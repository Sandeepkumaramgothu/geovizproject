{"ast":null,"code":"// src/components/preprocessData.js\n\nimport axios from 'axios';\nimport { MAPBOX_TOKEN } from './constants';\nimport * as turf from '@turf/turf';\nimport usStates from '../data/us-states.json'; // Ensure this path is correct\n\nconst extractCoordinates = geoLocation => {\n  if (!geoLocation) return {\n    latitude: null,\n    longitude: null\n  };\n  const regex = /POINT\\s*\\(\\s*([-.\\d]+)\\s+([-.\\d]+)\\s*\\)/i;\n  const match = geoLocation.match(regex);\n  if (match) {\n    return {\n      longitude: parseFloat(match[1]),\n      latitude: parseFloat(match[2])\n    };\n  }\n  return {\n    latitude: null,\n    longitude: null\n  };\n};\nconst geocodeLocation = async locationName => {\n  if (!locationName) return {\n    latitude: null,\n    longitude: null\n  };\n  try {\n    const response = await axios.get(`https://api.mapbox.com/geocoding/v5/mapbox.places/${encodeURIComponent(locationName)}.json`, {\n      params: {\n        access_token: MAPBOX_TOKEN,\n        limit: 1\n      }\n    });\n    const features = response.data.features;\n    if (features && features.length > 0) {\n      const [longitude, latitude] = features[0].center;\n      return {\n        latitude,\n        longitude\n      };\n    }\n    return {\n      latitude: null,\n      longitude: null\n    };\n  } catch (error) {\n    console.error('Geocoding error:', error);\n    return {\n      latitude: null,\n      longitude: null\n    };\n  }\n};\n\n// Function to determine state from coordinates using Turf.js\nconst getStateFromCoords = (latitude, longitude) => {\n  const point = turf.point([longitude, latitude]);\n  for (const feature of usStates.features) {\n    if (turf.booleanPointInPolygon(point, feature)) {\n      return feature.properties.name;\n    }\n  }\n  return null;\n};\nconst preprocessData = async (data, setProgress, locationColumn) => {\n  // Initialize progress\n  setProgress(prev => ({\n    ...prev,\n    preprocess: 0\n  }));\n  const limitedData = data.slice(0, 100000);\n  setProgress(prev => ({\n    ...prev,\n    preprocess: 10\n  }));\n  const possibleLatitudeFields = ['latitude', 'Latitude', 'lat', 'Lat'];\n  const possibleLongitudeFields = ['longitude', 'Longitude', 'lon', 'Lng', 'Long'];\n  let latitudeField = null;\n  let longitudeField = null;\n  if (limitedData.length > 0) {\n    latitudeField = possibleLatitudeFields.find(field => limitedData[0].hasOwnProperty(field));\n    longitudeField = possibleLongitudeFields.find(field => limitedData[0].hasOwnProperty(field));\n  } else {\n    alert('The dataset is empty.');\n    return [];\n  }\n  setProgress(prev => ({\n    ...prev,\n    preprocess: 20\n  }));\n  const requiredFields = [];\n  if (!latitudeField || !longitudeField) {\n    requiredFields.push(locationColumn);\n  }\n  const cleanData = limitedData.filter(row => {\n    return requiredFields.every(field => row.hasOwnProperty(field) && row[field] !== null && row[field] !== undefined && row[field] !== '');\n  });\n  if (cleanData.length === 0) {\n    alert('No valid data after filtering out rows with missing critical fields.');\n    return [];\n  }\n  setProgress(prev => ({\n    ...prev,\n    preprocess: 30\n  }));\n  if (!latitudeField || !longitudeField) {\n    if (cleanData.length > 0) {\n      latitudeField = possibleLatitudeFields.find(field => cleanData[0].hasOwnProperty(field));\n      longitudeField = possibleLongitudeFields.find(field => cleanData[0].hasOwnProperty(field));\n    }\n  }\n  const dataWithCoords = await Promise.all(cleanData.map(async item => {\n    let latitude = null;\n    let longitude = null;\n    if (latitudeField && longitudeField) {\n      latitude = parseFloat(item[latitudeField]);\n      longitude = parseFloat(item[longitudeField]);\n    } else if (item.GeoLocation) {\n      const coords = extractCoordinates(item.GeoLocation);\n      latitude = coords.latitude;\n      longitude = coords.longitude;\n    } else if (item[locationColumn] && locationColumn !== 'locationID') {\n      // Geocode if we have a location name\n      const coords = await geocodeLocation(item[locationColumn]);\n      latitude = coords.latitude;\n      longitude = coords.longitude;\n    }\n\n    // Remove any existing latitude and longitude fields to avoid confusion\n    possibleLatitudeFields.forEach(field => {\n      delete item[field];\n    });\n    possibleLongitudeFields.forEach(field => {\n      delete item[field];\n    });\n    return {\n      ...item,\n      latitude,\n      longitude\n    };\n  }));\n  setProgress(prev => ({\n    ...prev,\n    preprocess: 70\n  }));\n  const cleanDataWithCoords = dataWithCoords.filter(item => item.latitude !== null && item.longitude !== null && !isNaN(item.latitude) && !isNaN(item.longitude));\n  if (cleanDataWithCoords.length === 0) {\n    alert('No valid data after extracting coordinates.');\n    return [];\n  }\n\n  // Map each data point to its state using Turf.js\n  const stateDataMap = {};\n  const stateCoordsMap = {}; // To store state coordinates\n  const numericFields = new Set();\n  for (const item of cleanDataWithCoords) {\n    const latitude = parseFloat(item.latitude);\n    const longitude = parseFloat(item.longitude);\n    if (isNaN(latitude) || isNaN(longitude)) continue;\n    const stateName = getStateFromCoords(latitude, longitude);\n    if (!stateName) continue; // Skip if state couldn't be determined\n\n    // Aggregate data per state\n    if (!stateDataMap[stateName]) {\n      stateDataMap[stateName] = {\n        ...item\n      };\n      stateDataMap[stateName].state = stateName;\n      stateDataMap[stateName].count = 1;\n      stateCoordsMap[stateName] = {\n        latitude,\n        longitude\n      };\n    } else {\n      // Sum numeric fields\n      Object.keys(item).forEach(key => {\n        const value = parseFloat(item[key]);\n        if (!isNaN(value)) {\n          numericFields.add(key);\n          stateDataMap[stateName][key] = (stateDataMap[stateName][key] || 0) + value;\n        }\n      });\n      stateDataMap[stateName].count += 1;\n    }\n  }\n  setProgress(prev => ({\n    ...prev,\n    preprocess: 80\n  }));\n\n  // Calculate averages for numeric fields\n  const aggregatedData = Object.values(stateDataMap).map(item => {\n    const count = item.count || 1;\n    numericFields.forEach(key => {\n      const parsedValue = parseFloat(item[key]);\n      if (!isNaN(parsedValue)) {\n        item[key] = parsedValue / count;\n      } else {\n        item[key] = 0; // Assign 0 if value is invalid\n      }\n    });\n    return item;\n  });\n  if (aggregatedData.length === 0) {\n    alert('No data could be aggregated by state.');\n    return [];\n  }\n  setProgress(prev => ({\n    ...prev,\n    preprocess: 90\n  }));\n  setProgress(prev => ({\n    ...prev,\n    preprocess: 100\n  }));\n  return aggregatedData;\n};\nexport default preprocessData;","map":{"version":3,"names":["axios","MAPBOX_TOKEN","turf","usStates","extractCoordinates","geoLocation","latitude","longitude","regex","match","parseFloat","geocodeLocation","locationName","response","get","encodeURIComponent","params","access_token","limit","features","data","length","center","error","console","getStateFromCoords","point","feature","booleanPointInPolygon","properties","name","preprocessData","setProgress","locationColumn","prev","preprocess","limitedData","slice","possibleLatitudeFields","possibleLongitudeFields","latitudeField","longitudeField","find","field","hasOwnProperty","alert","requiredFields","push","cleanData","filter","row","every","undefined","dataWithCoords","Promise","all","map","item","GeoLocation","coords","forEach","cleanDataWithCoords","isNaN","stateDataMap","stateCoordsMap","numericFields","Set","stateName","state","count","Object","keys","key","value","add","aggregatedData","values","parsedValue"],"sources":["/Users/girishkumarpatchikoru/Desktop/projecthci/geovizproject/frontend/src/components/preprocessData.js"],"sourcesContent":["// src/components/preprocessData.js\n\nimport axios from 'axios';\nimport { MAPBOX_TOKEN } from './constants';\nimport * as turf from '@turf/turf';\nimport usStates from '../data/us-states.json'; // Ensure this path is correct\n\nconst extractCoordinates = (geoLocation) => {\n  if (!geoLocation) return { latitude: null, longitude: null };\n  const regex = /POINT\\s*\\(\\s*([-.\\d]+)\\s+([-.\\d]+)\\s*\\)/i;\n  const match = geoLocation.match(regex);\n  if (match) {\n    return {\n      longitude: parseFloat(match[1]),\n      latitude: parseFloat(match[2]),\n    };\n  }\n  return { latitude: null, longitude: null };\n};\n\nconst geocodeLocation = async (locationName) => {\n  if (!locationName) return { latitude: null, longitude: null };\n  try {\n    const response = await axios.get(\n      `https://api.mapbox.com/geocoding/v5/mapbox.places/${encodeURIComponent(\n        locationName\n      )}.json`,\n      {\n        params: {\n          access_token: MAPBOX_TOKEN,\n          limit: 1,\n        },\n      }\n    );\n    const features = response.data.features;\n    if (features && features.length > 0) {\n      const [longitude, latitude] = features[0].center;\n      return { latitude, longitude };\n    }\n    return { latitude: null, longitude: null };\n  } catch (error) {\n    console.error('Geocoding error:', error);\n    return { latitude: null, longitude: null };\n  }\n};\n\n// Function to determine state from coordinates using Turf.js\nconst getStateFromCoords = (latitude, longitude) => {\n  const point = turf.point([longitude, latitude]);\n  for (const feature of usStates.features) {\n    if (turf.booleanPointInPolygon(point, feature)) {\n      return feature.properties.name;\n    }\n  }\n  return null;\n};\n\nconst preprocessData = async (data, setProgress, locationColumn) => {\n  // Initialize progress\n  setProgress((prev) => ({ ...prev, preprocess: 0 }));\n\n  const limitedData = data.slice(0, 100000);\n\n  setProgress((prev) => ({ ...prev, preprocess: 10 }));\n\n  const possibleLatitudeFields = ['latitude', 'Latitude', 'lat', 'Lat'];\n  const possibleLongitudeFields = ['longitude', 'Longitude', 'lon', 'Lng', 'Long'];\n\n  let latitudeField = null;\n  let longitudeField = null;\n\n  if (limitedData.length > 0) {\n    latitudeField = possibleLatitudeFields.find((field) =>\n      limitedData[0].hasOwnProperty(field)\n    );\n    longitudeField = possibleLongitudeFields.find((field) =>\n      limitedData[0].hasOwnProperty(field)\n    );\n  } else {\n    alert('The dataset is empty.');\n    return [];\n  }\n\n  setProgress((prev) => ({ ...prev, preprocess: 20 }));\n\n  const requiredFields = [];\n  if (!latitudeField || !longitudeField) {\n    requiredFields.push(locationColumn);\n  }\n\n  const cleanData = limitedData.filter((row) => {\n    return requiredFields.every(\n      (field) =>\n        row.hasOwnProperty(field) &&\n        row[field] !== null &&\n        row[field] !== undefined &&\n        row[field] !== ''\n    );\n  });\n\n  if (cleanData.length === 0) {\n    alert('No valid data after filtering out rows with missing critical fields.');\n    return [];\n  }\n\n  setProgress((prev) => ({ ...prev, preprocess: 30 }));\n\n  if (!latitudeField || !longitudeField) {\n    if (cleanData.length > 0) {\n      latitudeField = possibleLatitudeFields.find((field) =>\n        cleanData[0].hasOwnProperty(field)\n      );\n      longitudeField = possibleLongitudeFields.find((field) =>\n        cleanData[0].hasOwnProperty(field)\n      );\n    }\n  }\n\n  const dataWithCoords = await Promise.all(\n    cleanData.map(async (item) => {\n      let latitude = null;\n      let longitude = null;\n\n      if (latitudeField && longitudeField) {\n        latitude = parseFloat(item[latitudeField]);\n        longitude = parseFloat(item[longitudeField]);\n      } else if (item.GeoLocation) {\n        const coords = extractCoordinates(item.GeoLocation);\n        latitude = coords.latitude;\n        longitude = coords.longitude;\n      } else if (item[locationColumn] && locationColumn !== 'locationID') {\n        // Geocode if we have a location name\n        const coords = await geocodeLocation(item[locationColumn]);\n        latitude = coords.latitude;\n        longitude = coords.longitude;\n      }\n\n      // Remove any existing latitude and longitude fields to avoid confusion\n      possibleLatitudeFields.forEach((field) => {\n        delete item[field];\n      });\n      possibleLongitudeFields.forEach((field) => {\n        delete item[field];\n      });\n\n      return { ...item, latitude, longitude };\n    })\n  );\n\n  setProgress((prev) => ({ ...prev, preprocess: 70 }));\n\n  const cleanDataWithCoords = dataWithCoords.filter(\n    (item) =>\n      item.latitude !== null &&\n      item.longitude !== null &&\n      !isNaN(item.latitude) &&\n      !isNaN(item.longitude)\n  );\n\n  if (cleanDataWithCoords.length === 0) {\n    alert('No valid data after extracting coordinates.');\n    return [];\n  }\n\n  // Map each data point to its state using Turf.js\n  const stateDataMap = {};\n  const stateCoordsMap = {}; // To store state coordinates\n  const numericFields = new Set();\n\n  for (const item of cleanDataWithCoords) {\n    const latitude = parseFloat(item.latitude);\n    const longitude = parseFloat(item.longitude);\n\n    if (isNaN(latitude) || isNaN(longitude)) continue;\n\n    const stateName = getStateFromCoords(latitude, longitude);\n\n    if (!stateName) continue; // Skip if state couldn't be determined\n\n    // Aggregate data per state\n    if (!stateDataMap[stateName]) {\n      stateDataMap[stateName] = { ...item };\n      stateDataMap[stateName].state = stateName;\n      stateDataMap[stateName].count = 1;\n      stateCoordsMap[stateName] = { latitude, longitude };\n    } else {\n      // Sum numeric fields\n      Object.keys(item).forEach((key) => {\n        const value = parseFloat(item[key]);\n        if (!isNaN(value)) {\n          numericFields.add(key);\n          stateDataMap[stateName][key] =\n            (stateDataMap[stateName][key] || 0) + value;\n        }\n      });\n      stateDataMap[stateName].count += 1;\n    }\n  }\n\n  setProgress((prev) => ({ ...prev, preprocess: 80 }));\n\n  // Calculate averages for numeric fields\n  const aggregatedData = Object.values(stateDataMap).map((item) => {\n    const count = item.count || 1;\n    numericFields.forEach((key) => {\n      const parsedValue = parseFloat(item[key]);\n      if (!isNaN(parsedValue)) {\n        item[key] = parsedValue / count;\n      } else {\n        item[key] = 0; // Assign 0 if value is invalid\n      }\n    });\n    return item;\n  });\n\n  if (aggregatedData.length === 0) {\n    alert('No data could be aggregated by state.');\n    return [];\n  }\n\n  setProgress((prev) => ({ ...prev, preprocess: 90 }));\n\n  setProgress((prev) => ({ ...prev, preprocess: 100 }));\n\n  return aggregatedData;\n};\n\nexport default preprocessData;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}
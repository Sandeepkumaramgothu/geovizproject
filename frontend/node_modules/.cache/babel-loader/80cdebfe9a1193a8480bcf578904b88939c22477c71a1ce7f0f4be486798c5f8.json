{"ast":null,"code":"// src/components/preprocessData.js\n\nimport axios from 'axios';\nimport { MAPBOX_TOKEN } from './constants';\n\n/**\n * Extracts latitude and longitude from a GeoLocation string if available.\n * @param {string} geoLocation - The GeoLocation string.\n * @returns {Object} - An object containing latitude and longitude.\n */\nconst extractCoordinates = geoLocation => {\n  if (!geoLocation) return {\n    latitude: null,\n    longitude: null\n  };\n  const regex = /POINT\\s*\\(\\s*([-.\\d]+)\\s+([-.\\d]+)\\s*\\)/i;\n  const match = geoLocation.match(regex);\n  if (match) {\n    return {\n      longitude: parseFloat(match[1]),\n      latitude: parseFloat(match[2])\n    };\n  }\n  return {\n    latitude: null,\n    longitude: null\n  };\n};\n\n/**\n * Geocodes a location name to obtain its latitude and longitude.\n * @param {string} locationName - The name of the location to geocode.\n * @returns {Object} - An object containing latitude and longitude.\n */\nconst geocodeLocation = async locationName => {\n  if (!locationName) return {\n    latitude: null,\n    longitude: null\n  };\n  try {\n    const response = await axios.get(`https://api.mapbox.com/geocoding/v5/mapbox.places/${encodeURIComponent(locationName)}.json`, {\n      params: {\n        access_token: MAPBOX_TOKEN,\n        limit: 1\n      }\n    });\n    const features = response.data.features;\n    if (features && features.length > 0) {\n      const [longitude, latitude] = features[0].center;\n      return {\n        latitude,\n        longitude\n      };\n    }\n    return {\n      latitude: null,\n      longitude: null\n    };\n  } catch (error) {\n    console.error('Geocoding error:', error);\n    return {\n      latitude: null,\n      longitude: null\n    };\n  }\n};\n\n/**\n * Preprocesses the dataset by aggregating data state-wise.\n * @param {Array} data - The raw dataset.\n * @param {Function} setProgress - Function to update progress state.\n * @param {string} locationColumn - The column name containing location information.\n * @returns {Array} - The aggregated dataset.\n */\nconst preprocessData = async (data, setProgress, locationColumn) => {\n  // Initialize progress\n  setProgress(prev => ({\n    ...prev,\n    preprocess: 0\n  }));\n\n  // Limit data to the first 20 rows as per your dataset\n  const limitedData = data.slice(0, 20);\n  setProgress(prev => ({\n    ...prev,\n    preprocess: 10\n  }));\n\n  // Identify unique states\n  const uniqueStates = new Set();\n  const stateCoordinates = {}; // To store state centroid coordinates\n  const aggregatedStateData = {}; // To store aggregated data per state\n  const numericFields = new Set();\n  for (const item of limitedData) {\n    let stateName = null;\n    if (item.state || item.State) {\n      stateName = item.state || item.State;\n    } else if (item.latitude && item.longitude) {\n      const latitude = parseFloat(item.latitude);\n      const longitude = parseFloat(item.longitude);\n      if (!isNaN(latitude) && !isNaN(longitude)) {\n        // Reverse geocode to get state name\n        try {\n          const response = await axios.get(`https://api.mapbox.com/geocoding/v5/mapbox.places/${longitude},${latitude}.json`, {\n            params: {\n              access_token: MAPBOX_TOKEN,\n              types: 'region',\n              limit: 1\n            }\n          });\n          const features = response.data.features;\n          if (features && features.length > 0) {\n            stateName = features[0].text;\n          }\n        } catch (error) {\n          console.error('Reverse geocoding error:', error);\n        }\n      }\n    }\n    if (stateName) {\n      uniqueStates.add(stateName);\n      if (!aggregatedStateData[stateName]) {\n        aggregatedStateData[stateName] = {\n          state: stateName,\n          count: 0\n        };\n      }\n      aggregatedStateData[stateName].count += 1;\n\n      // Aggregate numeric fields\n      Object.keys(item).forEach(key => {\n        if (key.toLowerCase() === 'state' || key.toLowerCase() === 'latitude' || key.toLowerCase() === 'longitude') {\n          return; // Skip non-numeric fields\n        }\n        const value = parseFloat(item[key]);\n        if (!isNaN(value)) {\n          numericFields.add(key);\n          if (!aggregatedStateData[stateName][key]) {\n            aggregatedStateData[stateName][key] = value;\n          } else {\n            aggregatedStateData[stateName][key] += value;\n          }\n        }\n      });\n    }\n  }\n  setProgress(prev => ({\n    ...prev,\n    preprocess: 40\n  }));\n\n  // Calculate averages for numeric fields\n  const finalAggregatedData = Object.values(aggregatedStateData).map(stateData => {\n    const count = stateData.count || 1;\n    const averagedData = {\n      state: stateData.state\n    };\n    numericFields.forEach(field => {\n      averagedData[field] = stateData[field] / count;\n    });\n    return averagedData;\n  });\n  setProgress(prev => ({\n    ...prev,\n    preprocess: 60\n  }));\n\n  // Geocode each unique state to get its centroid coordinates\n  for (const stateName of uniqueStates) {\n    if (stateCoordinates[stateName]) continue; // Skip if already geocoded\n    const coords = await geocodeLocation(stateName);\n    if (coords.latitude && coords.longitude) {\n      stateCoordinates[stateName] = {\n        latitude: coords.latitude,\n        longitude: coords.longitude\n      };\n    }\n    // To respect rate limits, introduce a short delay between API calls\n    await new Promise(resolve => setTimeout(resolve, 250)); // 250ms delay\n  }\n  setProgress(prev => ({\n    ...prev,\n    preprocess: 80\n  }));\n\n  // Attach coordinates to the aggregated data\n  const finalDataWithCoords = finalAggregatedData.map(item => {\n    const coords = stateCoordinates[item.state];\n    if (coords) {\n      return {\n        ...item,\n        latitude: coords.latitude,\n        longitude: coords.longitude\n      };\n    }\n    return null;\n  }).filter(item => item !== null);\n  setProgress(prev => ({\n    ...prev,\n    preprocess: 100\n  }));\n  return finalDataWithCoords;\n};\nexport default preprocessData;","map":{"version":3,"names":["axios","MAPBOX_TOKEN","extractCoordinates","geoLocation","latitude","longitude","regex","match","parseFloat","geocodeLocation","locationName","response","get","encodeURIComponent","params","access_token","limit","features","data","length","center","error","console","preprocessData","setProgress","locationColumn","prev","preprocess","limitedData","slice","uniqueStates","Set","stateCoordinates","aggregatedStateData","numericFields","item","stateName","state","State","isNaN","types","text","add","count","Object","keys","forEach","key","toLowerCase","value","finalAggregatedData","values","map","stateData","averagedData","field","coords","Promise","resolve","setTimeout","finalDataWithCoords","filter"],"sources":["/Users/girishkumarpatchikoru/Desktop/projecthci/geovizproject/frontend/src/components/preprocessData.js"],"sourcesContent":["// src/components/preprocessData.js\n\nimport axios from 'axios';\nimport { MAPBOX_TOKEN } from './constants';\n\n/**\n * Extracts latitude and longitude from a GeoLocation string if available.\n * @param {string} geoLocation - The GeoLocation string.\n * @returns {Object} - An object containing latitude and longitude.\n */\nconst extractCoordinates = (geoLocation) => {\n  if (!geoLocation) return { latitude: null, longitude: null };\n  const regex = /POINT\\s*\\(\\s*([-.\\d]+)\\s+([-.\\d]+)\\s*\\)/i;\n  const match = geoLocation.match(regex);\n  if (match) {\n    return {\n      longitude: parseFloat(match[1]),\n      latitude: parseFloat(match[2]),\n    };\n  }\n  return { latitude: null, longitude: null };\n};\n\n/**\n * Geocodes a location name to obtain its latitude and longitude.\n * @param {string} locationName - The name of the location to geocode.\n * @returns {Object} - An object containing latitude and longitude.\n */\nconst geocodeLocation = async (locationName) => {\n  if (!locationName) return { latitude: null, longitude: null };\n  try {\n    const response = await axios.get(\n      `https://api.mapbox.com/geocoding/v5/mapbox.places/${encodeURIComponent(\n        locationName\n      )}.json`,\n      {\n        params: {\n          access_token: MAPBOX_TOKEN,\n          limit: 1,\n        },\n      }\n    );\n    const features = response.data.features;\n    if (features && features.length > 0) {\n      const [longitude, latitude] = features[0].center;\n      return { latitude, longitude };\n    }\n    return { latitude: null, longitude: null };\n  } catch (error) {\n    console.error('Geocoding error:', error);\n    return { latitude: null, longitude: null };\n  }\n};\n\n/**\n * Preprocesses the dataset by aggregating data state-wise.\n * @param {Array} data - The raw dataset.\n * @param {Function} setProgress - Function to update progress state.\n * @param {string} locationColumn - The column name containing location information.\n * @returns {Array} - The aggregated dataset.\n */\nconst preprocessData = async (data, setProgress, locationColumn) => {\n  // Initialize progress\n  setProgress((prev) => ({ ...prev, preprocess: 0 }));\n\n  // Limit data to the first 20 rows as per your dataset\n  const limitedData = data.slice(0, 20);\n\n  setProgress((prev) => ({ ...prev, preprocess: 10 }));\n\n  // Identify unique states\n  const uniqueStates = new Set();\n  const stateCoordinates = {}; // To store state centroid coordinates\n  const aggregatedStateData = {}; // To store aggregated data per state\n  const numericFields = new Set();\n\n  for (const item of limitedData) {\n    let stateName = null;\n\n    if (item.state || item.State) {\n      stateName = item.state || item.State;\n    } else if (item.latitude && item.longitude) {\n      const latitude = parseFloat(item.latitude);\n      const longitude = parseFloat(item.longitude);\n      if (!isNaN(latitude) && !isNaN(longitude)) {\n        // Reverse geocode to get state name\n        try {\n          const response = await axios.get(\n            `https://api.mapbox.com/geocoding/v5/mapbox.places/${longitude},${latitude}.json`,\n            {\n              params: {\n                access_token: MAPBOX_TOKEN,\n                types: 'region',\n                limit: 1,\n              },\n            }\n          );\n          const features = response.data.features;\n          if (features && features.length > 0) {\n            stateName = features[0].text;\n          }\n        } catch (error) {\n          console.error('Reverse geocoding error:', error);\n        }\n      }\n    }\n\n    if (stateName) {\n      uniqueStates.add(stateName);\n      if (!aggregatedStateData[stateName]) {\n        aggregatedStateData[stateName] = { state: stateName, count: 0 };\n      }\n      aggregatedStateData[stateName].count += 1;\n\n      // Aggregate numeric fields\n      Object.keys(item).forEach((key) => {\n        if (key.toLowerCase() === 'state' || key.toLowerCase() === 'latitude' || key.toLowerCase() === 'longitude') {\n          return; // Skip non-numeric fields\n        }\n        const value = parseFloat(item[key]);\n        if (!isNaN(value)) {\n          numericFields.add(key);\n          if (!aggregatedStateData[stateName][key]) {\n            aggregatedStateData[stateName][key] = value;\n          } else {\n            aggregatedStateData[stateName][key] += value;\n          }\n        }\n      });\n    }\n  }\n\n  setProgress((prev) => ({ ...prev, preprocess: 40 }));\n\n  // Calculate averages for numeric fields\n  const finalAggregatedData = Object.values(aggregatedStateData).map((stateData) => {\n    const count = stateData.count || 1;\n    const averagedData = { state: stateData.state };\n    numericFields.forEach((field) => {\n      averagedData[field] = stateData[field] / count;\n    });\n    return averagedData;\n  });\n\n  setProgress((prev) => ({ ...prev, preprocess: 60 }));\n\n  // Geocode each unique state to get its centroid coordinates\n  for (const stateName of uniqueStates) {\n    if (stateCoordinates[stateName]) continue; // Skip if already geocoded\n    const coords = await geocodeLocation(stateName);\n    if (coords.latitude && coords.longitude) {\n      stateCoordinates[stateName] = { latitude: coords.latitude, longitude: coords.longitude };\n    }\n    // To respect rate limits, introduce a short delay between API calls\n    await new Promise((resolve) => setTimeout(resolve, 250)); // 250ms delay\n  }\n\n  setProgress((prev) => ({ ...prev, preprocess: 80 }));\n\n  // Attach coordinates to the aggregated data\n  const finalDataWithCoords = finalAggregatedData\n    .map((item) => {\n      const coords = stateCoordinates[item.state];\n      if (coords) {\n        return { ...item, latitude: coords.latitude, longitude: coords.longitude };\n      }\n      return null;\n    })\n    .filter((item) => item !== null);\n\n  setProgress((prev) => ({ ...prev, preprocess: 100 }));\n\n  return finalDataWithCoords;\n};\n\nexport default preprocessData;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}
{"ast":null,"code":"// src/components/preprocessData.js\n\nimport axios from 'axios';\nimport { MAPBOX_TOKEN } from './constants';\n\n// Function to introduce a delay (in milliseconds)\nconst delay = ms => new Promise(resolve => setTimeout(resolve, ms));\n\n// Cache object to store geocoding results and avoid duplicate API calls\nconst geocodeCache = {};\n\n// Function to handle geocoding with rate-limiting and caching\nconst geocodeLocationWithRateLimit = async (locationName, delayMs = 200) => {\n  if (geocodeCache[locationName]) {\n    return geocodeCache[locationName];\n  }\n  try {\n    const response = await axios.get(`https://api.mapbox.com/geocoding/v5/mapbox.places/${encodeURIComponent(locationName)}.json`, {\n      params: {\n        access_token: MAPBOX_TOKEN,\n        limit: 1\n      }\n    });\n    const features = response.data.features;\n    if (features && features.length > 0) {\n      const [longitude, latitude] = features[0].center;\n      const result = {\n        latitude,\n        longitude\n      };\n      geocodeCache[locationName] = result; // Cache the result\n      return result;\n    }\n  } catch (error) {\n    if (error.response && error.response.status === 429) {\n      console.warn('Rate limit exceeded. Retrying after delay...');\n      await delay(delayMs);\n      return geocodeLocationWithRateLimit(locationName, delayMs * 2); // Exponential backoff\n    }\n    console.error('Geocoding error:', error);\n  }\n\n  // Return null coordinates if geocoding fails\n  return {\n    latitude: null,\n    longitude: null\n  };\n};\n\n// Function to extract coordinates from GeoLocation field if present\nconst extractCoordinates = geoLocation => {\n  if (!geoLocation) return {\n    latitude: null,\n    longitude: null\n  };\n  const regex = /POINT\\s*\\(\\s*([-.\\d]+)\\s+([-.\\d]+)\\s*\\)/i;\n  const match = geoLocation.match(regex);\n  if (match) {\n    return {\n      longitude: parseFloat(match[1]),\n      latitude: parseFloat(match[2])\n    };\n  }\n  return {\n    latitude: null,\n    longitude: null\n  };\n};\n\n// Main preprocess function\nconst preprocessData = async (data, setProgress) => {\n  // Initialize progress\n  setProgress(prev => ({\n    ...prev,\n    preprocess: 0\n  }));\n\n  // Define possible field names for latitude and longitude\n  const possibleLatitudeFields = ['latitude', 'Latitude', 'lat', 'Lat'];\n  const possibleLongitudeFields = ['longitude', 'Longitude', 'lon', 'Lng', 'Long'];\n  const possibleStateFields = ['state', 'STATE_NAME', 'state_id', 'STATE_CODE'];\n  const possibleCityFields = ['city', 'CITY', 'city_ascii'];\n\n  // Identify actual fields in the dataset\n  const fields = data[0] ? Object.keys(data[0]) : [];\n  const latitudeField = possibleLatitudeFields.find(field => fields.includes(field));\n  const longitudeField = possibleLongitudeFields.find(field => fields.includes(field));\n  const locationField = possibleStateFields.concat(possibleCityFields).find(field => fields.includes(field));\n  if (!latitudeField || !longitudeField) {\n    console.error('Critical geolocation fields missing');\n    return []; // Exit if essential fields are missing\n  }\n  setProgress(prev => ({\n    ...prev,\n    preprocess: 10\n  }));\n\n  // Filter and process data\n  const processedData = data.filter(item => {\n    return item[latitudeField] && item[longitudeField] && (item[locationField] || locationField);\n  }).map(item => {\n    // Extract and assign coordinates\n    const latitude = parseFloat(item[latitudeField]);\n    const longitude = parseFloat(item[longitudeField]);\n    return {\n      ...item,\n      latitude,\n      longitude\n    };\n  });\n  console.log('Processed Data Length:', processedData.length);\n  setProgress(prev => ({\n    ...prev,\n    preprocess: 100\n  }));\n  return processedData;\n};\nexport default preprocessData;","map":{"version":3,"names":["axios","MAPBOX_TOKEN","delay","ms","Promise","resolve","setTimeout","geocodeCache","geocodeLocationWithRateLimit","locationName","delayMs","response","get","encodeURIComponent","params","access_token","limit","features","data","length","longitude","latitude","center","result","error","status","console","warn","extractCoordinates","geoLocation","regex","match","parseFloat","preprocessData","setProgress","prev","preprocess","possibleLatitudeFields","possibleLongitudeFields","possibleStateFields","possibleCityFields","fields","Object","keys","latitudeField","find","field","includes","longitudeField","locationField","concat","processedData","filter","item","map","log"],"sources":["/Users/girishkumarpatchikoru/Desktop/projecthci/geovizproject/frontend/src/components/preprocessData.js"],"sourcesContent":["// src/components/preprocessData.js\n\nimport axios from 'axios';\nimport { MAPBOX_TOKEN } from './constants';\n\n// Function to introduce a delay (in milliseconds)\nconst delay = (ms) => new Promise((resolve) => setTimeout(resolve, ms));\n\n// Cache object to store geocoding results and avoid duplicate API calls\nconst geocodeCache = {};\n\n// Function to handle geocoding with rate-limiting and caching\nconst geocodeLocationWithRateLimit = async (locationName, delayMs = 200) => {\n  if (geocodeCache[locationName]) {\n    return geocodeCache[locationName];\n  }\n\n  try {\n    const response = await axios.get(\n      `https://api.mapbox.com/geocoding/v5/mapbox.places/${encodeURIComponent(\n        locationName\n      )}.json`,\n      {\n        params: {\n          access_token: MAPBOX_TOKEN,\n          limit: 1,\n        },\n      }\n    );\n\n    const features = response.data.features;\n    if (features && features.length > 0) {\n      const [longitude, latitude] = features[0].center;\n      const result = { latitude, longitude };\n      geocodeCache[locationName] = result; // Cache the result\n      return result;\n    }\n  } catch (error) {\n    if (error.response && error.response.status === 429) {\n      console.warn('Rate limit exceeded. Retrying after delay...');\n      await delay(delayMs);\n      return geocodeLocationWithRateLimit(locationName, delayMs * 2); // Exponential backoff\n    }\n    console.error('Geocoding error:', error);\n  }\n\n  // Return null coordinates if geocoding fails\n  return { latitude: null, longitude: null };\n};\n\n// Function to extract coordinates from GeoLocation field if present\nconst extractCoordinates = (geoLocation) => {\n  if (!geoLocation) return { latitude: null, longitude: null };\n  const regex = /POINT\\s*\\(\\s*([-.\\d]+)\\s+([-.\\d]+)\\s*\\)/i;\n  const match = geoLocation.match(regex);\n  if (match) {\n    return {\n      longitude: parseFloat(match[1]),\n      latitude: parseFloat(match[2]),\n    };\n  }\n  return { latitude: null, longitude: null };\n};\n\n// Main preprocess function\nconst preprocessData = async (data, setProgress) => {\n  // Initialize progress\n  setProgress((prev) => ({ ...prev, preprocess: 0 }));\n\n  // Define possible field names for latitude and longitude\n  const possibleLatitudeFields = ['latitude', 'Latitude', 'lat', 'Lat'];\n  const possibleLongitudeFields = ['longitude', 'Longitude', 'lon', 'Lng', 'Long'];\n  const possibleStateFields = ['state', 'STATE_NAME', 'state_id', 'STATE_CODE'];\n  const possibleCityFields = ['city', 'CITY', 'city_ascii'];\n\n  // Identify actual fields in the dataset\n  const fields = data[0] ? Object.keys(data[0]) : [];\n  const latitudeField = possibleLatitudeFields.find(field => fields.includes(field));\n  const longitudeField = possibleLongitudeFields.find(field => fields.includes(field));\n  const locationField = possibleStateFields.concat(possibleCityFields).find(field => fields.includes(field));\n\n  if (!latitudeField || !longitudeField) {\n    console.error('Critical geolocation fields missing');\n    return []; // Exit if essential fields are missing\n  }\n\n  setProgress((prev) => ({ ...prev, preprocess: 10 }));\n\n  // Filter and process data\n  const processedData = data.filter(item => {\n    return item[latitudeField] && item[longitudeField] && (item[locationField] || locationField);\n  }).map(item => {\n    // Extract and assign coordinates\n    const latitude = parseFloat(item[latitudeField]);\n    const longitude = parseFloat(item[longitudeField]);\n    return { ...item, latitude, longitude };\n  });\n\n  console.log('Processed Data Length:', processedData.length);\n\n  setProgress((prev) => ({ ...prev, preprocess: 100 }));\n  return processedData;\n};\n\nexport default preprocessData;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}
{"ast":null,"code":"var _jsxFileName = \"/Users/girishkumarpatchikoru/Desktop/projecthci/geovizproject/frontend/src/components/MapView.js\",\n  _s = $RefreshSig$();\n// src/components/MapView.js\n\nimport React, { useEffect, useState, useCallback } from 'react';\nimport MapComponent from './MapComponent';\nimport Controls from './Controls';\nimport styles from './styles';\nimport preprocessData from './preprocessData';\nimport Papa from 'papaparse';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst MapView = () => {\n  _s();\n  // State Variables\n  const [geoData, setGeoData] = useState([]);\n  const [numericHeaders, setNumericHeaders] = useState([]);\n  const [stringHeaders, setStringHeaders] = useState([]);\n  const [selectedLocation, setSelectedLocation] = useState(null);\n  const [chartType, setChartType] = useState('Bar');\n  const [chartData, setChartData] = useState(null);\n  const [totalRows, setTotalRows] = useState(0);\n  const [totalColumns, setTotalColumns] = useState(0);\n  const [progress, setProgress] = useState({\n    upload: 0,\n    preprocess: 0,\n    geocode: 0\n  });\n  const [progressMessages, setProgressMessages] = useState({\n    upload: '',\n    preprocess: '',\n    geocode: ''\n  });\n  const [cityList, setCityList] = useState([]);\n  const [selectedCity1, setSelectedCity1] = useState('');\n  const [selectedCity2, setSelectedCity2] = useState('');\n  const [locationColumn, setLocationColumn] = useState('');\n  const [markersAdded, setMarkersAdded] = useState(false);\n\n  // Preprocess Data Function\n  const handlePreprocess = useCallback(async rawData => {\n    // Determine the location column dynamically\n    const possibleLocationColumns = ['LocationDesc', 'LocationAbbr', 'state', 'State', 'city', 'City', 'Country', 'Country Name', 'Country Code', 'Address', 'Place', 'GeoLocation'\n    // Include more possible location columns if necessary\n    ];\n    let detectedLocationColumn = possibleLocationColumns.find(col => rawData[0] && rawData[0].hasOwnProperty(col));\n\n    // If no location column is found, use 'locationID'\n    if (!detectedLocationColumn) {\n      detectedLocationColumn = 'locationID';\n    }\n    setLocationColumn(detectedLocationColumn);\n    console.log('Detected Location Column:', detectedLocationColumn);\n\n    // Preprocess data\n    const processedData = await preprocessData(rawData, setProgress, detectedLocationColumn);\n    if (!processedData || processedData.length === 0) {\n      alert('No valid data after preprocessing.');\n      return;\n    }\n    setGeoData(processedData);\n\n    // Identify numeric and string headers\n    if (processedData.length > 0) {\n      const headers = Object.keys(processedData[0]);\n      const numeric = [];\n      const strings = [];\n      headers.forEach(header => {\n        if (['latitude', 'longitude', 'GeoLocation', 'locationID'].includes(header)) return;\n        const isNumeric = processedData.every(item => {\n          const value = parseFloat(item[header]);\n          return !isNaN(value);\n        });\n        if (isNumeric) {\n          numeric.push(header);\n        } else {\n          strings.push(header);\n        }\n      });\n      setNumericHeaders(numeric);\n      setStringHeaders(strings);\n      setTotalRows(processedData.length);\n      setTotalColumns(headers.length);\n\n      // Extract unique locations for comparison\n      const uniqueLocations = [...new Set(processedData.map(item => item[detectedLocationColumn]).filter(Boolean))];\n      setCityList(uniqueLocations);\n    } else {\n      alert('No data available after filtering.');\n    }\n\n    // Reset markersAdded state when new data is uploaded\n    setMarkersAdded(false);\n  }, []);\n\n  // Generate Chart Data for Selected Location\n  const generateChartData = useCallback(() => {\n    if (selectedLocation) {\n      const locationValues = numericHeaders.map(header => ({\n        label: header,\n        value: parseFloat(selectedLocation[header]) || 0\n      }));\n\n      // Normalize data for chart display (0.5% to 10%)\n      const dataMin = 0; // Minimum data value\n      const dataMax = Math.max(...locationValues.map(item => item.value));\n      const range = dataMax - dataMin || 1; // Avoid division by zero\n\n      const normalizedValues = locationValues.map(item => ({\n        label: item.label,\n        normalizedValue: (item.value - dataMin) / range * 9.5 + 0.5,\n        actualValue: item.value // Keep the actual value\n      }));\n      setChartData({\n        labels: normalizedValues.map(item => item.label),\n        datasets: [{\n          label: getLocationLabel(selectedLocation),\n          data: normalizedValues.map(item => item.normalizedValue),\n          actualValues: normalizedValues.map(item => item.actualValue),\n          // Store actual values\n          backgroundColor: ['rgba(255, 99, 132, 0.5)', 'rgba(54, 162, 235, 0.5)', 'rgba(255, 206, 86, 0.5)', 'rgba(75, 192, 192, 0.5)', 'rgba(153, 102, 255, 0.5)', 'rgba(255, 159, 64, 0.5)'],\n          borderColor: ['rgba(255, 99, 132, 1)', 'rgba(54, 162, 235, 1)', 'rgba(255, 206, 86, 1)', 'rgba(75, 192, 192, 1)', 'rgba(153, 102, 255, 1)', 'rgba(255, 159, 64, 1)'],\n          borderWidth: 1\n        }]\n      });\n    }\n  }, [selectedLocation, numericHeaders]);\n\n  // Generate a human-readable label for the location\n  const getLocationLabel = useCallback(data => {\n    if (data[locationColumn]) return data[locationColumn];\n    if (data.city) return data.city;\n    if (data.state) return data.state;\n    if (data.address) return data.address;\n    return `Lat: ${parseFloat(data.latitude).toFixed(2)}, Lng: ${parseFloat(data.longitude).toFixed(2)}`;\n  }, [locationColumn]);\n\n  // Handle File Upload\n  const handleFileUpload = useCallback(event => {\n    setProgress({\n      upload: 0,\n      preprocess: 0,\n      geocode: 0\n    });\n    setProgressMessages({\n      upload: '',\n      preprocess: '',\n      geocode: ''\n    });\n    const file = event.target.files[0];\n    if (file) {\n      const fileExtension = file.name.split('.').pop().toLowerCase();\n      if (fileExtension === 'json') {\n        const reader = new FileReader();\n        reader.onload = async e => {\n          try {\n            const data = JSON.parse(e.target.result);\n            setProgress(prev => ({\n              ...prev,\n              upload: 100\n            }));\n            setProgressMessages(prev => ({\n              ...prev,\n              upload: 'Dataset uploaded successfully.'\n            }));\n            await handlePreprocess(data);\n          } catch (error) {\n            console.error('Invalid JSON format:', error);\n            alert('Error: Uploaded file is not valid JSON.');\n          }\n        };\n        reader.readAsText(file);\n      } else if (fileExtension === 'csv') {\n        Papa.parse(file, {\n          header: true,\n          skipEmptyLines: true,\n          beforeFirstChunk: chunk => {\n            // Handle datasets with metadata rows\n            const lines = chunk.trim().split('\\n');\n            const dataStartIndex = lines.findIndex(line => line.startsWith('Country Name') || line.startsWith('state') || line.startsWith('RowId'));\n            if (dataStartIndex > 0) {\n              return lines.slice(dataStartIndex).join('\\n');\n            }\n            return chunk;\n          },\n          complete: async results => {\n            setProgress(prev => ({\n              ...prev,\n              upload: 100\n            }));\n            setProgressMessages(prev => ({\n              ...prev,\n              upload: 'Dataset uploaded successfully.'\n            }));\n            await handlePreprocess(results.data);\n          },\n          error: error => {\n            console.error('CSV parsing error:', error);\n            alert('Error: Failed to parse CSV file.');\n          }\n        });\n      } else {\n        alert('Please upload a valid JSON or CSV file.');\n      }\n    }\n  }, [handlePreprocess]);\n\n  // Monitor Progress Updates\n  useEffect(() => {\n    if (progress.preprocess === 100) {\n      setProgressMessages(prev => ({\n        ...prev,\n        preprocess: 'Preprocessing completed.'\n      }));\n    }\n  }, [progress.preprocess]);\n  useEffect(() => {\n    if (progress.geocode === 100) {\n      setProgressMessages(prev => ({\n        ...prev,\n        geocode: 'Locations marked on the map.'\n      }));\n    }\n  }, [progress.geocode]);\n\n  // Handle Location Selection from Map\n  const handleLocationSelect = useCallback(locationData => {\n    // Clear city selections if a map marker is selected\n    setSelectedCity1('');\n    setSelectedCity2('');\n    if (selectedLocation && selectedLocation.locationID === locationData.locationID) {\n      setSelectedLocation(null); // Deselect\n      setChartData(null);\n    } else {\n      setSelectedLocation(locationData);\n      setChartData(null);\n    }\n  }, [selectedLocation]);\n\n  // Handle Location Comparison Selection\n  const handleCitySelection = useCallback(() => {\n    if (selectedCity1 && selectedCity2) {\n      const data1 = geoData.filter(item => item[locationColumn] === selectedCity1);\n      const data2 = geoData.filter(item => item[locationColumn] === selectedCity2);\n      if (data1.length === 0 || data2.length === 0) {\n        alert('One or both selected locations have no data.');\n        return;\n      }\n\n      // Aggregate data (e.g., average)\n      const aggregatedData1 = {};\n      const aggregatedData2 = {};\n      numericHeaders.forEach(header => {\n        const values1 = data1.map(item => parseFloat(item[header]) || 0);\n        const values2 = data2.map(item => parseFloat(item[header]) || 0);\n        const avg1 = values1.reduce((a, b) => a + b, 0) / (values1.length || 1);\n        const avg2 = values2.reduce((a, b) => a + b, 0) / (values2.length || 1);\n        aggregatedData1[header] = avg1;\n        aggregatedData2[header] = avg2;\n      });\n\n      // Normalize data for chart display (0.5% to 10%)\n      const dataMin = 0; // Minimum data value\n      const dataMax = Math.max(...Object.values(aggregatedData1), ...Object.values(aggregatedData2));\n      const range = dataMax - dataMin || 1; // Avoid division by zero\n\n      const normalizedData1 = {};\n      const normalizedData2 = {};\n      const actualData1 = {};\n      const actualData2 = {};\n      numericHeaders.forEach(header => {\n        normalizedData1[header] = (aggregatedData1[header] - dataMin) / range * 9.5 + 0.5;\n        normalizedData2[header] = (aggregatedData2[header] - dataMin) / range * 9.5 + 0.5;\n        actualData1[header] = aggregatedData1[header];\n        actualData2[header] = aggregatedData2[header];\n      });\n\n      // Prepare chart data\n      const labels = numericHeaders;\n      const dataSet = {\n        labels,\n        datasets: [{\n          label: selectedCity1,\n          data: numericHeaders.map(header => normalizedData1[header]),\n          actualValues: numericHeaders.map(header => actualData1[header]),\n          backgroundColor: 'rgba(255, 99, 132, 0.5)',\n          borderColor: 'rgba(255, 99, 132, 1)',\n          borderWidth: 1\n        }, {\n          label: selectedCity2,\n          data: numericHeaders.map(header => normalizedData2[header]),\n          actualValues: numericHeaders.map(header => actualData2[header]),\n          backgroundColor: 'rgba(54, 162, 235, 0.5)',\n          borderColor: 'rgba(54, 162, 235, 1)',\n          borderWidth: 1\n        }]\n      };\n      setChartData(dataSet);\n      setSelectedLocation(null); // Deselect any single location\n    }\n  }, [selectedCity1, selectedCity2, geoData, locationColumn, numericHeaders]);\n\n  // Trigger Chart Data Generation\n  useEffect(() => {\n    generateChartData();\n  }, [generateChartData, chartType]);\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    style: styles.container,\n    children: [/*#__PURE__*/_jsxDEV(MapComponent, {\n      geoData: geoData,\n      selectedLocation: selectedLocation,\n      handleLocationSelect: handleLocationSelect,\n      markersAdded: markersAdded,\n      setMarkersAdded: setMarkersAdded\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 387,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(Controls, {\n      progress: progress,\n      progressMessages: progressMessages,\n      handleFileUpload: handleFileUpload,\n      geoData: geoData,\n      totalRows: totalRows,\n      totalColumns: totalColumns,\n      numericHeaders: numericHeaders,\n      stringHeaders: stringHeaders,\n      cityList: cityList,\n      selectedCity1: selectedCity1,\n      selectedCity2: selectedCity2,\n      setSelectedCity1: setSelectedCity1,\n      setSelectedCity2: setSelectedCity2,\n      handleCitySelection: handleCitySelection,\n      chartType: chartType,\n      setChartType: setChartType,\n      chartData: chartData\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 394,\n      columnNumber: 7\n    }, this)]\n  }, void 0, true, {\n    fileName: _jsxFileName,\n    lineNumber: 386,\n    columnNumber: 5\n  }, this);\n};\n_s(MapView, \"ci+ihse937xW6NvmT8qgQx9abdg=\");\n_c = MapView;\nexport default MapView;\nvar _c;\n$RefreshReg$(_c, \"MapView\");","map":{"version":3,"names":["React","useEffect","useState","useCallback","MapComponent","Controls","styles","preprocessData","Papa","jsxDEV","_jsxDEV","MapView","_s","geoData","setGeoData","numericHeaders","setNumericHeaders","stringHeaders","setStringHeaders","selectedLocation","setSelectedLocation","chartType","setChartType","chartData","setChartData","totalRows","setTotalRows","totalColumns","setTotalColumns","progress","setProgress","upload","preprocess","geocode","progressMessages","setProgressMessages","cityList","setCityList","selectedCity1","setSelectedCity1","selectedCity2","setSelectedCity2","locationColumn","setLocationColumn","markersAdded","setMarkersAdded","handlePreprocess","rawData","possibleLocationColumns","detectedLocationColumn","find","col","hasOwnProperty","console","log","processedData","length","alert","headers","Object","keys","numeric","strings","forEach","header","includes","isNumeric","every","item","value","parseFloat","isNaN","push","uniqueLocations","Set","map","filter","Boolean","generateChartData","locationValues","label","dataMin","dataMax","Math","max","range","normalizedValues","normalizedValue","actualValue","labels","datasets","getLocationLabel","data","actualValues","backgroundColor","borderColor","borderWidth","city","state","address","latitude","toFixed","longitude","handleFileUpload","event","file","target","files","fileExtension","name","split","pop","toLowerCase","reader","FileReader","onload","e","JSON","parse","result","prev","error","readAsText","skipEmptyLines","beforeFirstChunk","chunk","lines","trim","dataStartIndex","findIndex","line","startsWith","slice","join","complete","results","handleLocationSelect","locationData","locationID","handleCitySelection","data1","data2","aggregatedData1","aggregatedData2","values1","values2","avg1","reduce","a","b","avg2","values","normalizedData1","normalizedData2","actualData1","actualData2","dataSet","style","container","children","fileName","_jsxFileName","lineNumber","columnNumber","_c","$RefreshReg$"],"sources":["/Users/girishkumarpatchikoru/Desktop/projecthci/geovizproject/frontend/src/components/MapView.js"],"sourcesContent":["// src/components/MapView.js\r\n\r\nimport React, { useEffect, useState, useCallback } from 'react';\r\nimport MapComponent from './MapComponent';\r\nimport Controls from './Controls';\r\nimport styles from './styles';\r\nimport preprocessData from './preprocessData';\r\nimport Papa from 'papaparse';\r\n\r\nconst MapView = () => {\r\n  // State Variables\r\n  const [geoData, setGeoData] = useState([]);\r\n  const [numericHeaders, setNumericHeaders] = useState([]);\r\n  const [stringHeaders, setStringHeaders] = useState([]);\r\n  const [selectedLocation, setSelectedLocation] = useState(null);\r\n  const [chartType, setChartType] = useState('Bar');\r\n  const [chartData, setChartData] = useState(null);\r\n  const [totalRows, setTotalRows] = useState(0);\r\n  const [totalColumns, setTotalColumns] = useState(0);\r\n  const [progress, setProgress] = useState({\r\n    upload: 0,\r\n    preprocess: 0,\r\n    geocode: 0,\r\n  });\r\n  const [progressMessages, setProgressMessages] = useState({\r\n    upload: '',\r\n    preprocess: '',\r\n    geocode: '',\r\n  });\r\n  const [cityList, setCityList] = useState([]);\r\n  const [selectedCity1, setSelectedCity1] = useState('');\r\n  const [selectedCity2, setSelectedCity2] = useState('');\r\n  const [locationColumn, setLocationColumn] = useState('');\r\n  const [markersAdded, setMarkersAdded] = useState(false);\r\n\r\n  // Preprocess Data Function\r\n  const handlePreprocess = useCallback(\r\n    async (rawData) => {\r\n      // Determine the location column dynamically\r\n      const possibleLocationColumns = [\r\n        'LocationDesc',\r\n        'LocationAbbr',\r\n        'state',\r\n        'State',\r\n        'city',\r\n        'City',\r\n        'Country',\r\n        'Country Name',\r\n        'Country Code',\r\n        'Address',\r\n        'Place',\r\n        'GeoLocation',\r\n        // Include more possible location columns if necessary\r\n      ];\r\n      let detectedLocationColumn = possibleLocationColumns.find(\r\n        (col) => rawData[0] && rawData[0].hasOwnProperty(col)\r\n      );\r\n\r\n      // If no location column is found, use 'locationID'\r\n      if (!detectedLocationColumn) {\r\n        detectedLocationColumn = 'locationID';\r\n      }\r\n\r\n      setLocationColumn(detectedLocationColumn);\r\n      console.log('Detected Location Column:', detectedLocationColumn);\r\n\r\n      // Preprocess data\r\n      const processedData = await preprocessData(\r\n        rawData,\r\n        setProgress,\r\n        detectedLocationColumn\r\n      );\r\n\r\n      if (!processedData || processedData.length === 0) {\r\n        alert('No valid data after preprocessing.');\r\n        return;\r\n      }\r\n\r\n      setGeoData(processedData);\r\n\r\n      // Identify numeric and string headers\r\n      if (processedData.length > 0) {\r\n        const headers = Object.keys(processedData[0]);\r\n        const numeric = [];\r\n        const strings = [];\r\n\r\n        headers.forEach((header) => {\r\n          if (\r\n            ['latitude', 'longitude', 'GeoLocation', 'locationID'].includes(header)\r\n          )\r\n            return;\r\n\r\n          const isNumeric = processedData.every((item) => {\r\n            const value = parseFloat(item[header]);\r\n            return !isNaN(value);\r\n          });\r\n          if (isNumeric) {\r\n            numeric.push(header);\r\n          } else {\r\n            strings.push(header);\r\n          }\r\n        });\r\n\r\n        setNumericHeaders(numeric);\r\n        setStringHeaders(strings);\r\n\r\n        setTotalRows(processedData.length);\r\n        setTotalColumns(headers.length);\r\n\r\n        // Extract unique locations for comparison\r\n        const uniqueLocations = [\r\n          ...new Set(\r\n            processedData.map((item) => item[detectedLocationColumn]).filter(Boolean)\r\n          ),\r\n        ];\r\n        setCityList(uniqueLocations);\r\n      } else {\r\n        alert('No data available after filtering.');\r\n      }\r\n\r\n      // Reset markersAdded state when new data is uploaded\r\n      setMarkersAdded(false);\r\n    },\r\n    []\r\n  );\r\n\r\n  // Generate Chart Data for Selected Location\r\n  const generateChartData = useCallback(() => {\r\n    if (selectedLocation) {\r\n      const locationValues = numericHeaders.map((header) => ({\r\n        label: header,\r\n        value: parseFloat(selectedLocation[header]) || 0,\r\n      }));\r\n\r\n      // Normalize data for chart display (0.5% to 10%)\r\n      const dataMin = 0; // Minimum data value\r\n      const dataMax = Math.max(...locationValues.map((item) => item.value));\r\n      const range = dataMax - dataMin || 1; // Avoid division by zero\r\n\r\n      const normalizedValues = locationValues.map((item) => ({\r\n        label: item.label,\r\n        normalizedValue: ((item.value - dataMin) / range) * 9.5 + 0.5,\r\n        actualValue: item.value, // Keep the actual value\r\n      }));\r\n\r\n      setChartData({\r\n        labels: normalizedValues.map((item) => item.label),\r\n        datasets: [\r\n          {\r\n            label: getLocationLabel(selectedLocation),\r\n            data: normalizedValues.map((item) => item.normalizedValue),\r\n            actualValues: normalizedValues.map((item) => item.actualValue), // Store actual values\r\n            backgroundColor: [\r\n              'rgba(255, 99, 132, 0.5)',\r\n              'rgba(54, 162, 235, 0.5)',\r\n              'rgba(255, 206, 86, 0.5)',\r\n              'rgba(75, 192, 192, 0.5)',\r\n              'rgba(153, 102, 255, 0.5)',\r\n              'rgba(255, 159, 64, 0.5)',\r\n            ],\r\n            borderColor: [\r\n              'rgba(255, 99, 132, 1)',\r\n              'rgba(54, 162, 235, 1)',\r\n              'rgba(255, 206, 86, 1)',\r\n              'rgba(75, 192, 192, 1)',\r\n              'rgba(153, 102, 255, 1)',\r\n              'rgba(255, 159, 64, 1)',\r\n            ],\r\n            borderWidth: 1,\r\n          },\r\n        ],\r\n      });\r\n    }\r\n  }, [selectedLocation, numericHeaders]);\r\n\r\n  // Generate a human-readable label for the location\r\n  const getLocationLabel = useCallback(\r\n    (data) => {\r\n      if (data[locationColumn]) return data[locationColumn];\r\n      if (data.city) return data.city;\r\n      if (data.state) return data.state;\r\n      if (data.address) return data.address;\r\n      return `Lat: ${parseFloat(data.latitude).toFixed(2)}, Lng: ${parseFloat(\r\n        data.longitude\r\n      ).toFixed(2)}`;\r\n    },\r\n    [locationColumn]\r\n  );\r\n\r\n  // Handle File Upload\r\n  const handleFileUpload = useCallback(\r\n    (event) => {\r\n      setProgress({\r\n        upload: 0,\r\n        preprocess: 0,\r\n        geocode: 0,\r\n      });\r\n      setProgressMessages({\r\n        upload: '',\r\n        preprocess: '',\r\n        geocode: '',\r\n      });\r\n      const file = event.target.files[0];\r\n      if (file) {\r\n        const fileExtension = file.name.split('.').pop().toLowerCase();\r\n\r\n        if (fileExtension === 'json') {\r\n          const reader = new FileReader();\r\n          reader.onload = async (e) => {\r\n            try {\r\n              const data = JSON.parse(e.target.result);\r\n              setProgress((prev) => ({ ...prev, upload: 100 }));\r\n              setProgressMessages((prev) => ({\r\n                ...prev,\r\n                upload: 'Dataset uploaded successfully.',\r\n              }));\r\n              await handlePreprocess(data);\r\n            } catch (error) {\r\n              console.error('Invalid JSON format:', error);\r\n              alert('Error: Uploaded file is not valid JSON.');\r\n            }\r\n          };\r\n          reader.readAsText(file);\r\n        } else if (fileExtension === 'csv') {\r\n          Papa.parse(file, {\r\n            header: true,\r\n            skipEmptyLines: true,\r\n            beforeFirstChunk: (chunk) => {\r\n              // Handle datasets with metadata rows\r\n              const lines = chunk.trim().split('\\n');\r\n              const dataStartIndex = lines.findIndex(\r\n                (line) =>\r\n                  line.startsWith('Country Name') ||\r\n                  line.startsWith('state') ||\r\n                  line.startsWith('RowId')\r\n              );\r\n              if (dataStartIndex > 0) {\r\n                return lines.slice(dataStartIndex).join('\\n');\r\n              }\r\n              return chunk;\r\n            },\r\n            complete: async (results) => {\r\n              setProgress((prev) => ({ ...prev, upload: 100 }));\r\n              setProgressMessages((prev) => ({\r\n                ...prev,\r\n                upload: 'Dataset uploaded successfully.',\r\n              }));\r\n              await handlePreprocess(results.data);\r\n            },\r\n            error: (error) => {\r\n              console.error('CSV parsing error:', error);\r\n              alert('Error: Failed to parse CSV file.');\r\n            },\r\n          });\r\n        } else {\r\n          alert('Please upload a valid JSON or CSV file.');\r\n        }\r\n      }\r\n    },\r\n    [handlePreprocess]\r\n  );\r\n\r\n  // Monitor Progress Updates\r\n  useEffect(() => {\r\n    if (progress.preprocess === 100) {\r\n      setProgressMessages((prev) => ({\r\n        ...prev,\r\n        preprocess: 'Preprocessing completed.',\r\n      }));\r\n    }\r\n  }, [progress.preprocess]);\r\n\r\n  useEffect(() => {\r\n    if (progress.geocode === 100) {\r\n      setProgressMessages((prev) => ({\r\n        ...prev,\r\n        geocode: 'Locations marked on the map.',\r\n      }));\r\n    }\r\n  }, [progress.geocode]);\r\n\r\n  // Handle Location Selection from Map\r\n  const handleLocationSelect = useCallback(\r\n    (locationData) => {\r\n      // Clear city selections if a map marker is selected\r\n      setSelectedCity1('');\r\n      setSelectedCity2('');\r\n      if (selectedLocation && selectedLocation.locationID === locationData.locationID) {\r\n        setSelectedLocation(null); // Deselect\r\n        setChartData(null);\r\n      } else {\r\n        setSelectedLocation(locationData);\r\n        setChartData(null);\r\n      }\r\n    },\r\n    [selectedLocation]\r\n  );\r\n\r\n  // Handle Location Comparison Selection\r\n  const handleCitySelection = useCallback(() => {\r\n    if (selectedCity1 && selectedCity2) {\r\n      const data1 = geoData.filter(\r\n        (item) => item[locationColumn] === selectedCity1\r\n      );\r\n      const data2 = geoData.filter(\r\n        (item) => item[locationColumn] === selectedCity2\r\n      );\r\n\r\n      if (data1.length === 0 || data2.length === 0) {\r\n        alert('One or both selected locations have no data.');\r\n        return;\r\n      }\r\n\r\n      // Aggregate data (e.g., average)\r\n      const aggregatedData1 = {};\r\n      const aggregatedData2 = {};\r\n\r\n      numericHeaders.forEach((header) => {\r\n        const values1 = data1.map((item) => parseFloat(item[header]) || 0);\r\n        const values2 = data2.map((item) => parseFloat(item[header]) || 0);\r\n\r\n        const avg1 = values1.reduce((a, b) => a + b, 0) / (values1.length || 1);\r\n        const avg2 = values2.reduce((a, b) => a + b, 0) / (values2.length || 1);\r\n\r\n        aggregatedData1[header] = avg1;\r\n        aggregatedData2[header] = avg2;\r\n      });\r\n\r\n      // Normalize data for chart display (0.5% to 10%)\r\n      const dataMin = 0; // Minimum data value\r\n      const dataMax = Math.max(\r\n        ...Object.values(aggregatedData1),\r\n        ...Object.values(aggregatedData2)\r\n      );\r\n      const range = dataMax - dataMin || 1; // Avoid division by zero\r\n\r\n      const normalizedData1 = {};\r\n      const normalizedData2 = {};\r\n      const actualData1 = {};\r\n      const actualData2 = {};\r\n\r\n      numericHeaders.forEach((header) => {\r\n        normalizedData1[header] =\r\n          ((aggregatedData1[header] - dataMin) / range) * 9.5 + 0.5;\r\n        normalizedData2[header] =\r\n          ((aggregatedData2[header] - dataMin) / range) * 9.5 + 0.5;\r\n        actualData1[header] = aggregatedData1[header];\r\n        actualData2[header] = aggregatedData2[header];\r\n      });\r\n\r\n      // Prepare chart data\r\n      const labels = numericHeaders;\r\n      const dataSet = {\r\n        labels,\r\n        datasets: [\r\n          {\r\n            label: selectedCity1,\r\n            data: numericHeaders.map((header) => normalizedData1[header]),\r\n            actualValues: numericHeaders.map((header) => actualData1[header]),\r\n            backgroundColor: 'rgba(255, 99, 132, 0.5)',\r\n            borderColor: 'rgba(255, 99, 132, 1)',\r\n            borderWidth: 1,\r\n          },\r\n          {\r\n            label: selectedCity2,\r\n            data: numericHeaders.map((header) => normalizedData2[header]),\r\n            actualValues: numericHeaders.map((header) => actualData2[header]),\r\n            backgroundColor: 'rgba(54, 162, 235, 0.5)',\r\n            borderColor: 'rgba(54, 162, 235, 1)',\r\n            borderWidth: 1,\r\n          },\r\n        ],\r\n      };\r\n\r\n      setChartData(dataSet);\r\n      setSelectedLocation(null); // Deselect any single location\r\n    }\r\n  }, [selectedCity1, selectedCity2, geoData, locationColumn, numericHeaders]);\r\n\r\n  // Trigger Chart Data Generation\r\n  useEffect(() => {\r\n    generateChartData();\r\n  }, [generateChartData, chartType]);\r\n\r\n  return (\r\n    <div style={styles.container}>\r\n      <MapComponent\r\n        geoData={geoData}\r\n        selectedLocation={selectedLocation}\r\n        handleLocationSelect={handleLocationSelect}\r\n        markersAdded={markersAdded}\r\n        setMarkersAdded={setMarkersAdded}\r\n      />\r\n      <Controls\r\n        progress={progress}\r\n        progressMessages={progressMessages}\r\n        handleFileUpload={handleFileUpload}\r\n        geoData={geoData}\r\n        totalRows={totalRows}\r\n        totalColumns={totalColumns}\r\n        numericHeaders={numericHeaders}\r\n        stringHeaders={stringHeaders}\r\n        cityList={cityList}\r\n        selectedCity1={selectedCity1}\r\n        selectedCity2={selectedCity2}\r\n        setSelectedCity1={setSelectedCity1}\r\n        setSelectedCity2={setSelectedCity2}\r\n        handleCitySelection={handleCitySelection}\r\n        chartType={chartType}\r\n        setChartType={setChartType}\r\n        chartData={chartData}\r\n      />\r\n    </div>\r\n  );\r\n};\r\n\r\nexport default MapView;\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}
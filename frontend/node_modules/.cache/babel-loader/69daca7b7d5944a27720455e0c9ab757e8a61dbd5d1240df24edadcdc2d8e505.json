{"ast":null,"code":"import axios from 'axios';\nimport { MAPBOX_TOKEN } from './constants';\n\n// US States metadata for validation and normalization\nconst US_STATES = {\n  // Full mapping of state names, abbreviations, and FIPS codes\n  mapping: {\n    'AL': {\n      name: 'Alabama',\n      fips: '01'\n    },\n    'AK': {\n      name: 'Alaska',\n      fips: '02'\n    },\n    'AZ': {\n      name: 'Arizona',\n      fips: '04'\n    },\n    'AR': {\n      name: 'Arkansas',\n      fips: '05'\n    },\n    'CA': {\n      name: 'California',\n      fips: '06'\n    },\n    'CO': {\n      name: 'Colorado',\n      fips: '08'\n    },\n    'CT': {\n      name: 'Connecticut',\n      fips: '09'\n    },\n    'DE': {\n      name: 'Delaware',\n      fips: '10'\n    },\n    'DC': {\n      name: 'District of Columbia',\n      fips: '11'\n    },\n    'FL': {\n      name: 'Florida',\n      fips: '12'\n    },\n    'GA': {\n      name: 'Georgia',\n      fips: '13'\n    },\n    'HI': {\n      name: 'Hawaii',\n      fips: '15'\n    },\n    'ID': {\n      name: 'Idaho',\n      fips: '16'\n    },\n    'IL': {\n      name: 'Illinois',\n      fips: '17'\n    },\n    'IN': {\n      name: 'Indiana',\n      fips: '18'\n    },\n    'IA': {\n      name: 'Iowa',\n      fips: '19'\n    },\n    'KS': {\n      name: 'Kansas',\n      fips: '20'\n    },\n    'KY': {\n      name: 'Kentucky',\n      fips: '21'\n    },\n    'LA': {\n      name: 'Louisiana',\n      fips: '22'\n    },\n    'ME': {\n      name: 'Maine',\n      fips: '23'\n    },\n    'MD': {\n      name: 'Maryland',\n      fips: '24'\n    },\n    'MA': {\n      name: 'Massachusetts',\n      fips: '25'\n    },\n    'MI': {\n      name: 'Michigan',\n      fips: '26'\n    },\n    'MN': {\n      name: 'Minnesota',\n      fips: '27'\n    },\n    'MS': {\n      name: 'Mississippi',\n      fips: '28'\n    },\n    'MO': {\n      name: 'Missouri',\n      fips: '29'\n    },\n    'MT': {\n      name: 'Montana',\n      fips: '30'\n    },\n    'NE': {\n      name: 'Nebraska',\n      fips: '31'\n    },\n    'NV': {\n      name: 'Nevada',\n      fips: '32'\n    },\n    'NH': {\n      name: 'New Hampshire',\n      fips: '33'\n    },\n    'NJ': {\n      name: 'New Jersey',\n      fips: '34'\n    },\n    'NM': {\n      name: 'New Mexico',\n      fips: '35'\n    },\n    'NY': {\n      name: 'New York',\n      fips: '36'\n    },\n    'NC': {\n      name: 'North Carolina',\n      fips: '37'\n    },\n    'ND': {\n      name: 'North Dakota',\n      fips: '38'\n    },\n    'OH': {\n      name: 'Ohio',\n      fips: '39'\n    },\n    'OK': {\n      name: 'Oklahoma',\n      fips: '40'\n    },\n    'OR': {\n      name: 'Oregon',\n      fips: '41'\n    },\n    'PA': {\n      name: 'Pennsylvania',\n      fips: '42'\n    },\n    'RI': {\n      name: 'Rhode Island',\n      fips: '44'\n    },\n    'SC': {\n      name: 'South Carolina',\n      fips: '45'\n    },\n    'SD': {\n      name: 'South Dakota',\n      fips: '46'\n    },\n    'TN': {\n      name: 'Tennessee',\n      fips: '47'\n    },\n    'TX': {\n      name: 'Texas',\n      fips: '48'\n    },\n    'UT': {\n      name: 'Utah',\n      fips: '49'\n    },\n    'VT': {\n      name: 'Vermont',\n      fips: '50'\n    },\n    'VA': {\n      name: 'Virginia',\n      fips: '51'\n    },\n    'WA': {\n      name: 'Washington',\n      fips: '53'\n    },\n    'WV': {\n      name: 'West Virginia',\n      fips: '54'\n    },\n    'WI': {\n      name: 'Wisconsin',\n      fips: '55'\n    },\n    'WY': {\n      name: 'Wyoming',\n      fips: '56'\n    }\n  },\n  // Lookup functions\n  getStateCode: stateName => {\n    var _Object$entries$find;\n    const normalizedName = stateName.trim().toLowerCase();\n    return ((_Object$entries$find = Object.entries(US_STATES.mapping).find(([code, data]) => data.name.toLowerCase() === normalizedName)) === null || _Object$entries$find === void 0 ? void 0 : _Object$entries$find[0]) || null;\n  },\n  getStateName: stateCode => {\n    var _US_STATES$mapping$st;\n    return ((_US_STATES$mapping$st = US_STATES.mapping[stateCode.toUpperCase()]) === null || _US_STATES$mapping$st === void 0 ? void 0 : _US_STATES$mapping$st.name) || null;\n  },\n  getFipsCode: stateIdentifier => {\n    var _US_STATES$mapping$st2;\n    const stateCode = stateIdentifier.length === 2 ? stateIdentifier.toUpperCase() : US_STATES.getStateCode(stateIdentifier);\n    return ((_US_STATES$mapping$st2 = US_STATES.mapping[stateCode]) === null || _US_STATES$mapping$st2 === void 0 ? void 0 : _US_STATES$mapping$st2.fips) || null;\n  }\n};\n\n// Column pattern detection for various dataset types\nconst COLUMN_PATTERNS = {\n  state: {\n    patterns: [/^state$/i, /^state[_-](?:name|code|id)$/i, /^st$/i, /^state[_-]abbreviation$/i],\n    alternatives: ['state_name', 'state_id', 'STATE_CODE', 'st', 'state']\n  },\n  city: {\n    patterns: [/^city$/i, /^city[_-]name$/i, /^city[_-]ascii$/i, /^place[_-]name$/i],\n    alternatives: ['city', 'city_name', 'city_ascii', 'place_name']\n  },\n  latitude: {\n    patterns: [/^lat(?:itude)?$/i, /^lat[_-]y$/i],\n    alternatives: ['latitude', 'lat', 'Latitude', 'LAT', 'y']\n  },\n  longitude: {\n    patterns: [/^lon(?:g(?:itude)?)?$/i, /^lng$/i, /^lon[_-]x$/i],\n    alternatives: ['longitude', 'lon', 'lng', 'Longitude', 'LONG', 'x']\n  },\n  population: {\n    patterns: [/^pop(?:ulation)?$/i, /^total[_-]population$/i],\n    alternatives: ['population', 'pop', 'total_population']\n  },\n  county: {\n    patterns: [/^county$/i, /^county[_-]name$/i, /^county[_-]fips$/i],\n    alternatives: ['county', 'county_name', 'county_fips']\n  }\n};\n\n// Enhanced geocoding cache with TTL\nclass GeoCache {\n  constructor(ttlHours = 24) {\n    this.cache = new Map();\n    this.ttl = ttlHours * 60 * 60 * 1000;\n  }\n  get(key) {\n    const item = this.cache.get(key);\n    if (!item) return null;\n    if (Date.now() > item.expires) {\n      this.cache.delete(key);\n      return null;\n    }\n    return item.value;\n  }\n  set(key, value) {\n    this.cache.set(key, {\n      value,\n      expires: Date.now() + this.ttl\n    });\n  }\n  clear() {\n    this.cache.clear();\n  }\n}\nconst geocodeCache = new GeoCache();\n\n// Utility functions\nconst delay = ms => new Promise(resolve => setTimeout(resolve, ms));\nconst isValidCoordinate = (lat, lon) => {\n  return lat != null && lon != null && !isNaN(lat) && !isNaN(lon) && lat >= -90 && lat <= 90 && lon >= -180 && lon <= 180;\n};\n\n// Main preprocessor class\nclass preprocessData {\n  constructor(config = {}) {\n    this.config = {\n      maxRows: 100000,\n      batchSize: 100,\n      geocodingDelay: 200,\n      maxRetries: 3,\n      cacheEnabled: true,\n      ...config\n    };\n    this.geocodeCache = geocodeCache;\n  }\n\n  // Detect column names based on patterns\n  detectColumns(data) {\n    if (!Array.isArray(data) || data.length === 0) return {};\n    const columns = {};\n    const sampleRow = data[0];\n    Object.entries(COLUMN_PATTERNS).forEach(([key, pattern]) => {\n      // Try exact matches first\n      let found = pattern.alternatives.find(alt => sampleRow.hasOwnProperty(alt));\n\n      // Try pattern matching if no exact match\n      if (!found) {\n        found = Object.keys(sampleRow).find(col => pattern.patterns.some(regex => regex.test(col)));\n      }\n      if (found) columns[key] = found;\n    });\n    return columns;\n  }\n\n  // Geocode location with rate limiting and retries\n  async geocodeLocation(location, retryCount = 0) {\n    if (!location) return null;\n    const cacheKey = location.toLowerCase();\n    if (this.config.cacheEnabled) {\n      const cached = this.geocodeCache.get(cacheKey);\n      if (cached) return cached;\n    }\n    try {\n      var _response$data$featur;\n      const response = await axios.get(`https://api.mapbox.com/geocoding/v5/mapbox.places/${encodeURIComponent(location)}.json`, {\n        params: {\n          access_token: MAPBOX_TOKEN,\n          limit: 1,\n          types: 'place,region',\n          country: 'US'\n        }\n      });\n      if (((_response$data$featur = response.data.features) === null || _response$data$featur === void 0 ? void 0 : _response$data$featur.length) > 0) {\n        const [longitude, latitude] = response.data.features[0].center;\n        const result = {\n          latitude,\n          longitude\n        };\n        if (this.config.cacheEnabled) {\n          this.geocodeCache.set(cacheKey, result);\n        }\n        return result;\n      }\n    } catch (error) {\n      var _error$response, _error$response2;\n      console.error(`Geocoding error for \"${location}\":`, error.message);\n      if (retryCount < this.config.maxRetries && (((_error$response = error.response) === null || _error$response === void 0 ? void 0 : _error$response.status) === 429 || ((_error$response2 = error.response) === null || _error$response2 === void 0 ? void 0 : _error$response2.status) >= 500)) {\n        await delay(this.config.geocodingDelay * Math.pow(2, retryCount));\n        return this.geocodeLocation(location, retryCount + 1);\n      }\n    }\n    return null;\n  }\n\n  // Process a single data row\n  async processRow(row, columns) {\n    const processed = {\n      ...row\n    };\n\n    // Normalize state information\n    if (columns.state) {\n      const stateIdentifier = row[columns.state];\n      if (stateIdentifier) {\n        processed.state_code = stateIdentifier.length === 2 ? stateIdentifier.toUpperCase() : US_STATES.getStateCode(stateIdentifier);\n        processed.state_name = US_STATES.getStateName(processed.state_code);\n        processed.state_fips = US_STATES.getFipsCode(processed.state_code);\n      }\n    }\n\n    // Handle coordinates\n    let hasValidCoords = false;\n    if (columns.latitude && columns.longitude) {\n      const lat = parseFloat(row[columns.latitude]);\n      const lon = parseFloat(row[columns.longitude]);\n      if (isValidCoordinate(lat, lon)) {\n        processed.latitude = lat;\n        processed.longitude = lon;\n        hasValidCoords = true;\n      }\n    }\n\n    // Geocode if necessary\n    if (!hasValidCoords) {\n      const locationParts = [];\n      if (columns.city && row[columns.city]) locationParts.push(row[columns.city]);\n      if (processed.state_name) locationParts.push(processed.state_name);\n      if (locationParts.length > 0) {\n        const coords = await this.geocodeLocation(locationParts.join(', '));\n        if (coords) {\n          processed.latitude = coords.latitude;\n          processed.longitude = coords.longitude;\n          hasValidCoords = true;\n        }\n      }\n    }\n\n    // Normalize population if present\n    if (columns.population) {\n      const pop = parseFloat(row[columns.population]);\n      if (!isNaN(pop)) {\n        processed.population = pop;\n      }\n    }\n    return hasValidCoords ? processed : null;\n  }\n\n  // Main preprocessing function\n  async preprocess(data, setProgress) {\n    try {\n      setProgress === null || setProgress === void 0 ? void 0 : setProgress(prev => ({\n        ...prev,\n        preprocess: 0\n      }));\n\n      // Input validation\n      if (!Array.isArray(data) || data.length === 0) {\n        throw new Error('Input must be a non-empty array');\n      }\n\n      // Limit data size\n      const limitedData = data.slice(0, this.config.maxRows);\n      setProgress === null || setProgress === void 0 ? void 0 : setProgress(prev => ({\n        ...prev,\n        preprocess: 10\n      }));\n\n      // Detect columns\n      const columns = this.detectColumns(limitedData);\n      console.log('Detected columns:', columns);\n      setProgress === null || setProgress === void 0 ? void 0 : setProgress(prev => ({\n        ...prev,\n        preprocess: 20\n      }));\n\n      // Process data in batches\n      const processedData = [];\n      let lastProgressUpdate = Date.now();\n      for (let i = 0; i < limitedData.length; i++) {\n        const processed = await this.processRow(limitedData[i], columns);\n        if (processed) processedData.push(processed);\n\n        // Update progress periodically\n        const now = Date.now();\n        if (now - lastProgressUpdate > 100) {\n          const progress = 20 + Math.floor(i / limitedData.length * 70);\n          setProgress === null || setProgress === void 0 ? void 0 : setProgress(prev => ({\n            ...prev,\n            preprocess: progress\n          }));\n          lastProgressUpdate = now;\n          await delay(1);\n        }\n      }\n      setProgress === null || setProgress === void 0 ? void 0 : setProgress(prev => ({\n        ...prev,\n        preprocess: 100\n      }));\n      return processedData;\n    } catch (error) {\n      console.error('Preprocessing failed:', error);\n      setProgress === null || setProgress === void 0 ? void 0 : setProgress(prev => ({\n        ...prev,\n        preprocess: 0\n      }));\n      throw error;\n    }\n  }\n}\nexport default preprocessData;","map":{"version":3,"names":["axios","MAPBOX_TOKEN","US_STATES","mapping","name","fips","getStateCode","stateName","_Object$entries$find","normalizedName","trim","toLowerCase","Object","entries","find","code","data","getStateName","stateCode","_US_STATES$mapping$st","toUpperCase","getFipsCode","stateIdentifier","_US_STATES$mapping$st2","length","COLUMN_PATTERNS","state","patterns","alternatives","city","latitude","longitude","population","county","GeoCache","constructor","ttlHours","cache","Map","ttl","get","key","item","Date","now","expires","delete","value","set","clear","geocodeCache","delay","ms","Promise","resolve","setTimeout","isValidCoordinate","lat","lon","isNaN","preprocessData","config","maxRows","batchSize","geocodingDelay","maxRetries","cacheEnabled","detectColumns","Array","isArray","columns","sampleRow","forEach","pattern","found","alt","hasOwnProperty","keys","col","some","regex","test","geocodeLocation","location","retryCount","cacheKey","cached","_response$data$featur","response","encodeURIComponent","params","access_token","limit","types","country","features","center","result","error","_error$response","_error$response2","console","message","status","Math","pow","processRow","row","processed","state_code","state_name","state_fips","hasValidCoords","parseFloat","locationParts","push","coords","join","pop","preprocess","setProgress","prev","Error","limitedData","slice","log","processedData","lastProgressUpdate","i","progress","floor"],"sources":["/Users/girishkumarpatchikoru/Desktop/projecthci/geovizproject/frontend/src/components/preprocessData.js"],"sourcesContent":["\n\nimport axios from 'axios';\nimport { MAPBOX_TOKEN } from './constants';\n\n// US States metadata for validation and normalization\nconst US_STATES = {\n  // Full mapping of state names, abbreviations, and FIPS codes\n  mapping: {\n    'AL': { name: 'Alabama', fips: '01' },\n    'AK': { name: 'Alaska', fips: '02' },\n    'AZ': { name: 'Arizona', fips: '04' },\n    'AR': { name: 'Arkansas', fips: '05' },\n    'CA': { name: 'California', fips: '06' },\n    'CO': { name: 'Colorado', fips: '08' },\n    'CT': { name: 'Connecticut', fips: '09' },\n    'DE': { name: 'Delaware', fips: '10' },\n    'DC': { name: 'District of Columbia', fips: '11' },\n    'FL': { name: 'Florida', fips: '12' },\n    'GA': { name: 'Georgia', fips: '13' },\n    'HI': { name: 'Hawaii', fips: '15' },\n    'ID': { name: 'Idaho', fips: '16' },\n    'IL': { name: 'Illinois', fips: '17' },\n    'IN': { name: 'Indiana', fips: '18' },\n    'IA': { name: 'Iowa', fips: '19' },\n    'KS': { name: 'Kansas', fips: '20' },\n    'KY': { name: 'Kentucky', fips: '21' },\n    'LA': { name: 'Louisiana', fips: '22' },\n    'ME': { name: 'Maine', fips: '23' },\n    'MD': { name: 'Maryland', fips: '24' },\n    'MA': { name: 'Massachusetts', fips: '25' },\n    'MI': { name: 'Michigan', fips: '26' },\n    'MN': { name: 'Minnesota', fips: '27' },\n    'MS': { name: 'Mississippi', fips: '28' },\n    'MO': { name: 'Missouri', fips: '29' },\n    'MT': { name: 'Montana', fips: '30' },\n    'NE': { name: 'Nebraska', fips: '31' },\n    'NV': { name: 'Nevada', fips: '32' },\n    'NH': { name: 'New Hampshire', fips: '33' },\n    'NJ': { name: 'New Jersey', fips: '34' },\n    'NM': { name: 'New Mexico', fips: '35' },\n    'NY': { name: 'New York', fips: '36' },\n    'NC': { name: 'North Carolina', fips: '37' },\n    'ND': { name: 'North Dakota', fips: '38' },\n    'OH': { name: 'Ohio', fips: '39' },\n    'OK': { name: 'Oklahoma', fips: '40' },\n    'OR': { name: 'Oregon', fips: '41' },\n    'PA': { name: 'Pennsylvania', fips: '42' },\n    'RI': { name: 'Rhode Island', fips: '44' },\n    'SC': { name: 'South Carolina', fips: '45' },\n    'SD': { name: 'South Dakota', fips: '46' },\n    'TN': { name: 'Tennessee', fips: '47' },\n    'TX': { name: 'Texas', fips: '48' },\n    'UT': { name: 'Utah', fips: '49' },\n    'VT': { name: 'Vermont', fips: '50' },\n    'VA': { name: 'Virginia', fips: '51' },\n    'WA': { name: 'Washington', fips: '53' },\n    'WV': { name: 'West Virginia', fips: '54' },\n    'WI': { name: 'Wisconsin', fips: '55' },\n    'WY': { name: 'Wyoming', fips: '56' }\n  },\n\n  // Lookup functions\n  getStateCode: (stateName) => {\n    const normalizedName = stateName.trim().toLowerCase();\n    return Object.entries(US_STATES.mapping).find(\n      ([code, data]) => data.name.toLowerCase() === normalizedName\n    )?.[0] || null;\n  },\n\n  getStateName: (stateCode) => {\n    return US_STATES.mapping[stateCode.toUpperCase()]?.name || null;\n  },\n\n  getFipsCode: (stateIdentifier) => {\n    const stateCode = stateIdentifier.length === 2 ? \n      stateIdentifier.toUpperCase() : \n      US_STATES.getStateCode(stateIdentifier);\n    return US_STATES.mapping[stateCode]?.fips || null;\n  }\n};\n\n// Column pattern detection for various dataset types\nconst COLUMN_PATTERNS = {\n  state: {\n    patterns: [\n      /^state$/i,\n      /^state[_-](?:name|code|id)$/i,\n      /^st$/i,\n      /^state[_-]abbreviation$/i\n    ],\n    alternatives: ['state_name', 'state_id', 'STATE_CODE', 'st', 'state']\n  },\n  city: {\n    patterns: [\n      /^city$/i,\n      /^city[_-]name$/i,\n      /^city[_-]ascii$/i,\n      /^place[_-]name$/i\n    ],\n    alternatives: ['city', 'city_name', 'city_ascii', 'place_name']\n  },\n  latitude: {\n    patterns: [\n      /^lat(?:itude)?$/i,\n      /^lat[_-]y$/i\n    ],\n    alternatives: ['latitude', 'lat', 'Latitude', 'LAT', 'y']\n  },\n  longitude: {\n    patterns: [\n      /^lon(?:g(?:itude)?)?$/i,\n      /^lng$/i,\n      /^lon[_-]x$/i\n    ],\n    alternatives: ['longitude', 'lon', 'lng', 'Longitude', 'LONG', 'x']\n  },\n  population: {\n    patterns: [\n      /^pop(?:ulation)?$/i,\n      /^total[_-]population$/i\n    ],\n    alternatives: ['population', 'pop', 'total_population']\n  },\n  county: {\n    patterns: [\n      /^county$/i,\n      /^county[_-]name$/i,\n      /^county[_-]fips$/i\n    ],\n    alternatives: ['county', 'county_name', 'county_fips']\n  }\n};\n\n// Enhanced geocoding cache with TTL\nclass GeoCache {\n  constructor(ttlHours = 24) {\n    this.cache = new Map();\n    this.ttl = ttlHours * 60 * 60 * 1000;\n  }\n\n  get(key) {\n    const item = this.cache.get(key);\n    if (!item) return null;\n    if (Date.now() > item.expires) {\n      this.cache.delete(key);\n      return null;\n    }\n    return item.value;\n  }\n\n  set(key, value) {\n    this.cache.set(key, {\n      value,\n      expires: Date.now() + this.ttl\n    });\n  }\n\n  clear() {\n    this.cache.clear();\n  }\n}\n\nconst geocodeCache = new GeoCache();\n\n// Utility functions\nconst delay = (ms) => new Promise(resolve => setTimeout(resolve, ms));\n\nconst isValidCoordinate = (lat, lon) => {\n  return lat != null && \n         lon != null && \n         !isNaN(lat) && \n         !isNaN(lon) && \n         lat >= -90 && \n         lat <= 90 && \n         lon >= -180 && \n         lon <= 180;\n};\n\n// Main preprocessor class\nclass preprocessData {\n  constructor(config = {}) {\n    this.config = {\n      maxRows: 100000,\n      batchSize: 100,\n      geocodingDelay: 200,\n      maxRetries: 3,\n      cacheEnabled: true,\n      ...config\n    };\n    \n    this.geocodeCache = geocodeCache;\n  }\n\n  // Detect column names based on patterns\n  detectColumns(data) {\n    if (!Array.isArray(data) || data.length === 0) return {};\n    \n    const columns = {};\n    const sampleRow = data[0];\n    \n    Object.entries(COLUMN_PATTERNS).forEach(([key, pattern]) => {\n      // Try exact matches first\n      let found = pattern.alternatives.find(alt => sampleRow.hasOwnProperty(alt));\n      \n      // Try pattern matching if no exact match\n      if (!found) {\n        found = Object.keys(sampleRow).find(col => \n          pattern.patterns.some(regex => regex.test(col))\n        );\n      }\n      \n      if (found) columns[key] = found;\n    });\n    \n    return columns;\n  }\n\n  // Geocode location with rate limiting and retries\n  async geocodeLocation(location, retryCount = 0) {\n    if (!location) return null;\n    \n    const cacheKey = location.toLowerCase();\n    if (this.config.cacheEnabled) {\n      const cached = this.geocodeCache.get(cacheKey);\n      if (cached) return cached;\n    }\n\n    try {\n      const response = await axios.get(\n        `https://api.mapbox.com/geocoding/v5/mapbox.places/${encodeURIComponent(location)}.json`,\n        {\n          params: {\n            access_token: MAPBOX_TOKEN,\n            limit: 1,\n            types: 'place,region',\n            country: 'US'\n          }\n        }\n      );\n\n      if (response.data.features?.length > 0) {\n        const [longitude, latitude] = response.data.features[0].center;\n        const result = { latitude, longitude };\n        \n        if (this.config.cacheEnabled) {\n          this.geocodeCache.set(cacheKey, result);\n        }\n        \n        return result;\n      }\n    } catch (error) {\n      console.error(`Geocoding error for \"${location}\":`, error.message);\n      \n      if (retryCount < this.config.maxRetries && \n          (error.response?.status === 429 || error.response?.status >= 500)) {\n        await delay(this.config.geocodingDelay * Math.pow(2, retryCount));\n        return this.geocodeLocation(location, retryCount + 1);\n      }\n    }\n\n    return null;\n  }\n\n  // Process a single data row\n  async processRow(row, columns) {\n    const processed = { ...row };\n    \n    // Normalize state information\n    if (columns.state) {\n      const stateIdentifier = row[columns.state];\n      if (stateIdentifier) {\n        processed.state_code = stateIdentifier.length === 2 ? \n          stateIdentifier.toUpperCase() : \n          US_STATES.getStateCode(stateIdentifier);\n        processed.state_name = US_STATES.getStateName(processed.state_code);\n        processed.state_fips = US_STATES.getFipsCode(processed.state_code);\n      }\n    }\n\n    // Handle coordinates\n    let hasValidCoords = false;\n    if (columns.latitude && columns.longitude) {\n      const lat = parseFloat(row[columns.latitude]);\n      const lon = parseFloat(row[columns.longitude]);\n      \n      if (isValidCoordinate(lat, lon)) {\n        processed.latitude = lat;\n        processed.longitude = lon;\n        hasValidCoords = true;\n      }\n    }\n\n    // Geocode if necessary\n    if (!hasValidCoords) {\n      const locationParts = [];\n      if (columns.city && row[columns.city]) locationParts.push(row[columns.city]);\n      if (processed.state_name) locationParts.push(processed.state_name);\n      \n      if (locationParts.length > 0) {\n        const coords = await this.geocodeLocation(locationParts.join(', '));\n        if (coords) {\n          processed.latitude = coords.latitude;\n          processed.longitude = coords.longitude;\n          hasValidCoords = true;\n        }\n      }\n    }\n\n    // Normalize population if present\n    if (columns.population) {\n      const pop = parseFloat(row[columns.population]);\n      if (!isNaN(pop)) {\n        processed.population = pop;\n      }\n    }\n\n    return hasValidCoords ? processed : null;\n  }\n\n  // Main preprocessing function\n  async preprocess(data, setProgress) {\n    try {\n      setProgress?.((prev) => ({ ...prev, preprocess: 0 }));\n\n      // Input validation\n      if (!Array.isArray(data) || data.length === 0) {\n        throw new Error('Input must be a non-empty array');\n      }\n\n      // Limit data size\n      const limitedData = data.slice(0, this.config.maxRows);\n      setProgress?.((prev) => ({ ...prev, preprocess: 10 }));\n\n      // Detect columns\n      const columns = this.detectColumns(limitedData);\n      console.log('Detected columns:', columns);\n      \n      setProgress?.((prev) => ({ ...prev, preprocess: 20 }));\n\n      // Process data in batches\n      const processedData = [];\n      let lastProgressUpdate = Date.now();\n\n      for (let i = 0; i < limitedData.length; i++) {\n        const processed = await this.processRow(limitedData[i], columns);\n        if (processed) processedData.push(processed);\n\n        // Update progress periodically\n        const now = Date.now();\n        if (now - lastProgressUpdate > 100) {\n          const progress = 20 + Math.floor((i / limitedData.length) * 70);\n          setProgress?.((prev) => ({ ...prev, preprocess: progress }));\n          lastProgressUpdate = now;\n          await delay(1);\n        }\n      }\n\n      setProgress?.((prev) => ({ ...prev, preprocess: 100 }));\n\n      return processedData;\n\n    } catch (error) {\n      console.error('Preprocessing failed:', error);\n      setProgress?.((prev) => ({ ...prev, preprocess: 0 }));\n      throw error;\n    }\n  }\n}\n\n\nexport default preprocessData;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}
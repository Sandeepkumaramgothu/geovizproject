{"ast":null,"code":"// src/components/preprocessData.js\n\nimport axios from 'axios';\nimport { MAPBOX_TOKEN } from './constants';\n\n// TypeScript-like constants for field mappings\nconst FIELD_MAPPINGS = {\n  latitude: ['latitude', 'Latitude', 'lat', 'Lat', 'LAT', 'LATITUDE'],\n  longitude: ['longitude', 'Longitude', 'lon', 'Lng', 'Long', 'LONGITUDE', 'LON'],\n  state: ['state', 'STATE_NAME', 'state_id', 'STATE_CODE', 'STATE'],\n  city: ['city', 'CITY_NAME', 'city_ascii', 'CITY'],\n  geoLocation: ['GeoLocation', 'GEOLOCATION', 'geo_location', 'geometry']\n};\n\n// Configuration object for preprocessing options\nconst DEFAULT_CONFIG = {\n  maxRows: 100000,\n  batchSize: 100,\n  retryDelay: 200,\n  maxRetries: 3,\n  progressUpdateInterval: 100\n};\n\n// Utility function for delay with timeout\nconst delay = ms => new Promise(resolve => setTimeout(resolve, ms));\n\n// Enhanced geocoding cache with TTL\nclass GeocodingCache {\n  constructor(ttlMs = 24 * 60 * 60 * 1000) {\n    // 24 hour default TTL\n    this.cache = new Map();\n    this.ttl = ttlMs;\n  }\n  get(key) {\n    const item = this.cache.get(key);\n    if (!item) return null;\n    if (Date.now() > item.expires) {\n      this.cache.delete(key);\n      return null;\n    }\n    return item.value;\n  }\n  set(key, value) {\n    this.cache.set(key, {\n      value,\n      expires: Date.now() + this.ttl\n    });\n  }\n}\nconst geocodeCache = new GeocodingCache();\n\n// Enhanced coordinate extraction with validation\nconst extractCoordinates = geoLocation => {\n  if (!geoLocation) return {\n    latitude: null,\n    longitude: null\n  };\n\n  // Support multiple geometry formats\n  const patterns = {\n    point: /POINT\\s*\\(\\s*([-.\\d]+)\\s+([-.\\d]+)\\s*\\)/i,\n    coordinates: /\"coordinates\":\\s*\\[\\s*([-.\\d]+)\\s*,\\s*([-.\\d]+)\\s*\\]/i,\n    latLon: /\"lat\":\\s*([-.\\d]+).*\"lon\":\\s*([-.\\d]+)/i\n  };\n  for (const [format, regex] of Object.entries(patterns)) {\n    const match = geoLocation.match(regex);\n    if (match) {\n      const [longitude, latitude] = format === 'latLon' ? [parseFloat(match[2]), parseFloat(match[1])] : [parseFloat(match[1]), parseFloat(match[2])];\n      if (isValidCoordinate(latitude, longitude)) {\n        return {\n          latitude,\n          longitude\n        };\n      }\n    }\n  }\n  return {\n    latitude: null,\n    longitude: null\n  };\n};\n\n// Coordinate validation\nconst isValidCoordinate = (lat, lon) => {\n  return lat !== null && lon !== null && !isNaN(lat) && !isNaN(lon) && lat >= -90 && lat <= 90 && lon >= -180 && lon <= 180;\n};\n\n// Enhanced geocoding with rate limiting and retries\nconst geocodeLocationWithRateLimit = async (locationName, retryCount = 0, delayMs = DEFAULT_CONFIG.retryDelay) => {\n  const cached = geocodeCache.get(locationName);\n  if (cached) return cached;\n  try {\n    const response = await axios.get(`https://api.mapbox.com/geocoding/v5/mapbox.places/${encodeURIComponent(locationName)}.json`, {\n      params: {\n        access_token: MAPBOX_TOKEN,\n        limit: 1,\n        types: 'place,region,country'\n      }\n    });\n    const features = response.data.features;\n    if ((features === null || features === void 0 ? void 0 : features.length) > 0) {\n      const [longitude, latitude] = features[0].center;\n      const result = {\n        latitude,\n        longitude\n      };\n      if (isValidCoordinate(latitude, longitude)) {\n        geocodeCache.set(locationName, result);\n        return result;\n      }\n    }\n  } catch (error) {\n    var _error$response, _error$response2;\n    console.error(`Geocoding error for \"${locationName}\":`, error.message);\n    if (retryCount < DEFAULT_CONFIG.maxRetries && (((_error$response = error.response) === null || _error$response === void 0 ? void 0 : _error$response.status) === 429 || ((_error$response2 = error.response) === null || _error$response2 === void 0 ? void 0 : _error$response2.status) >= 500)) {\n      await delay(delayMs);\n      return geocodeLocationWithRateLimit(locationName, retryCount + 1, delayMs * 2);\n    }\n  }\n  return {\n    latitude: null,\n    longitude: null\n  };\n};\n\n// Field detection utility\nconst detectFields = (data, possibleFields) => {\n  if (!data || data.length === 0) return null;\n  return possibleFields.find(field => data[0].hasOwnProperty(field) && data.some(row => row[field] !== null && row[field] !== undefined));\n};\n\n// Main preprocess function with enhanced error handling and validation\nconst preprocessData = async (data, setProgress, locationColumn, config = {}) => {\n  const options = {\n    ...DEFAULT_CONFIG,\n    ...config\n  };\n  try {\n    setProgress === null || setProgress === void 0 ? void 0 : setProgress(prev => ({\n      ...prev,\n      preprocess: 0\n    }));\n    if (!Array.isArray(data) || data.length === 0) {\n      throw new Error('Input data must be a non-empty array');\n    }\n\n    // Limit data size\n    const limitedData = data.slice(0, options.maxRows);\n    setProgress === null || setProgress === void 0 ? void 0 : setProgress(prev => ({\n      ...prev,\n      preprocess: 10\n    }));\n\n    // Detect fields\n    const fields = {\n      latitude: detectFields(limitedData, FIELD_MAPPINGS.latitude),\n      longitude: detectFields(limitedData, FIELD_MAPPINGS.longitude),\n      state: detectFields(limitedData, FIELD_MAPPINGS.state),\n      city: detectFields(limitedData, FIELD_MAPPINGS.city),\n      geoLocation: detectFields(limitedData, FIELD_MAPPINGS.geoLocation)\n    };\n    console.log('Detected fields:', fields);\n    setProgress === null || setProgress === void 0 ? void 0 : setProgress(prev => ({\n      ...prev,\n      preprocess: 20\n    }));\n\n    // Filter and process data\n    const processedData = [];\n    let lastProgressUpdate = Date.now();\n    for (let i = 0; i < limitedData.length; i++) {\n      const item = {\n        ...limitedData[i]\n      };\n      let coordinates = {\n        latitude: null,\n        longitude: null\n      };\n\n      // Try different methods to get coordinates\n      if (fields.latitude && fields.longitude) {\n        coordinates = {\n          latitude: parseFloat(item[fields.latitude]),\n          longitude: parseFloat(item[fields.longitude])\n        };\n      } else if (fields.geoLocation) {\n        coordinates = extractCoordinates(item[fields.geoLocation]);\n      } else if (locationColumn) {\n        const locationQuery = [item[fields.city], item[fields.state], item[locationColumn]].filter(Boolean).join(', ');\n        if (locationQuery) {\n          coordinates = await geocodeLocationWithRateLimit(locationQuery);\n        }\n      }\n\n      // Validate and add coordinates\n      if (isValidCoordinate(coordinates.latitude, coordinates.longitude)) {\n        // Clean up existing coordinate fields\n        Object.values(FIELD_MAPPINGS).flat().forEach(field => delete item[field]);\n        processedData.push({\n          ...item,\n          latitude: coordinates.latitude,\n          longitude: coordinates.longitude\n        });\n      }\n\n      // Update progress periodically\n      const now = Date.now();\n      if (now - lastProgressUpdate > options.progressUpdateInterval) {\n        const progress = 20 + Math.floor(i / limitedData.length * 70);\n        setProgress === null || setProgress === void 0 ? void 0 : setProgress(prev => ({\n          ...prev,\n          preprocess: progress\n        }));\n        lastProgressUpdate = now;\n        await delay(1);\n      }\n    }\n    if (processedData.length === 0) {\n      throw new Error('No valid data points after processing');\n    }\n    console.log(`Successfully processed ${processedData.length} data points`);\n    setProgress === null || setProgress === void 0 ? void 0 : setProgress(prev => ({\n      ...prev,\n      preprocess: 100\n    }));\n    return processedData;\n  } catch (error) {\n    console.error('Preprocessing failed:', error);\n    setProgress === null || setProgress === void 0 ? void 0 : setProgress(prev => ({\n      ...prev,\n      preprocess: 0\n    }));\n    throw error;\n  }\n};\nexport default preprocessData;","map":{"version":3,"names":["axios","MAPBOX_TOKEN","FIELD_MAPPINGS","latitude","longitude","state","city","geoLocation","DEFAULT_CONFIG","maxRows","batchSize","retryDelay","maxRetries","progressUpdateInterval","delay","ms","Promise","resolve","setTimeout","GeocodingCache","constructor","ttlMs","cache","Map","ttl","get","key","item","Date","now","expires","delete","value","set","geocodeCache","extractCoordinates","patterns","point","coordinates","latLon","format","regex","Object","entries","match","parseFloat","isValidCoordinate","lat","lon","isNaN","geocodeLocationWithRateLimit","locationName","retryCount","delayMs","cached","response","encodeURIComponent","params","access_token","limit","types","features","data","length","center","result","error","_error$response","_error$response2","console","message","status","detectFields","possibleFields","find","field","hasOwnProperty","some","row","undefined","preprocessData","setProgress","locationColumn","config","options","prev","preprocess","Array","isArray","Error","limitedData","slice","fields","log","processedData","lastProgressUpdate","i","locationQuery","filter","Boolean","join","values","flat","forEach","push","progress","Math","floor"],"sources":["/Users/girishkumarpatchikoru/Desktop/projecthci/geovizproject/frontend/src/components/preprocessData.js"],"sourcesContent":["// src/components/preprocessData.js\n\nimport axios from 'axios';\nimport { MAPBOX_TOKEN } from './constants';\n\n// TypeScript-like constants for field mappings\nconst FIELD_MAPPINGS = {\n  latitude: ['latitude', 'Latitude', 'lat', 'Lat', 'LAT', 'LATITUDE'],\n  longitude: ['longitude', 'Longitude', 'lon', 'Lng', 'Long', 'LONGITUDE', 'LON'],\n  state: ['state', 'STATE_NAME', 'state_id', 'STATE_CODE', 'STATE'],\n  city: ['city', 'CITY_NAME', 'city_ascii', 'CITY'],\n  geoLocation: ['GeoLocation', 'GEOLOCATION', 'geo_location', 'geometry']\n};\n\n// Configuration object for preprocessing options\nconst DEFAULT_CONFIG = {\n  maxRows: 100000,\n  batchSize: 100,\n  retryDelay: 200,\n  maxRetries: 3,\n  progressUpdateInterval: 100\n};\n\n// Utility function for delay with timeout\nconst delay = (ms) => new Promise((resolve) => setTimeout(resolve, ms));\n\n// Enhanced geocoding cache with TTL\nclass GeocodingCache {\n  constructor(ttlMs = 24 * 60 * 60 * 1000) { // 24 hour default TTL\n    this.cache = new Map();\n    this.ttl = ttlMs;\n  }\n\n  get(key) {\n    const item = this.cache.get(key);\n    if (!item) return null;\n    if (Date.now() > item.expires) {\n      this.cache.delete(key);\n      return null;\n    }\n    return item.value;\n  }\n\n  set(key, value) {\n    this.cache.set(key, {\n      value,\n      expires: Date.now() + this.ttl\n    });\n  }\n}\n\nconst geocodeCache = new GeocodingCache();\n\n// Enhanced coordinate extraction with validation\nconst extractCoordinates = (geoLocation) => {\n  if (!geoLocation) return { latitude: null, longitude: null };\n  \n  // Support multiple geometry formats\n  const patterns = {\n    point: /POINT\\s*\\(\\s*([-.\\d]+)\\s+([-.\\d]+)\\s*\\)/i,\n    coordinates: /\"coordinates\":\\s*\\[\\s*([-.\\d]+)\\s*,\\s*([-.\\d]+)\\s*\\]/i,\n    latLon: /\"lat\":\\s*([-.\\d]+).*\"lon\":\\s*([-.\\d]+)/i\n  };\n\n  for (const [format, regex] of Object.entries(patterns)) {\n    const match = geoLocation.match(regex);\n    if (match) {\n      const [longitude, latitude] = format === 'latLon' \n        ? [parseFloat(match[2]), parseFloat(match[1])]\n        : [parseFloat(match[1]), parseFloat(match[2])];\n        \n      if (isValidCoordinate(latitude, longitude)) {\n        return { latitude, longitude };\n      }\n    }\n  }\n  \n  return { latitude: null, longitude: null };\n};\n\n// Coordinate validation\nconst isValidCoordinate = (lat, lon) => {\n  return lat !== null && \n         lon !== null && \n         !isNaN(lat) && \n         !isNaN(lon) && \n         lat >= -90 && \n         lat <= 90 && \n         lon >= -180 && \n         lon <= 180;\n};\n\n// Enhanced geocoding with rate limiting and retries\nconst geocodeLocationWithRateLimit = async (\n  locationName, \n  retryCount = 0,\n  delayMs = DEFAULT_CONFIG.retryDelay\n) => {\n  const cached = geocodeCache.get(locationName);\n  if (cached) return cached;\n\n  try {\n    const response = await axios.get(\n      `https://api.mapbox.com/geocoding/v5/mapbox.places/${encodeURIComponent(\n        locationName\n      )}.json`,\n      {\n        params: {\n          access_token: MAPBOX_TOKEN,\n          limit: 1,\n          types: 'place,region,country'\n        }\n      }\n    );\n\n    const features = response.data.features;\n    if (features?.length > 0) {\n      const [longitude, latitude] = features[0].center;\n      const result = { latitude, longitude };\n      if (isValidCoordinate(latitude, longitude)) {\n        geocodeCache.set(locationName, result);\n        return result;\n      }\n    }\n  } catch (error) {\n    console.error(`Geocoding error for \"${locationName}\":`, error.message);\n    \n    if (retryCount < DEFAULT_CONFIG.maxRetries && \n        (error.response?.status === 429 || error.response?.status >= 500)) {\n      await delay(delayMs);\n      return geocodeLocationWithRateLimit(\n        locationName,\n        retryCount + 1,\n        delayMs * 2\n      );\n    }\n  }\n\n  return { latitude: null, longitude: null };\n};\n\n// Field detection utility\nconst detectFields = (data, possibleFields) => {\n  if (!data || data.length === 0) return null;\n  return possibleFields.find(field => \n    data[0].hasOwnProperty(field) && \n    data.some(row => row[field] !== null && row[field] !== undefined)\n  );\n};\n\n// Main preprocess function with enhanced error handling and validation\nconst preprocessData = async (\n  data, \n  setProgress, \n  locationColumn,\n  config = {}\n) => {\n  const options = { ...DEFAULT_CONFIG, ...config };\n  \n  try {\n    setProgress?.(prev => ({ ...prev, preprocess: 0 }));\n\n    if (!Array.isArray(data) || data.length === 0) {\n      throw new Error('Input data must be a non-empty array');\n    }\n\n    // Limit data size\n    const limitedData = data.slice(0, options.maxRows);\n    setProgress?.(prev => ({ ...prev, preprocess: 10 }));\n\n    // Detect fields\n    const fields = {\n      latitude: detectFields(limitedData, FIELD_MAPPINGS.latitude),\n      longitude: detectFields(limitedData, FIELD_MAPPINGS.longitude),\n      state: detectFields(limitedData, FIELD_MAPPINGS.state),\n      city: detectFields(limitedData, FIELD_MAPPINGS.city),\n      geoLocation: detectFields(limitedData, FIELD_MAPPINGS.geoLocation)\n    };\n\n    console.log('Detected fields:', fields);\n    setProgress?.(prev => ({ ...prev, preprocess: 20 }));\n\n    // Filter and process data\n    const processedData = [];\n    let lastProgressUpdate = Date.now();\n\n    for (let i = 0; i < limitedData.length; i++) {\n      const item = { ...limitedData[i] };\n      let coordinates = { latitude: null, longitude: null };\n\n      // Try different methods to get coordinates\n      if (fields.latitude && fields.longitude) {\n        coordinates = {\n          latitude: parseFloat(item[fields.latitude]),\n          longitude: parseFloat(item[fields.longitude])\n        };\n      } else if (fields.geoLocation) {\n        coordinates = extractCoordinates(item[fields.geoLocation]);\n      } else if (locationColumn) {\n        const locationQuery = [\n          item[fields.city],\n          item[fields.state],\n          item[locationColumn]\n        ]\n          .filter(Boolean)\n          .join(', ');\n\n        if (locationQuery) {\n          coordinates = await geocodeLocationWithRateLimit(locationQuery);\n        }\n      }\n\n      // Validate and add coordinates\n      if (isValidCoordinate(coordinates.latitude, coordinates.longitude)) {\n        // Clean up existing coordinate fields\n        Object.values(FIELD_MAPPINGS)\n          .flat()\n          .forEach(field => delete item[field]);\n\n        processedData.push({\n          ...item,\n          latitude: coordinates.latitude,\n          longitude: coordinates.longitude\n        });\n      }\n\n      // Update progress periodically\n      const now = Date.now();\n      if (now - lastProgressUpdate > options.progressUpdateInterval) {\n        const progress = 20 + Math.floor((i / limitedData.length) * 70);\n        setProgress?.(prev => ({ ...prev, preprocess: progress }));\n        lastProgressUpdate = now;\n        await delay(1);\n      }\n    }\n\n    if (processedData.length === 0) {\n      throw new Error('No valid data points after processing');\n    }\n\n    console.log(`Successfully processed ${processedData.length} data points`);\n    setProgress?.(prev => ({ ...prev, preprocess: 100 }));\n\n    return processedData;\n\n  } catch (error) {\n    console.error('Preprocessing failed:', error);\n    setProgress?.(prev => ({ ...prev, preprocess: 0 }));\n    throw error;\n  }\n};\n\nexport default preprocessData;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}
{"ast":null,"code":"// src/components/preprocessData.js\n\nimport axios from 'axios';\nimport { MAPBOX_TOKEN } from './constants';\n\n// Function to extract coordinates from GeoLocation field if present\nconst extractCoordinates = geoLocation => {\n  if (!geoLocation) return {\n    latitude: null,\n    longitude: null\n  };\n  const regex = /POINT\\s*\\(\\s*([-.\\d]+)\\s+([-.\\d]+)\\s*\\)/i;\n  const match = geoLocation.match(regex);\n  if (match) {\n    return {\n      longitude: parseFloat(match[1]),\n      latitude: parseFloat(match[2])\n    };\n  }\n  return {\n    latitude: null,\n    longitude: null\n  };\n};\n\n// Function to geocode location names (e.g., cities) to get coordinates\nconst geocodeLocation = async locationName => {\n  if (!locationName) return {\n    latitude: null,\n    longitude: null\n  };\n  try {\n    const response = await axios.get(`https://api.mapbox.com/geocoding/v5/mapbox.places/${encodeURIComponent(locationName)}.json`, {\n      params: {\n        access_token: MAPBOX_TOKEN,\n        limit: 1\n      }\n    });\n    const features = response.data.features;\n    if (features && features.length > 0) {\n      const [longitude, latitude] = features[0].center;\n      return {\n        latitude,\n        longitude\n      };\n    }\n    return {\n      latitude: null,\n      longitude: null\n    };\n  } catch (error) {\n    console.error('Geocoding error:', error);\n    return {\n      latitude: null,\n      longitude: null\n    };\n  }\n};\n\n// Main preprocess function\nconst preprocessData = async (data, setProgress) => {\n  // Initialize progress\n  setProgress(prev => ({\n    ...prev,\n    preprocess: 0\n  }));\n  const limitedData = data.slice(0, 100000); // Limit data to 100,000 rows\n\n  setProgress(prev => ({\n    ...prev,\n    preprocess: 10\n  }));\n\n  // Define possible column names for latitude and longitude\n  const possibleLatitudeFields = ['latitude', 'Latitude', 'lat', 'Lat', 'LATITUDE', 'LAT'];\n  const possibleLongitudeFields = ['longitude', 'Longitude', 'lon', 'Lng', 'Long', 'LONGITUDE', 'LNG', 'LON'];\n\n  // Define possible location fields\n  const possibleLocationFields = ['city', 'City', 'CITY', 'county', 'County', 'COUNTY', 'state', 'State', 'STATE', 'state_name', 'State_Name', 'STATE_NAME'];\n\n  // Map dataset columns to standard names\n  const firstRow = limitedData[0];\n\n  // Map latitude field\n  let latitudeField = possibleLatitudeFields.find(field => field in firstRow);\n  // Map longitude field\n  let longitudeField = possibleLongitudeFields.find(field => field in firstRow);\n  // Map location field\n  let locationField = possibleLocationFields.find(field => field in firstRow);\n  if (!latitudeField || !longitudeField) {\n    // If latitude and longitude are not available, we need a location field\n    if (!locationField) {\n      alert('No valid location information found in the dataset.');\n      return [];\n    }\n  }\n  setProgress(prev => ({\n    ...prev,\n    preprocess: 20\n  }));\n  const requiredFields = [];\n  if (!latitudeField || !longitudeField) {\n    requiredFields.push(locationField);\n  }\n  const cleanData = limitedData.filter(row => {\n    return requiredFields.every(field => row.hasOwnProperty(field) && row[field] !== null && row[field] !== undefined && row[field].toString().trim() !== '');\n  });\n  if (cleanData.length === 0) {\n    alert('No data available after filtering out rows with missing critical fields.');\n    return [];\n  }\n  setProgress(prev => ({\n    ...prev,\n    preprocess: 30\n  }));\n  const dataWithCoords = await Promise.all(cleanData.map(async item => {\n    let latitude = null;\n    let longitude = null;\n    let locationName = '';\n    if (latitudeField && longitudeField) {\n      latitude = parseFloat(item[latitudeField]);\n      longitude = parseFloat(item[longitudeField]);\n    } else if (item.GeoLocation) {\n      const coords = extractCoordinates(item.GeoLocation);\n      latitude = coords.latitude;\n      longitude = coords.longitude;\n    } else if (item[locationField]) {\n      // Geocode if we have a location name\n      locationName = item[locationField];\n      const coords = await geocodeLocation(locationName);\n      latitude = coords.latitude;\n      longitude = coords.longitude;\n    }\n\n    // Remove any existing latitude and longitude fields to avoid confusion\n    possibleLatitudeFields.forEach(field => {\n      delete item[field];\n    });\n    possibleLongitudeFields.forEach(field => {\n      delete item[field];\n    });\n    return {\n      ...item,\n      latitude,\n      longitude\n    };\n  }));\n  setProgress(prev => ({\n    ...prev,\n    preprocess: 70\n  }));\n  const cleanDataWithCoords = dataWithCoords.filter(item => item.latitude !== null && item.longitude !== null && !isNaN(item.latitude) && !isNaN(item.longitude));\n  if (cleanDataWithCoords.length === 0) {\n    alert('No data available after extracting coordinates.');\n    return [];\n  }\n  setProgress(prev => ({\n    ...prev,\n    preprocess: 90\n  }));\n  setProgress(prev => ({\n    ...prev,\n    preprocess: 100\n  }));\n  return cleanDataWithCoords;\n};\nexport default preprocessData;","map":{"version":3,"names":["axios","MAPBOX_TOKEN","extractCoordinates","geoLocation","latitude","longitude","regex","match","parseFloat","geocodeLocation","locationName","response","get","encodeURIComponent","params","access_token","limit","features","data","length","center","error","console","preprocessData","setProgress","prev","preprocess","limitedData","slice","possibleLatitudeFields","possibleLongitudeFields","possibleLocationFields","firstRow","latitudeField","find","field","longitudeField","locationField","alert","requiredFields","push","cleanData","filter","row","every","hasOwnProperty","undefined","toString","trim","dataWithCoords","Promise","all","map","item","GeoLocation","coords","forEach","cleanDataWithCoords","isNaN"],"sources":["/Users/girishkumarpatchikoru/Desktop/projecthci/geovizproject/frontend/src/components/preprocessData.js"],"sourcesContent":["// src/components/preprocessData.js\n\n\nimport axios from 'axios';\nimport { MAPBOX_TOKEN } from './constants';\n\n\n// Function to extract coordinates from GeoLocation field if present\nconst extractCoordinates = (geoLocation) => {\n if (!geoLocation) return { latitude: null, longitude: null };\n const regex = /POINT\\s*\\(\\s*([-.\\d]+)\\s+([-.\\d]+)\\s*\\)/i;\n const match = geoLocation.match(regex);\n if (match) {\n   return {\n     longitude: parseFloat(match[1]),\n     latitude: parseFloat(match[2]),\n   };\n }\n return { latitude: null, longitude: null };\n};\n\n\n// Function to geocode location names (e.g., cities) to get coordinates\nconst geocodeLocation = async (locationName) => {\n if (!locationName) return { latitude: null, longitude: null };\n try {\n   const response = await axios.get(\n     `https://api.mapbox.com/geocoding/v5/mapbox.places/${encodeURIComponent(\n       locationName\n     )}.json`,\n     {\n       params: {\n         access_token: MAPBOX_TOKEN,\n         limit: 1,\n       },\n     }\n   );\n   const features = response.data.features;\n   if (features && features.length > 0) {\n     const [longitude, latitude] = features[0].center;\n     return { latitude, longitude };\n   }\n   return { latitude: null, longitude: null };\n } catch (error) {\n   console.error('Geocoding error:', error);\n   return { latitude: null, longitude: null };\n }\n};\n\n\n// Main preprocess function\nconst preprocessData = async (data, setProgress) => {\n // Initialize progress\n setProgress((prev) => ({ ...prev, preprocess: 0 }));\n\n\n const limitedData = data.slice(0, 100000); // Limit data to 100,000 rows\n\n\n setProgress((prev) => ({ ...prev, preprocess: 10 }));\n\n\n // Define possible column names for latitude and longitude\n const possibleLatitudeFields = ['latitude', 'Latitude', 'lat', 'Lat', 'LATITUDE', 'LAT'];\n const possibleLongitudeFields = ['longitude', 'Longitude', 'lon', 'Lng', 'Long', 'LONGITUDE', 'LNG', 'LON'];\n\n\n // Define possible location fields\n const possibleLocationFields = [\n   'city',\n   'City',\n   'CITY',\n   'county',\n   'County',\n   'COUNTY',\n   'state',\n   'State',\n   'STATE',\n   'state_name',\n   'State_Name',\n   'STATE_NAME',\n ];\n\n\n // Map dataset columns to standard names\n const firstRow = limitedData[0];\n\n\n // Map latitude field\n let latitudeField = possibleLatitudeFields.find((field) => field in firstRow);\n // Map longitude field\n let longitudeField = possibleLongitudeFields.find((field) => field in firstRow);\n // Map location field\n let locationField = possibleLocationFields.find((field) => field in firstRow);\n\n\n if (!latitudeField || !longitudeField) {\n   // If latitude and longitude are not available, we need a location field\n   if (!locationField) {\n     alert('No valid location information found in the dataset.');\n     return [];\n   }\n }\n\n\n setProgress((prev) => ({ ...prev, preprocess: 20 }));\n\n\n const requiredFields = [];\n if (!latitudeField || !longitudeField) {\n   requiredFields.push(locationField);\n }\n\n\n const cleanData = limitedData.filter((row) => {\n   return requiredFields.every(\n     (field) =>\n       row.hasOwnProperty(field) &&\n       row[field] !== null &&\n       row[field] !== undefined &&\n       row[field].toString().trim() !== ''\n   );\n });\n\n\n if (cleanData.length === 0) {\n   alert('No data available after filtering out rows with missing critical fields.');\n   return [];\n }\n\n\n setProgress((prev) => ({ ...prev, preprocess: 30 }));\n\n\n const dataWithCoords = await Promise.all(\n   cleanData.map(async (item) => {\n     let latitude = null;\n     let longitude = null;\n     let locationName = '';\n\n\n     if (latitudeField && longitudeField) {\n       latitude = parseFloat(item[latitudeField]);\n       longitude = parseFloat(item[longitudeField]);\n     } else if (item.GeoLocation) {\n       const coords = extractCoordinates(item.GeoLocation);\n       latitude = coords.latitude;\n       longitude = coords.longitude;\n     } else if (item[locationField]) {\n       // Geocode if we have a location name\n       locationName = item[locationField];\n       const coords = await geocodeLocation(locationName);\n       latitude = coords.latitude;\n       longitude = coords.longitude;\n     }\n\n\n     // Remove any existing latitude and longitude fields to avoid confusion\n     possibleLatitudeFields.forEach((field) => {\n       delete item[field];\n     });\n     possibleLongitudeFields.forEach((field) => {\n       delete item[field];\n     });\n\n\n     return { ...item, latitude, longitude };\n   })\n );\n\n\n setProgress((prev) => ({ ...prev, preprocess: 70 }));\n\n\n const cleanDataWithCoords = dataWithCoords.filter(\n   (item) =>\n     item.latitude !== null &&\n     item.longitude !== null &&\n     !isNaN(item.latitude) &&\n     !isNaN(item.longitude)\n );\n\n\n if (cleanDataWithCoords.length === 0) {\n   alert('No data available after extracting coordinates.');\n   return [];\n }\n\n\n setProgress((prev) => ({ ...prev, preprocess: 90 }));\n\n\n setProgress((prev) => ({ ...prev, preprocess: 100 }));\n\n\n return cleanDataWithCoords;\n};\n\n\nexport default preprocessData;\n\n\n\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}
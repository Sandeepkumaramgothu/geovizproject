{"ast":null,"code":"import axios from'axios';import{MAPBOX_TOKEN}from'./constants';const geocodeLocation=async locationName=>{if(!locationName)return{latitude:null,longitude:null};try{const response=await axios.get(`https://api.mapbox.com/geocoding/v5/mapbox.places/${encodeURIComponent(locationName)}.json`,{params:{access_token:MAPBOX_TOKEN,limit:1}});const features=response.data.features;if(features&&features.length>0){const[longitude,latitude]=features[0].center;return{latitude,longitude};}return{latitude:null,longitude:null};}catch(error){console.error('Geocoding error:',error);return{latitude:null,longitude:null};}};//Main preprocess\nconst preprocessData=async(data,setProgress)=>{setProgress(prev=>({...prev,preprocess:0}));const limitedData=data.slice(0,100000);setProgress(prev=>({...prev,preprocess:10}));//possible column names for latitude and longitude\nconst possibleLatitudeFields=['latitude','Latitude','lat','Lat','LATITUDE','LAT'];const possibleLongitudeFields=['longitude','Longitude','lon','Lng','Long','LONGITUDE','LNG','LON'];//possible location fields\nconst possibleLocationFields=['city','City','CITY','county','County','COUNTY','state','State','STATE','state_name','State_Name','STATE_NAME'];// Mapdataset columns to standard names\nconst firstRow=limitedData[0];// Maplatitude field\nlet latitudeField=possibleLatitudeFields.find(field=>field in firstRow);// Maplongitude field\nlet longitudeField=possibleLongitudeFields.find(field=>field in firstRow);// Maplocation field\nlet locationField=possibleLocationFields.find(field=>field in firstRow);setProgress(prev=>({...prev,preprocess:20}));const requiredFields=[];if(!latitudeField||!longitudeField){if(locationField){requiredFields.push(locationField);}}const cleanData=limitedData.filter(row=>{if(requiredFields.length>0){return requiredFields.every(field=>row.hasOwnProperty(field)&&row[field]!==null&&row[field]!==undefined&&row[field].toString().trim()!=='');}else{return row!==null&&row!==undefined&&Object.keys(row).length>0;}});if(cleanData.length===0){alert('No data available after filtering out rows with missing critical fields.');return[];}setProgress(prev=>({...prev,preprocess:30}));let dataWithCoords;if(latitudeField&&longitudeField){//check latitude and longitude, no need to geocode\ndataWithCoords=cleanData.map(item=>{const latitude=parseFloat(item[latitudeField]);const longitude=parseFloat(item[longitudeField]);// Removeexisting latitude and longitude fields to avoid muultiple location selecction\npossibleLatitudeFields.forEach(field=>{delete item[field];});possibleLongitudeFields.forEach(field=>{delete item[field];});return{...item,latitude,longitude};});}else if(locationField){//geocode the location names to get coordinates\ndataWithCoords=await Promise.all(cleanData.map(async item=>{let latitude=null;let longitude=null;let locationName=item[locationField];const coords=await geocodeLocation(locationName);latitude=coords.latitude;longitude=coords.longitude;// Removeexisting latitude and longitude fields to avoid muultiple location selecction\npossibleLatitudeFields.forEach(field=>{delete item[field];});possibleLongitudeFields.forEach(field=>{delete item[field];});return{...item,latitude,longitude};}));}else{// Nolocation data, proceed without coordinates\ndataWithCoords=cleanData;}setProgress(prev=>({...prev,preprocess:70}));// given  numeric and string headers even without location data\nsetProgress(prev=>({...prev,preprocess:90}));setProgress(prev=>({...prev,preprocess:100}));return dataWithCoords;};export default preprocessData;","map":{"version":3,"names":["axios","MAPBOX_TOKEN","geocodeLocation","locationName","latitude","longitude","response","get","encodeURIComponent","params","access_token","limit","features","data","length","center","error","console","preprocessData","setProgress","prev","preprocess","limitedData","slice","possibleLatitudeFields","possibleLongitudeFields","possibleLocationFields","firstRow","latitudeField","find","field","longitudeField","locationField","requiredFields","push","cleanData","filter","row","every","hasOwnProperty","undefined","toString","trim","Object","keys","alert","dataWithCoords","map","item","parseFloat","forEach","Promise","all","coords"],"sources":["/Users/girishkumarpatchikoru/Desktop/projecthci/geovizproject/frontend/src/components/preprocessData.js"],"sourcesContent":["import axios from 'axios';\nimport { MAPBOX_TOKEN } from './constants';\n\nconst geocodeLocation = async (locationName) => {\n  if (!locationName) return { latitude: null, longitude: null };\n  try {\n    const response = await axios.get(\n      `https://api.mapbox.com/geocoding/v5/mapbox.places/${encodeURIComponent(\n        locationName\n      )}.json`,\n      {\n        params: {\n          access_token: MAPBOX_TOKEN,\n          limit: 1,\n        },\n      }\n    );\n    const features = response.data.features;\n    if (features && features.length > 0) {\n      const [longitude, latitude] = features[0].center;\n      return { latitude, longitude };\n    }\n    return { latitude: null, longitude: null };\n  } catch (error) {\n    console.error('Geocoding error:', error);\n    return { latitude: null, longitude: null };\n  }\n};\n\n//Main preprocess\nconst preprocessData = async (data, setProgress) => {\n  setProgress((prev) => ({ ...prev, preprocess: 0 }));\n\n  const limitedData = data.slice(0, 100000); \n\n  setProgress((prev) => ({ ...prev, preprocess: 10 }));\n\n  //possible column names for latitude and longitude\n  const possibleLatitudeFields = ['latitude', 'Latitude', 'lat', 'Lat', 'LATITUDE', 'LAT'];\n  const possibleLongitudeFields = ['longitude', 'Longitude', 'lon', 'Lng', 'Long', 'LONGITUDE', 'LNG', 'LON'];\n\n  //possible location fields\n  const possibleLocationFields = [\n    'city',\n    'City',\n    'CITY',\n    'county',\n    'County',\n    'COUNTY',\n    'state',\n    'State',\n    'STATE',\n    'state_name',\n    'State_Name',\n    'STATE_NAME',\n  ];\n\n  // Mapdataset columns to standard names\n  const firstRow = limitedData[0];\n\n  // Maplatitude field\n  let latitudeField = possibleLatitudeFields.find((field) => field in firstRow);\n  // Maplongitude field\n  let longitudeField = possibleLongitudeFields.find((field) => field in firstRow);\n  // Maplocation field\n  let locationField = possibleLocationFields.find((field) => field in firstRow);\n\n  setProgress((prev) => ({ ...prev, preprocess: 20 }));\n\n  const requiredFields = [];\n  if (!latitudeField || !longitudeField) {\n    if (locationField) {\n      requiredFields.push(locationField);\n    }\n  }\n\n  const cleanData = limitedData.filter((row) => {\n    if (requiredFields.length > 0) {\n      return requiredFields.every(\n        (field) =>\n          row.hasOwnProperty(field) &&\n          row[field] !== null &&\n          row[field] !== undefined &&\n          row[field].toString().trim() !== ''\n      );\n    } else {\n      return row !== null && row !== undefined && Object.keys(row).length > 0;\n    }\n  });\n\n  if (cleanData.length === 0) {\n    alert('No data available after filtering out rows with missing critical fields.');\n    return [];\n  }\n\n  setProgress((prev) => ({ ...prev, preprocess: 30 }));\n\n  let dataWithCoords;\n\n  if (latitudeField && longitudeField) {\n    //check latitude and longitude, no need to geocode\n    dataWithCoords = cleanData.map((item) => {\n      const latitude = parseFloat(item[latitudeField]);\n      const longitude = parseFloat(item[longitudeField]);\n\n      // Removeexisting latitude and longitude fields to avoid muultiple location selecction\n      possibleLatitudeFields.forEach((field) => {\n        delete item[field];\n      });\n      possibleLongitudeFields.forEach((field) => {\n        delete item[field];\n      });\n\n      return { ...item, latitude, longitude };\n    });\n  } else if (locationField) {\n    //geocode the location names to get coordinates\n    dataWithCoords = await Promise.all(\n      cleanData.map(async (item) => {\n        let latitude = null;\n        let longitude = null;\n        let locationName = item[locationField];\n\n        const coords = await geocodeLocation(locationName);\n        latitude = coords.latitude;\n        longitude = coords.longitude;\n\n        // Removeexisting latitude and longitude fields to avoid muultiple location selecction\n        possibleLatitudeFields.forEach((field) => {\n          delete item[field];\n        });\n        possibleLongitudeFields.forEach((field) => {\n          delete item[field];\n        });\n\n        return { ...item, latitude, longitude };\n      })\n    );\n  } else {\n    // Nolocation data, proceed without coordinates\n    dataWithCoords = cleanData;\n  }\n\n  setProgress((prev) => ({ ...prev, preprocess: 70 }));\n\n  // given  numeric and string headers even without location data\n\n  setProgress((prev) => ({ ...prev, preprocess: 90 }));\n\n  setProgress((prev) => ({ ...prev, preprocess: 100 }));\n\n  return dataWithCoords;\n};\n\nexport default preprocessData;\n"],"mappings":"AAAA,MAAO,CAAAA,KAAK,KAAM,OAAO,CACzB,OAASC,YAAY,KAAQ,aAAa,CAE1C,KAAM,CAAAC,eAAe,CAAG,KAAO,CAAAC,YAAY,EAAK,CAC9C,GAAI,CAACA,YAAY,CAAE,MAAO,CAAEC,QAAQ,CAAE,IAAI,CAAEC,SAAS,CAAE,IAAK,CAAC,CAC7D,GAAI,CACF,KAAM,CAAAC,QAAQ,CAAG,KAAM,CAAAN,KAAK,CAACO,GAAG,CAC9B,qDAAqDC,kBAAkB,CACrEL,YACF,CAAC,OAAO,CACR,CACEM,MAAM,CAAE,CACNC,YAAY,CAAET,YAAY,CAC1BU,KAAK,CAAE,CACT,CACF,CACF,CAAC,CACD,KAAM,CAAAC,QAAQ,CAAGN,QAAQ,CAACO,IAAI,CAACD,QAAQ,CACvC,GAAIA,QAAQ,EAAIA,QAAQ,CAACE,MAAM,CAAG,CAAC,CAAE,CACnC,KAAM,CAACT,SAAS,CAAED,QAAQ,CAAC,CAAGQ,QAAQ,CAAC,CAAC,CAAC,CAACG,MAAM,CAChD,MAAO,CAAEX,QAAQ,CAAEC,SAAU,CAAC,CAChC,CACA,MAAO,CAAED,QAAQ,CAAE,IAAI,CAAEC,SAAS,CAAE,IAAK,CAAC,CAC5C,CAAE,MAAOW,KAAK,CAAE,CACdC,OAAO,CAACD,KAAK,CAAC,kBAAkB,CAAEA,KAAK,CAAC,CACxC,MAAO,CAAEZ,QAAQ,CAAE,IAAI,CAAEC,SAAS,CAAE,IAAK,CAAC,CAC5C,CACF,CAAC,CAED;AACA,KAAM,CAAAa,cAAc,CAAG,KAAAA,CAAOL,IAAI,CAAEM,WAAW,GAAK,CAClDA,WAAW,CAAEC,IAAI,GAAM,CAAE,GAAGA,IAAI,CAAEC,UAAU,CAAE,CAAE,CAAC,CAAC,CAAC,CAEnD,KAAM,CAAAC,WAAW,CAAGT,IAAI,CAACU,KAAK,CAAC,CAAC,CAAE,MAAM,CAAC,CAEzCJ,WAAW,CAAEC,IAAI,GAAM,CAAE,GAAGA,IAAI,CAAEC,UAAU,CAAE,EAAG,CAAC,CAAC,CAAC,CAEpD;AACA,KAAM,CAAAG,sBAAsB,CAAG,CAAC,UAAU,CAAE,UAAU,CAAE,KAAK,CAAE,KAAK,CAAE,UAAU,CAAE,KAAK,CAAC,CACxF,KAAM,CAAAC,uBAAuB,CAAG,CAAC,WAAW,CAAE,WAAW,CAAE,KAAK,CAAE,KAAK,CAAE,MAAM,CAAE,WAAW,CAAE,KAAK,CAAE,KAAK,CAAC,CAE3G;AACA,KAAM,CAAAC,sBAAsB,CAAG,CAC7B,MAAM,CACN,MAAM,CACN,MAAM,CACN,QAAQ,CACR,QAAQ,CACR,QAAQ,CACR,OAAO,CACP,OAAO,CACP,OAAO,CACP,YAAY,CACZ,YAAY,CACZ,YAAY,CACb,CAED;AACA,KAAM,CAAAC,QAAQ,CAAGL,WAAW,CAAC,CAAC,CAAC,CAE/B;AACA,GAAI,CAAAM,aAAa,CAAGJ,sBAAsB,CAACK,IAAI,CAAEC,KAAK,EAAKA,KAAK,GAAI,CAAAH,QAAQ,CAAC,CAC7E;AACA,GAAI,CAAAI,cAAc,CAAGN,uBAAuB,CAACI,IAAI,CAAEC,KAAK,EAAKA,KAAK,GAAI,CAAAH,QAAQ,CAAC,CAC/E;AACA,GAAI,CAAAK,aAAa,CAAGN,sBAAsB,CAACG,IAAI,CAAEC,KAAK,EAAKA,KAAK,GAAI,CAAAH,QAAQ,CAAC,CAE7ER,WAAW,CAAEC,IAAI,GAAM,CAAE,GAAGA,IAAI,CAAEC,UAAU,CAAE,EAAG,CAAC,CAAC,CAAC,CAEpD,KAAM,CAAAY,cAAc,CAAG,EAAE,CACzB,GAAI,CAACL,aAAa,EAAI,CAACG,cAAc,CAAE,CACrC,GAAIC,aAAa,CAAE,CACjBC,cAAc,CAACC,IAAI,CAACF,aAAa,CAAC,CACpC,CACF,CAEA,KAAM,CAAAG,SAAS,CAAGb,WAAW,CAACc,MAAM,CAAEC,GAAG,EAAK,CAC5C,GAAIJ,cAAc,CAACnB,MAAM,CAAG,CAAC,CAAE,CAC7B,MAAO,CAAAmB,cAAc,CAACK,KAAK,CACxBR,KAAK,EACJO,GAAG,CAACE,cAAc,CAACT,KAAK,CAAC,EACzBO,GAAG,CAACP,KAAK,CAAC,GAAK,IAAI,EACnBO,GAAG,CAACP,KAAK,CAAC,GAAKU,SAAS,EACxBH,GAAG,CAACP,KAAK,CAAC,CAACW,QAAQ,CAAC,CAAC,CAACC,IAAI,CAAC,CAAC,GAAK,EACrC,CAAC,CACH,CAAC,IAAM,CACL,MAAO,CAAAL,GAAG,GAAK,IAAI,EAAIA,GAAG,GAAKG,SAAS,EAAIG,MAAM,CAACC,IAAI,CAACP,GAAG,CAAC,CAACvB,MAAM,CAAG,CAAC,CACzE,CACF,CAAC,CAAC,CAEF,GAAIqB,SAAS,CAACrB,MAAM,GAAK,CAAC,CAAE,CAC1B+B,KAAK,CAAC,0EAA0E,CAAC,CACjF,MAAO,EAAE,CACX,CAEA1B,WAAW,CAAEC,IAAI,GAAM,CAAE,GAAGA,IAAI,CAAEC,UAAU,CAAE,EAAG,CAAC,CAAC,CAAC,CAEpD,GAAI,CAAAyB,cAAc,CAElB,GAAIlB,aAAa,EAAIG,cAAc,CAAE,CACnC;AACAe,cAAc,CAAGX,SAAS,CAACY,GAAG,CAAEC,IAAI,EAAK,CACvC,KAAM,CAAA5C,QAAQ,CAAG6C,UAAU,CAACD,IAAI,CAACpB,aAAa,CAAC,CAAC,CAChD,KAAM,CAAAvB,SAAS,CAAG4C,UAAU,CAACD,IAAI,CAACjB,cAAc,CAAC,CAAC,CAElD;AACAP,sBAAsB,CAAC0B,OAAO,CAAEpB,KAAK,EAAK,CACxC,MAAO,CAAAkB,IAAI,CAAClB,KAAK,CAAC,CACpB,CAAC,CAAC,CACFL,uBAAuB,CAACyB,OAAO,CAAEpB,KAAK,EAAK,CACzC,MAAO,CAAAkB,IAAI,CAAClB,KAAK,CAAC,CACpB,CAAC,CAAC,CAEF,MAAO,CAAE,GAAGkB,IAAI,CAAE5C,QAAQ,CAAEC,SAAU,CAAC,CACzC,CAAC,CAAC,CACJ,CAAC,IAAM,IAAI2B,aAAa,CAAE,CACxB;AACAc,cAAc,CAAG,KAAM,CAAAK,OAAO,CAACC,GAAG,CAChCjB,SAAS,CAACY,GAAG,CAAC,KAAO,CAAAC,IAAI,EAAK,CAC5B,GAAI,CAAA5C,QAAQ,CAAG,IAAI,CACnB,GAAI,CAAAC,SAAS,CAAG,IAAI,CACpB,GAAI,CAAAF,YAAY,CAAG6C,IAAI,CAAChB,aAAa,CAAC,CAEtC,KAAM,CAAAqB,MAAM,CAAG,KAAM,CAAAnD,eAAe,CAACC,YAAY,CAAC,CAClDC,QAAQ,CAAGiD,MAAM,CAACjD,QAAQ,CAC1BC,SAAS,CAAGgD,MAAM,CAAChD,SAAS,CAE5B;AACAmB,sBAAsB,CAAC0B,OAAO,CAAEpB,KAAK,EAAK,CACxC,MAAO,CAAAkB,IAAI,CAAClB,KAAK,CAAC,CACpB,CAAC,CAAC,CACFL,uBAAuB,CAACyB,OAAO,CAAEpB,KAAK,EAAK,CACzC,MAAO,CAAAkB,IAAI,CAAClB,KAAK,CAAC,CACpB,CAAC,CAAC,CAEF,MAAO,CAAE,GAAGkB,IAAI,CAAE5C,QAAQ,CAAEC,SAAU,CAAC,CACzC,CAAC,CACH,CAAC,CACH,CAAC,IAAM,CACL;AACAyC,cAAc,CAAGX,SAAS,CAC5B,CAEAhB,WAAW,CAAEC,IAAI,GAAM,CAAE,GAAGA,IAAI,CAAEC,UAAU,CAAE,EAAG,CAAC,CAAC,CAAC,CAEpD;AAEAF,WAAW,CAAEC,IAAI,GAAM,CAAE,GAAGA,IAAI,CAAEC,UAAU,CAAE,EAAG,CAAC,CAAC,CAAC,CAEpDF,WAAW,CAAEC,IAAI,GAAM,CAAE,GAAGA,IAAI,CAAEC,UAAU,CAAE,GAAI,CAAC,CAAC,CAAC,CAErD,MAAO,CAAAyB,cAAc,CACvB,CAAC,CAED,cAAe,CAAA5B,cAAc","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}
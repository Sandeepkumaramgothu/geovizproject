{"ast":null,"code":"// src/components/preprocessData.js\n\nimport axios from 'axios';\nimport { MAPBOX_TOKEN } from './constants';\n\n// Function to introduce a delay (in milliseconds)\nconst delay = ms => new Promise(resolve => setTimeout(resolve, ms));\n\n// Cache object to store geocoding results and avoid duplicate API calls\nconst geocodeCache = {};\n\n// Function to handle geocoding with rate-limiting and caching\nconst geocodeLocationWithRateLimit = async (locationName, delayMs = 200) => {\n  if (geocodeCache[locationName]) {\n    return geocodeCache[locationName];\n  }\n  try {\n    const response = await axios.get(`https://api.mapbox.com/geocoding/v5/mapbox.places/${encodeURIComponent(locationName)}.json`, {\n      params: {\n        access_token: MAPBOX_TOKEN,\n        limit: 1\n      }\n    });\n    const features = response.data.features;\n    if (features && features.length > 0) {\n      const [longitude, latitude] = features[0].center;\n      const result = {\n        latitude,\n        longitude\n      };\n      geocodeCache[locationName] = result; // Cache the result\n      return result;\n    }\n  } catch (error) {\n    if (error.response && error.response.status === 429) {\n      console.warn('Rate limit exceeded. Retrying after delay...');\n      await delay(delayMs);\n      return geocodeLocationWithRateLimit(locationName, delayMs * 2); // Exponential backoff\n    }\n    console.error('Geocoding error:', error);\n  }\n\n  // Return null coordinates if geocoding fails\n  return {\n    latitude: null,\n    longitude: null\n  };\n};\n\n// Function to extract coordinates from GeoLocation field if present\nconst extractCoordinates = geoLocation => {\n  if (!geoLocation) return {\n    latitude: null,\n    longitude: null\n  };\n  const regex = /POINT\\s*\\(\\s*([-.\\d]+)\\s+([-.\\d]+)\\s*\\)/i;\n  const match = geoLocation.match(regex);\n  if (match) {\n    return {\n      longitude: parseFloat(match[1]),\n      latitude: parseFloat(match[2])\n    };\n  }\n  return {\n    latitude: null,\n    longitude: null\n  };\n};\n\n// Main preprocess function\nconst preprocessData = async (data, setProgress, locationColumn) => {\n  // Initialize progress\n  setProgress(prev => ({\n    ...prev,\n    preprocess: 0\n  }));\n\n  // Limit data to 100,000 rows to prevent excessive processing\n  const limitedData = data.slice(0, 100000);\n  setProgress(prev => ({\n    ...prev,\n    preprocess: 10\n  }));\n\n  // Define possible field names for latitude, longitude, state, and city\n  const possibleLatitudeFields = ['latitude', 'Latitude', 'lat', 'Lat'];\n  const possibleLongitudeFields = ['longitude', 'Longitude', 'lon', 'Lng', 'Long'];\n  const possibleStateFields = ['state', 'STATE_NAME', 'state_id', 'STATE_CODE'];\n  const possibleCityFields = ['city', 'CITY_NAME', 'city_ascii'];\n\n  // Identify the actual latitude and longitude fields in the dataset\n  let latitudeField = null;\n  let longitudeField = null;\n  if (limitedData.length > 0) {\n    latitudeField = possibleLatitudeFields.find(field => limitedData[0].hasOwnProperty(field));\n    longitudeField = possibleLongitudeFields.find(field => limitedData[0].hasOwnProperty(field));\n  } else {\n    alert('The dataset is empty.');\n    return [];\n  }\n  setProgress(prev => ({\n    ...prev,\n    preprocess: 20\n  }));\n\n  // Determine if we need to use location-based geocoding\n  let requiresGeocoding = false;\n  if (!latitudeField || !longitudeField) {\n    requiresGeocoding = true;\n  }\n\n  // Remove rows with missing critical fields (latitude, longitude, or locationColumn)\n  const requiredFields = [];\n  if (requiresGeocoding) {\n    requiredFields.push(locationColumn);\n    const foundStateField = possibleStateFields.find(field => limitedData[0].hasOwnProperty(field));\n    if (foundStateField) requiredFields.push(foundStateField);\n    const foundCityField = possibleCityFields.find(field => limitedData[0].hasOwnProperty(field));\n    if (foundCityField) requiredFields.push(foundCityField);\n  } else {\n    requiredFields.push(latitudeField, longitudeField);\n  }\n  const cleanData = limitedData.filter(row => {\n    return requiredFields.every(field => row.hasOwnProperty(field) && row[field] !== null && row[field] !== undefined && row[field].toString().trim() !== '');\n  });\n  console.log('Number of Clean Data Points:', cleanData.length);\n  if (cleanData.length === 0) {\n    alert('No data available after filtering out rows with missing critical fields.');\n    return [];\n  }\n  setProgress(prev => ({\n    ...prev,\n    preprocess: 30\n  }));\n\n  // Update latitudeField and longitudeField if they were not initially found\n  if (!latitudeField || !longitudeField) {\n    if (cleanData.length > 0) {\n      latitudeField = possibleLatitudeFields.find(field => cleanData[0].hasOwnProperty(field));\n      longitudeField = possibleLongitudeFields.find(field => cleanData[0].hasOwnProperty(field));\n    }\n  }\n\n  // Process data to ensure each item has latitude and longitude\n  const dataWithCoords = [];\n  for (let i = 0; i < cleanData.length; i++) {\n    const item = cleanData[i];\n    let latitude = null;\n    let longitude = null;\n    if (latitudeField && longitudeField) {\n      latitude = parseFloat(item[latitudeField]);\n      longitude = parseFloat(item[longitudeField]);\n    } else if (item.GeoLocation) {\n      const coords = extractCoordinates(item.GeoLocation);\n      latitude = coords.latitude;\n      longitude = coords.longitude;\n    } else if (item[locationColumn] && locationColumn !== 'locationID') {\n      // Use state and city names for geocoding if available\n      const state = possibleStateFields.find(field => item[field]) || '';\n      const city = possibleCityFields.find(field => item[field]) || '';\n      const locationQuery = `${city ? city + ', ' : ''}${state || item[locationColumn]}`;\n      const coords = await geocodeLocationWithRateLimit(locationQuery);\n      latitude = coords.latitude;\n      longitude = coords.longitude;\n    }\n\n    // Remove any existing latitude and longitude fields to avoid confusion\n    possibleLatitudeFields.forEach(field => {\n      delete item[field];\n    });\n    possibleLongitudeFields.forEach(field => {\n      delete item[field];\n    });\n\n    // Add the coordinates to the item\n    item.latitude = latitude;\n    item.longitude = longitude;\n\n    // Only include the item if it has valid coordinates\n    if (latitude !== null && longitude !== null && !isNaN(latitude) && !isNaN(longitude)) {\n      dataWithCoords.push(item);\n    }\n\n    // Update progress\n    if (i % 100 === 0) {\n      const progressValue = 30 + Math.floor(i / cleanData.length * 40); // 30% to 70%\n      setProgress(prev => ({\n        ...prev,\n        preprocess: progressValue\n      }));\n      await delay(1); // Allow UI to update\n    }\n  }\n  console.log('Number of Data Points After Extracting Coordinates:', dataWithCoords.length);\n  if (dataWithCoords.length === 0) {\n    alert('No data available after extracting coordinates.');\n    return [];\n  }\n  setProgress(prev => ({\n    ...prev,\n    preprocess: 80\n  }));\n\n  // Final processing (if any)\n  // ...\n\n  setProgress(prev => ({\n    ...prev,\n    preprocess: 100\n  }));\n  return dataWithCoords;\n};\nexport default preprocessData;","map":{"version":3,"names":["axios","MAPBOX_TOKEN","delay","ms","Promise","resolve","setTimeout","geocodeCache","geocodeLocationWithRateLimit","locationName","delayMs","response","get","encodeURIComponent","params","access_token","limit","features","data","length","longitude","latitude","center","result","error","status","console","warn","extractCoordinates","geoLocation","regex","match","parseFloat","preprocessData","setProgress","locationColumn","prev","preprocess","limitedData","slice","possibleLatitudeFields","possibleLongitudeFields","possibleStateFields","possibleCityFields","latitudeField","longitudeField","find","field","hasOwnProperty","alert","requiresGeocoding","requiredFields","push","foundStateField","foundCityField","cleanData","filter","row","every","undefined","toString","trim","log","dataWithCoords","i","item","GeoLocation","coords","state","city","locationQuery","forEach","isNaN","progressValue","Math","floor"],"sources":["/Users/girishkumarpatchikoru/Desktop/projecthci/geovizproject/frontend/src/components/preprocessData.js"],"sourcesContent":["// src/components/preprocessData.js\n\nimport axios from 'axios';\nimport { MAPBOX_TOKEN } from './constants';\n\n// Function to introduce a delay (in milliseconds)\nconst delay = (ms) => new Promise((resolve) => setTimeout(resolve, ms));\n\n// Cache object to store geocoding results and avoid duplicate API calls\nconst geocodeCache = {};\n\n// Function to handle geocoding with rate-limiting and caching\nconst geocodeLocationWithRateLimit = async (locationName, delayMs = 200) => {\n  if (geocodeCache[locationName]) {\n    return geocodeCache[locationName];\n  }\n\n  try {\n    const response = await axios.get(\n      `https://api.mapbox.com/geocoding/v5/mapbox.places/${encodeURIComponent(\n        locationName\n      )}.json`,\n      {\n        params: {\n          access_token: MAPBOX_TOKEN,\n          limit: 1,\n        },\n      }\n    );\n\n    const features = response.data.features;\n    if (features && features.length > 0) {\n      const [longitude, latitude] = features[0].center;\n      const result = { latitude, longitude };\n      geocodeCache[locationName] = result; // Cache the result\n      return result;\n    }\n  } catch (error) {\n    if (error.response && error.response.status === 429) {\n      console.warn('Rate limit exceeded. Retrying after delay...');\n      await delay(delayMs);\n      return geocodeLocationWithRateLimit(locationName, delayMs * 2); // Exponential backoff\n    }\n    console.error('Geocoding error:', error);\n  }\n\n  // Return null coordinates if geocoding fails\n  return { latitude: null, longitude: null };\n};\n\n// Function to extract coordinates from GeoLocation field if present\nconst extractCoordinates = (geoLocation) => {\n  if (!geoLocation) return { latitude: null, longitude: null };\n  const regex = /POINT\\s*\\(\\s*([-.\\d]+)\\s+([-.\\d]+)\\s*\\)/i;\n  const match = geoLocation.match(regex);\n  if (match) {\n    return {\n      longitude: parseFloat(match[1]),\n      latitude: parseFloat(match[2]),\n    };\n  }\n  return { latitude: null, longitude: null };\n};\n\n// Main preprocess function\nconst preprocessData = async (data, setProgress, locationColumn) => {\n  // Initialize progress\n  setProgress((prev) => ({ ...prev, preprocess: 0 }));\n\n  // Limit data to 100,000 rows to prevent excessive processing\n  const limitedData = data.slice(0, 100000);\n\n  setProgress((prev) => ({ ...prev, preprocess: 10 }));\n\n  // Define possible field names for latitude, longitude, state, and city\n  const possibleLatitudeFields = ['latitude', 'Latitude', 'lat', 'Lat'];\n  const possibleLongitudeFields = ['longitude', 'Longitude', 'lon', 'Lng', 'Long'];\n  const possibleStateFields = ['state', 'STATE_NAME', 'state_id', 'STATE_CODE'];\n  const possibleCityFields = ['city', 'CITY_NAME', 'city_ascii'];\n\n  // Identify the actual latitude and longitude fields in the dataset\n  let latitudeField = null;\n  let longitudeField = null;\n\n  if (limitedData.length > 0) {\n    latitudeField = possibleLatitudeFields.find((field) =>\n      limitedData[0].hasOwnProperty(field)\n    );\n    longitudeField = possibleLongitudeFields.find((field) =>\n      limitedData[0].hasOwnProperty(field)\n    );\n  } else {\n    alert('The dataset is empty.');\n    return [];\n  }\n\n  setProgress((prev) => ({ ...prev, preprocess: 20 }));\n\n  // Determine if we need to use location-based geocoding\n  let requiresGeocoding = false;\n  if (!latitudeField || !longitudeField) {\n    requiresGeocoding = true;\n  }\n\n  // Remove rows with missing critical fields (latitude, longitude, or locationColumn)\n  const requiredFields = [];\n  if (requiresGeocoding) {\n    requiredFields.push(locationColumn);\n    const foundStateField = possibleStateFields.find((field) =>\n      limitedData[0].hasOwnProperty(field)\n    );\n    if (foundStateField) requiredFields.push(foundStateField);\n\n    const foundCityField = possibleCityFields.find((field) =>\n      limitedData[0].hasOwnProperty(field)\n    );\n    if (foundCityField) requiredFields.push(foundCityField);\n  } else {\n    requiredFields.push(latitudeField, longitudeField);\n  }\n\n  const cleanData = limitedData.filter((row) => {\n    return requiredFields.every(\n      (field) =>\n        row.hasOwnProperty(field) &&\n        row[field] !== null &&\n        row[field] !== undefined &&\n        row[field].toString().trim() !== ''\n    );\n  });\n\n  console.log('Number of Clean Data Points:', cleanData.length);\n\n  if (cleanData.length === 0) {\n    alert('No data available after filtering out rows with missing critical fields.');\n    return [];\n  }\n\n  setProgress((prev) => ({ ...prev, preprocess: 30 }));\n\n  // Update latitudeField and longitudeField if they were not initially found\n  if (!latitudeField || !longitudeField) {\n    if (cleanData.length > 0) {\n      latitudeField = possibleLatitudeFields.find((field) =>\n        cleanData[0].hasOwnProperty(field)\n      );\n      longitudeField = possibleLongitudeFields.find((field) =>\n        cleanData[0].hasOwnProperty(field)\n      );\n    }\n  }\n\n  // Process data to ensure each item has latitude and longitude\n  const dataWithCoords = [];\n\n  for (let i = 0; i < cleanData.length; i++) {\n    const item = cleanData[i];\n    let latitude = null;\n    let longitude = null;\n\n    if (latitudeField && longitudeField) {\n      latitude = parseFloat(item[latitudeField]);\n      longitude = parseFloat(item[longitudeField]);\n    } else if (item.GeoLocation) {\n      const coords = extractCoordinates(item.GeoLocation);\n      latitude = coords.latitude;\n      longitude = coords.longitude;\n    } else if (item[locationColumn] && locationColumn !== 'locationID') {\n      // Use state and city names for geocoding if available\n      const state = possibleStateFields.find((field) => item[field]) || '';\n      const city = possibleCityFields.find((field) => item[field]) || '';\n      const locationQuery = `${city ? city + ', ' : ''}${state || item[locationColumn]}`;\n\n      const coords = await geocodeLocationWithRateLimit(locationQuery);\n      latitude = coords.latitude;\n      longitude = coords.longitude;\n    }\n\n    // Remove any existing latitude and longitude fields to avoid confusion\n    possibleLatitudeFields.forEach((field) => {\n      delete item[field];\n    });\n    possibleLongitudeFields.forEach((field) => {\n      delete item[field];\n    });\n\n    // Add the coordinates to the item\n    item.latitude = latitude;\n    item.longitude = longitude;\n\n    // Only include the item if it has valid coordinates\n    if (\n      latitude !== null &&\n      longitude !== null &&\n      !isNaN(latitude) &&\n      !isNaN(longitude)\n    ) {\n      dataWithCoords.push(item);\n    }\n\n    // Update progress\n    if (i % 100 === 0) {\n      const progressValue = 30 + Math.floor((i / cleanData.length) * 40); // 30% to 70%\n      setProgress((prev) => ({ ...prev, preprocess: progressValue }));\n      await delay(1); // Allow UI to update\n    }\n  }\n\n  console.log(\n    'Number of Data Points After Extracting Coordinates:',\n    dataWithCoords.length\n  );\n\n  if (dataWithCoords.length === 0) {\n    alert('No data available after extracting coordinates.');\n    return [];\n  }\n\n  setProgress((prev) => ({ ...prev, preprocess: 80 }));\n\n  // Final processing (if any)\n  // ...\n\n  setProgress((prev) => ({ ...prev, preprocess: 100 }));\n\n  return dataWithCoords;\n};\n\nexport default preprocessData;\n"],"mappings":"AAAA;;AAEA,OAAOA,KAAK,MAAM,OAAO;AACzB,SAASC,YAAY,QAAQ,aAAa;;AAE1C;AACA,MAAMC,KAAK,GAAIC,EAAE,IAAK,IAAIC,OAAO,CAAEC,OAAO,IAAKC,UAAU,CAACD,OAAO,EAAEF,EAAE,CAAC,CAAC;;AAEvE;AACA,MAAMI,YAAY,GAAG,CAAC,CAAC;;AAEvB;AACA,MAAMC,4BAA4B,GAAG,MAAAA,CAAOC,YAAY,EAAEC,OAAO,GAAG,GAAG,KAAK;EAC1E,IAAIH,YAAY,CAACE,YAAY,CAAC,EAAE;IAC9B,OAAOF,YAAY,CAACE,YAAY,CAAC;EACnC;EAEA,IAAI;IACF,MAAME,QAAQ,GAAG,MAAMX,KAAK,CAACY,GAAG,CAC9B,qDAAqDC,kBAAkB,CACrEJ,YACF,CAAC,OAAO,EACR;MACEK,MAAM,EAAE;QACNC,YAAY,EAAEd,YAAY;QAC1Be,KAAK,EAAE;MACT;IACF,CACF,CAAC;IAED,MAAMC,QAAQ,GAAGN,QAAQ,CAACO,IAAI,CAACD,QAAQ;IACvC,IAAIA,QAAQ,IAAIA,QAAQ,CAACE,MAAM,GAAG,CAAC,EAAE;MACnC,MAAM,CAACC,SAAS,EAAEC,QAAQ,CAAC,GAAGJ,QAAQ,CAAC,CAAC,CAAC,CAACK,MAAM;MAChD,MAAMC,MAAM,GAAG;QAAEF,QAAQ;QAAED;MAAU,CAAC;MACtCb,YAAY,CAACE,YAAY,CAAC,GAAGc,MAAM,CAAC,CAAC;MACrC,OAAOA,MAAM;IACf;EACF,CAAC,CAAC,OAAOC,KAAK,EAAE;IACd,IAAIA,KAAK,CAACb,QAAQ,IAAIa,KAAK,CAACb,QAAQ,CAACc,MAAM,KAAK,GAAG,EAAE;MACnDC,OAAO,CAACC,IAAI,CAAC,8CAA8C,CAAC;MAC5D,MAAMzB,KAAK,CAACQ,OAAO,CAAC;MACpB,OAAOF,4BAA4B,CAACC,YAAY,EAAEC,OAAO,GAAG,CAAC,CAAC,CAAC,CAAC;IAClE;IACAgB,OAAO,CAACF,KAAK,CAAC,kBAAkB,EAAEA,KAAK,CAAC;EAC1C;;EAEA;EACA,OAAO;IAAEH,QAAQ,EAAE,IAAI;IAAED,SAAS,EAAE;EAAK,CAAC;AAC5C,CAAC;;AAED;AACA,MAAMQ,kBAAkB,GAAIC,WAAW,IAAK;EAC1C,IAAI,CAACA,WAAW,EAAE,OAAO;IAAER,QAAQ,EAAE,IAAI;IAAED,SAAS,EAAE;EAAK,CAAC;EAC5D,MAAMU,KAAK,GAAG,0CAA0C;EACxD,MAAMC,KAAK,GAAGF,WAAW,CAACE,KAAK,CAACD,KAAK,CAAC;EACtC,IAAIC,KAAK,EAAE;IACT,OAAO;MACLX,SAAS,EAAEY,UAAU,CAACD,KAAK,CAAC,CAAC,CAAC,CAAC;MAC/BV,QAAQ,EAAEW,UAAU,CAACD,KAAK,CAAC,CAAC,CAAC;IAC/B,CAAC;EACH;EACA,OAAO;IAAEV,QAAQ,EAAE,IAAI;IAAED,SAAS,EAAE;EAAK,CAAC;AAC5C,CAAC;;AAED;AACA,MAAMa,cAAc,GAAG,MAAAA,CAAOf,IAAI,EAAEgB,WAAW,EAAEC,cAAc,KAAK;EAClE;EACAD,WAAW,CAAEE,IAAI,KAAM;IAAE,GAAGA,IAAI;IAAEC,UAAU,EAAE;EAAE,CAAC,CAAC,CAAC;;EAEnD;EACA,MAAMC,WAAW,GAAGpB,IAAI,CAACqB,KAAK,CAAC,CAAC,EAAE,MAAM,CAAC;EAEzCL,WAAW,CAAEE,IAAI,KAAM;IAAE,GAAGA,IAAI;IAAEC,UAAU,EAAE;EAAG,CAAC,CAAC,CAAC;;EAEpD;EACA,MAAMG,sBAAsB,GAAG,CAAC,UAAU,EAAE,UAAU,EAAE,KAAK,EAAE,KAAK,CAAC;EACrE,MAAMC,uBAAuB,GAAG,CAAC,WAAW,EAAE,WAAW,EAAE,KAAK,EAAE,KAAK,EAAE,MAAM,CAAC;EAChF,MAAMC,mBAAmB,GAAG,CAAC,OAAO,EAAE,YAAY,EAAE,UAAU,EAAE,YAAY,CAAC;EAC7E,MAAMC,kBAAkB,GAAG,CAAC,MAAM,EAAE,WAAW,EAAE,YAAY,CAAC;;EAE9D;EACA,IAAIC,aAAa,GAAG,IAAI;EACxB,IAAIC,cAAc,GAAG,IAAI;EAEzB,IAAIP,WAAW,CAACnB,MAAM,GAAG,CAAC,EAAE;IAC1ByB,aAAa,GAAGJ,sBAAsB,CAACM,IAAI,CAAEC,KAAK,IAChDT,WAAW,CAAC,CAAC,CAAC,CAACU,cAAc,CAACD,KAAK,CACrC,CAAC;IACDF,cAAc,GAAGJ,uBAAuB,CAACK,IAAI,CAAEC,KAAK,IAClDT,WAAW,CAAC,CAAC,CAAC,CAACU,cAAc,CAACD,KAAK,CACrC,CAAC;EACH,CAAC,MAAM;IACLE,KAAK,CAAC,uBAAuB,CAAC;IAC9B,OAAO,EAAE;EACX;EAEAf,WAAW,CAAEE,IAAI,KAAM;IAAE,GAAGA,IAAI;IAAEC,UAAU,EAAE;EAAG,CAAC,CAAC,CAAC;;EAEpD;EACA,IAAIa,iBAAiB,GAAG,KAAK;EAC7B,IAAI,CAACN,aAAa,IAAI,CAACC,cAAc,EAAE;IACrCK,iBAAiB,GAAG,IAAI;EAC1B;;EAEA;EACA,MAAMC,cAAc,GAAG,EAAE;EACzB,IAAID,iBAAiB,EAAE;IACrBC,cAAc,CAACC,IAAI,CAACjB,cAAc,CAAC;IACnC,MAAMkB,eAAe,GAAGX,mBAAmB,CAACI,IAAI,CAAEC,KAAK,IACrDT,WAAW,CAAC,CAAC,CAAC,CAACU,cAAc,CAACD,KAAK,CACrC,CAAC;IACD,IAAIM,eAAe,EAAEF,cAAc,CAACC,IAAI,CAACC,eAAe,CAAC;IAEzD,MAAMC,cAAc,GAAGX,kBAAkB,CAACG,IAAI,CAAEC,KAAK,IACnDT,WAAW,CAAC,CAAC,CAAC,CAACU,cAAc,CAACD,KAAK,CACrC,CAAC;IACD,IAAIO,cAAc,EAAEH,cAAc,CAACC,IAAI,CAACE,cAAc,CAAC;EACzD,CAAC,MAAM;IACLH,cAAc,CAACC,IAAI,CAACR,aAAa,EAAEC,cAAc,CAAC;EACpD;EAEA,MAAMU,SAAS,GAAGjB,WAAW,CAACkB,MAAM,CAAEC,GAAG,IAAK;IAC5C,OAAON,cAAc,CAACO,KAAK,CACxBX,KAAK,IACJU,GAAG,CAACT,cAAc,CAACD,KAAK,CAAC,IACzBU,GAAG,CAACV,KAAK,CAAC,KAAK,IAAI,IACnBU,GAAG,CAACV,KAAK,CAAC,KAAKY,SAAS,IACxBF,GAAG,CAACV,KAAK,CAAC,CAACa,QAAQ,CAAC,CAAC,CAACC,IAAI,CAAC,CAAC,KAAK,EACrC,CAAC;EACH,CAAC,CAAC;EAEFnC,OAAO,CAACoC,GAAG,CAAC,8BAA8B,EAAEP,SAAS,CAACpC,MAAM,CAAC;EAE7D,IAAIoC,SAAS,CAACpC,MAAM,KAAK,CAAC,EAAE;IAC1B8B,KAAK,CAAC,0EAA0E,CAAC;IACjF,OAAO,EAAE;EACX;EAEAf,WAAW,CAAEE,IAAI,KAAM;IAAE,GAAGA,IAAI;IAAEC,UAAU,EAAE;EAAG,CAAC,CAAC,CAAC;;EAEpD;EACA,IAAI,CAACO,aAAa,IAAI,CAACC,cAAc,EAAE;IACrC,IAAIU,SAAS,CAACpC,MAAM,GAAG,CAAC,EAAE;MACxByB,aAAa,GAAGJ,sBAAsB,CAACM,IAAI,CAAEC,KAAK,IAChDQ,SAAS,CAAC,CAAC,CAAC,CAACP,cAAc,CAACD,KAAK,CACnC,CAAC;MACDF,cAAc,GAAGJ,uBAAuB,CAACK,IAAI,CAAEC,KAAK,IAClDQ,SAAS,CAAC,CAAC,CAAC,CAACP,cAAc,CAACD,KAAK,CACnC,CAAC;IACH;EACF;;EAEA;EACA,MAAMgB,cAAc,GAAG,EAAE;EAEzB,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGT,SAAS,CAACpC,MAAM,EAAE6C,CAAC,EAAE,EAAE;IACzC,MAAMC,IAAI,GAAGV,SAAS,CAACS,CAAC,CAAC;IACzB,IAAI3C,QAAQ,GAAG,IAAI;IACnB,IAAID,SAAS,GAAG,IAAI;IAEpB,IAAIwB,aAAa,IAAIC,cAAc,EAAE;MACnCxB,QAAQ,GAAGW,UAAU,CAACiC,IAAI,CAACrB,aAAa,CAAC,CAAC;MAC1CxB,SAAS,GAAGY,UAAU,CAACiC,IAAI,CAACpB,cAAc,CAAC,CAAC;IAC9C,CAAC,MAAM,IAAIoB,IAAI,CAACC,WAAW,EAAE;MAC3B,MAAMC,MAAM,GAAGvC,kBAAkB,CAACqC,IAAI,CAACC,WAAW,CAAC;MACnD7C,QAAQ,GAAG8C,MAAM,CAAC9C,QAAQ;MAC1BD,SAAS,GAAG+C,MAAM,CAAC/C,SAAS;IAC9B,CAAC,MAAM,IAAI6C,IAAI,CAAC9B,cAAc,CAAC,IAAIA,cAAc,KAAK,YAAY,EAAE;MAClE;MACA,MAAMiC,KAAK,GAAG1B,mBAAmB,CAACI,IAAI,CAAEC,KAAK,IAAKkB,IAAI,CAAClB,KAAK,CAAC,CAAC,IAAI,EAAE;MACpE,MAAMsB,IAAI,GAAG1B,kBAAkB,CAACG,IAAI,CAAEC,KAAK,IAAKkB,IAAI,CAAClB,KAAK,CAAC,CAAC,IAAI,EAAE;MAClE,MAAMuB,aAAa,GAAG,GAAGD,IAAI,GAAGA,IAAI,GAAG,IAAI,GAAG,EAAE,GAAGD,KAAK,IAAIH,IAAI,CAAC9B,cAAc,CAAC,EAAE;MAElF,MAAMgC,MAAM,GAAG,MAAM3D,4BAA4B,CAAC8D,aAAa,CAAC;MAChEjD,QAAQ,GAAG8C,MAAM,CAAC9C,QAAQ;MAC1BD,SAAS,GAAG+C,MAAM,CAAC/C,SAAS;IAC9B;;IAEA;IACAoB,sBAAsB,CAAC+B,OAAO,CAAExB,KAAK,IAAK;MACxC,OAAOkB,IAAI,CAAClB,KAAK,CAAC;IACpB,CAAC,CAAC;IACFN,uBAAuB,CAAC8B,OAAO,CAAExB,KAAK,IAAK;MACzC,OAAOkB,IAAI,CAAClB,KAAK,CAAC;IACpB,CAAC,CAAC;;IAEF;IACAkB,IAAI,CAAC5C,QAAQ,GAAGA,QAAQ;IACxB4C,IAAI,CAAC7C,SAAS,GAAGA,SAAS;;IAE1B;IACA,IACEC,QAAQ,KAAK,IAAI,IACjBD,SAAS,KAAK,IAAI,IAClB,CAACoD,KAAK,CAACnD,QAAQ,CAAC,IAChB,CAACmD,KAAK,CAACpD,SAAS,CAAC,EACjB;MACA2C,cAAc,CAACX,IAAI,CAACa,IAAI,CAAC;IAC3B;;IAEA;IACA,IAAID,CAAC,GAAG,GAAG,KAAK,CAAC,EAAE;MACjB,MAAMS,aAAa,GAAG,EAAE,GAAGC,IAAI,CAACC,KAAK,CAAEX,CAAC,GAAGT,SAAS,CAACpC,MAAM,GAAI,EAAE,CAAC,CAAC,CAAC;MACpEe,WAAW,CAAEE,IAAI,KAAM;QAAE,GAAGA,IAAI;QAAEC,UAAU,EAAEoC;MAAc,CAAC,CAAC,CAAC;MAC/D,MAAMvE,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC;IAClB;EACF;EAEAwB,OAAO,CAACoC,GAAG,CACT,qDAAqD,EACrDC,cAAc,CAAC5C,MACjB,CAAC;EAED,IAAI4C,cAAc,CAAC5C,MAAM,KAAK,CAAC,EAAE;IAC/B8B,KAAK,CAAC,iDAAiD,CAAC;IACxD,OAAO,EAAE;EACX;EAEAf,WAAW,CAAEE,IAAI,KAAM;IAAE,GAAGA,IAAI;IAAEC,UAAU,EAAE;EAAG,CAAC,CAAC,CAAC;;EAEpD;EACA;;EAEAH,WAAW,CAAEE,IAAI,KAAM;IAAE,GAAGA,IAAI;IAAEC,UAAU,EAAE;EAAI,CAAC,CAAC,CAAC;EAErD,OAAO0B,cAAc;AACvB,CAAC;AAED,eAAe9B,cAAc","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}
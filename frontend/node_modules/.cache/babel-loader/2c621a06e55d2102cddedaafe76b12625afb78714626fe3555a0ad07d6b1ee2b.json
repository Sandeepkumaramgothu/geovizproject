{"ast":null,"code":"// src/components/preprocessData.js\n\nimport axios from 'axios';\nimport { MAPBOX_TOKEN } from './constants';\nconst geocodeLocation = async locationName => {\n  if (!locationName) return {\n    latitude: null,\n    longitude: null\n  };\n  try {\n    const response = await axios.get(`https://api.mapbox.com/geocoding/v5/mapbox.places/${encodeURIComponent(locationName)}.json`, {\n      params: {\n        access_token: MAPBOX_TOKEN,\n        limit: 1\n      }\n    });\n    const features = response.data.features;\n    if (features && features.length > 0) {\n      const [longitude, latitude] = features[0].center;\n      return {\n        latitude,\n        longitude\n      };\n    }\n    return {\n      latitude: null,\n      longitude: null\n    };\n  } catch (error) {\n    console.error('Geocoding error:', error);\n    return {\n      latitude: null,\n      longitude: null\n    };\n  }\n};\n\n//Main preprocess\nconst preprocessData = async (data, setProgress) => {\n  setProgress(prev => ({\n    ...prev,\n    preprocess: 0\n  }));\n  const limitedData = data.slice(0, 100000);\n  setProgress(prev => ({\n    ...prev,\n    preprocess: 10\n  }));\n\n  // Define possible column names for latitude and longitude\n  const possibleLatitudeFields = ['latitude', 'Latitude', 'lat', 'Lat', 'LATITUDE', 'LAT'];\n  const possibleLongitudeFields = ['longitude', 'Longitude', 'lon', 'Lng', 'Long', 'LONGITUDE', 'LNG', 'LON'];\n\n  // Define possible location fields\n  const possibleLocationFields = ['city', 'City', 'CITY', 'county', 'County', 'COUNTY', 'state', 'State', 'STATE', 'state_name', 'State_Name', 'STATE_NAME'];\n\n  // Map dataset columns to standard names\n  const firstRow = limitedData[0];\n\n  // Map latitude field\n  let latitudeField = possibleLatitudeFields.find(field => field in firstRow);\n  // Map longitude field\n  let longitudeField = possibleLongitudeFields.find(field => field in firstRow);\n  // Map location field\n  let locationField = possibleLocationFields.find(field => field in firstRow);\n  setProgress(prev => ({\n    ...prev,\n    preprocess: 20\n  }));\n  const requiredFields = [];\n  if (!latitudeField || !longitudeField) {\n    if (locationField) {\n      requiredFields.push(locationField);\n    }\n  }\n  const cleanData = limitedData.filter(row => {\n    if (requiredFields.length > 0) {\n      return requiredFields.every(field => row.hasOwnProperty(field) && row[field] !== null && row[field] !== undefined && row[field].toString().trim() !== '');\n    } else {\n      return row !== null && row !== undefined && Object.keys(row).length > 0;\n    }\n  });\n  if (cleanData.length === 0) {\n    alert('No data available after filtering out rows with missing critical fields.');\n    return [];\n  }\n  setProgress(prev => ({\n    ...prev,\n    preprocess: 30\n  }));\n  let dataWithCoords;\n  if (latitudeField && longitudeField) {\n    // We have latitude and longitude, no need to geocode\n    dataWithCoords = cleanData.map(item => {\n      const latitude = parseFloat(item[latitudeField]);\n      const longitude = parseFloat(item[longitudeField]);\n\n      // Remove any existing latitude and longitude fields to avoid confusion\n      possibleLatitudeFields.forEach(field => {\n        delete item[field];\n      });\n      possibleLongitudeFields.forEach(field => {\n        delete item[field];\n      });\n      return {\n        ...item,\n        latitude,\n        longitude\n      };\n    });\n  } else if (locationField) {\n    // We need to geocode the location names to get coordinates\n    dataWithCoords = await Promise.all(cleanData.map(async item => {\n      let latitude = null;\n      let longitude = null;\n      let locationName = item[locationField];\n      const coords = await geocodeLocation(locationName);\n      latitude = coords.latitude;\n      longitude = coords.longitude;\n\n      // Remove any existing latitude and longitude fields to avoid confusion\n      possibleLatitudeFields.forEach(field => {\n        delete item[field];\n      });\n      possibleLongitudeFields.forEach(field => {\n        delete item[field];\n      });\n      return {\n        ...item,\n        latitude,\n        longitude\n      };\n    }));\n  } else {\n    // No location data, proceed without coordinates\n    dataWithCoords = cleanData;\n  }\n  setProgress(prev => ({\n    ...prev,\n    preprocess: 70\n  }));\n\n  // Proceed to extract numeric and string headers even without location data\n\n  setProgress(prev => ({\n    ...prev,\n    preprocess: 90\n  }));\n  setProgress(prev => ({\n    ...prev,\n    preprocess: 100\n  }));\n  return dataWithCoords;\n};\nexport default preprocessData;","map":{"version":3,"names":["axios","MAPBOX_TOKEN","geocodeLocation","locationName","latitude","longitude","response","get","encodeURIComponent","params","access_token","limit","features","data","length","center","error","console","preprocessData","setProgress","prev","preprocess","limitedData","slice","possibleLatitudeFields","possibleLongitudeFields","possibleLocationFields","firstRow","latitudeField","find","field","longitudeField","locationField","requiredFields","push","cleanData","filter","row","every","hasOwnProperty","undefined","toString","trim","Object","keys","alert","dataWithCoords","map","item","parseFloat","forEach","Promise","all","coords"],"sources":["/Users/girishkumarpatchikoru/Desktop/projecthci/geovizproject/frontend/src/components/preprocessData.js"],"sourcesContent":["// src/components/preprocessData.js\n\nimport axios from 'axios';\nimport { MAPBOX_TOKEN } from './constants';\n\nconst geocodeLocation = async (locationName) => {\n  if (!locationName) return { latitude: null, longitude: null };\n  try {\n    const response = await axios.get(\n      `https://api.mapbox.com/geocoding/v5/mapbox.places/${encodeURIComponent(\n        locationName\n      )}.json`,\n      {\n        params: {\n          access_token: MAPBOX_TOKEN,\n          limit: 1,\n        },\n      }\n    );\n    const features = response.data.features;\n    if (features && features.length > 0) {\n      const [longitude, latitude] = features[0].center;\n      return { latitude, longitude };\n    }\n    return { latitude: null, longitude: null };\n  } catch (error) {\n    console.error('Geocoding error:', error);\n    return { latitude: null, longitude: null };\n  }\n};\n\n//Main preprocess\nconst preprocessData = async (data, setProgress) => {\n  setProgress((prev) => ({ ...prev, preprocess: 0 }));\n\n  const limitedData = data.slice(0, 100000); \n\n  setProgress((prev) => ({ ...prev, preprocess: 10 }));\n\n  // Define possible column names for latitude and longitude\n  const possibleLatitudeFields = ['latitude', 'Latitude', 'lat', 'Lat', 'LATITUDE', 'LAT'];\n  const possibleLongitudeFields = ['longitude', 'Longitude', 'lon', 'Lng', 'Long', 'LONGITUDE', 'LNG', 'LON'];\n\n  // Define possible location fields\n  const possibleLocationFields = [\n    'city',\n    'City',\n    'CITY',\n    'county',\n    'County',\n    'COUNTY',\n    'state',\n    'State',\n    'STATE',\n    'state_name',\n    'State_Name',\n    'STATE_NAME',\n  ];\n\n  // Map dataset columns to standard names\n  const firstRow = limitedData[0];\n\n  // Map latitude field\n  let latitudeField = possibleLatitudeFields.find((field) => field in firstRow);\n  // Map longitude field\n  let longitudeField = possibleLongitudeFields.find((field) => field in firstRow);\n  // Map location field\n  let locationField = possibleLocationFields.find((field) => field in firstRow);\n\n  setProgress((prev) => ({ ...prev, preprocess: 20 }));\n\n  const requiredFields = [];\n  if (!latitudeField || !longitudeField) {\n    if (locationField) {\n      requiredFields.push(locationField);\n    }\n  }\n\n  const cleanData = limitedData.filter((row) => {\n    if (requiredFields.length > 0) {\n      return requiredFields.every(\n        (field) =>\n          row.hasOwnProperty(field) &&\n          row[field] !== null &&\n          row[field] !== undefined &&\n          row[field].toString().trim() !== ''\n      );\n    } else {\n      return row !== null && row !== undefined && Object.keys(row).length > 0;\n    }\n  });\n\n  if (cleanData.length === 0) {\n    alert('No data available after filtering out rows with missing critical fields.');\n    return [];\n  }\n\n  setProgress((prev) => ({ ...prev, preprocess: 30 }));\n\n  let dataWithCoords;\n\n  if (latitudeField && longitudeField) {\n    // We have latitude and longitude, no need to geocode\n    dataWithCoords = cleanData.map((item) => {\n      const latitude = parseFloat(item[latitudeField]);\n      const longitude = parseFloat(item[longitudeField]);\n\n      // Remove any existing latitude and longitude fields to avoid confusion\n      possibleLatitudeFields.forEach((field) => {\n        delete item[field];\n      });\n      possibleLongitudeFields.forEach((field) => {\n        delete item[field];\n      });\n\n      return { ...item, latitude, longitude };\n    });\n  } else if (locationField) {\n    // We need to geocode the location names to get coordinates\n    dataWithCoords = await Promise.all(\n      cleanData.map(async (item) => {\n        let latitude = null;\n        let longitude = null;\n        let locationName = item[locationField];\n\n        const coords = await geocodeLocation(locationName);\n        latitude = coords.latitude;\n        longitude = coords.longitude;\n\n        // Remove any existing latitude and longitude fields to avoid confusion\n        possibleLatitudeFields.forEach((field) => {\n          delete item[field];\n        });\n        possibleLongitudeFields.forEach((field) => {\n          delete item[field];\n        });\n\n        return { ...item, latitude, longitude };\n      })\n    );\n  } else {\n    // No location data, proceed without coordinates\n    dataWithCoords = cleanData;\n  }\n\n  setProgress((prev) => ({ ...prev, preprocess: 70 }));\n\n  // Proceed to extract numeric and string headers even without location data\n\n  setProgress((prev) => ({ ...prev, preprocess: 90 }));\n\n  setProgress((prev) => ({ ...prev, preprocess: 100 }));\n\n  return dataWithCoords;\n};\n\nexport default preprocessData;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}
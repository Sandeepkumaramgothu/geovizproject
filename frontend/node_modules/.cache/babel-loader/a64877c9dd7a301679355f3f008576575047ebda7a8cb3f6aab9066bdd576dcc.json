{"ast":null,"code":"// src/components/UsDataPreprocessor.js\n\nimport axios from 'axios';\nimport { MAPBOX_TOKEN } from './constants';\n\n// US States validation data\nconst US_STATES = {\n  AL: 'Alabama',\n  AK: 'Alaska',\n  AZ: 'Arizona',\n  AR: 'Arkansas',\n  CA: 'California',\n  CO: 'Colorado',\n  CT: 'Connecticut',\n  DE: 'Delaware',\n  FL: 'Florida',\n  GA: 'Georgia',\n  HI: 'Hawaii',\n  ID: 'Idaho',\n  IL: 'Illinois',\n  IN: 'Indiana',\n  IA: 'Iowa',\n  KS: 'Kansas',\n  KY: 'Kentucky',\n  LA: 'Louisiana',\n  ME: 'Maine',\n  MD: 'Maryland',\n  MA: 'Massachusetts',\n  MI: 'Michigan',\n  MN: 'Minnesota',\n  MS: 'Mississippi',\n  MO: 'Missouri',\n  MT: 'Montana',\n  NE: 'Nebraska',\n  NV: 'Nevada',\n  NH: 'New Hampshire',\n  NJ: 'New Jersey',\n  NM: 'New Mexico',\n  NY: 'New York',\n  NC: 'North Carolina',\n  ND: 'North Dakota',\n  OH: 'Ohio',\n  OK: 'Oklahoma',\n  OR: 'Oregon',\n  PA: 'Pennsylvania',\n  RI: 'Rhode Island',\n  SC: 'South Carolina',\n  SD: 'South Dakota',\n  TN: 'Tennessee',\n  TX: 'Texas',\n  UT: 'Utah',\n  VT: 'Vermont',\n  VA: 'Virginia',\n  WA: 'Washington',\n  WV: 'West Virginia',\n  WI: 'Wisconsin',\n  WY: 'Wyoming',\n  DC: 'District of Columbia'\n};\n\n// Reverse lookup for state names to codes\nconst STATE_NAMES_TO_CODES = Object.entries(US_STATES).reduce(_c = (acc, [code, name]) => {\n  acc[name.toLowerCase()] = code;\n  return acc;\n}, {});\n\n// Column pattern recognition\n_c2 = STATE_NAMES_TO_CODES;\nconst COLUMN_PATTERNS = {\n  state: {\n    patterns: ['state', 'state_name', 'state_id', 'state_code', 'st'],\n    variants: ['', '_', 'name', 'code', 'id'],\n    cases: ['lower', 'upper', 'title']\n  },\n  city: {\n    patterns: ['city', 'city_name', 'city_ascii', 'place'],\n    variants: ['', '_', 'name', 'ascii'],\n    cases: ['lower', 'upper', 'title']\n  },\n  latitude: {\n    patterns: ['latitude', 'lat', 'y'],\n    variants: ['', '_'],\n    cases: ['lower', 'upper', 'title']\n  },\n  longitude: {\n    patterns: ['longitude', 'long', 'lng', 'lon', 'x'],\n    variants: ['', '_'],\n    cases: ['lower', 'upper', 'title']\n  },\n  population: {\n    patterns: ['population', 'pop', 'total_population'],\n    variants: ['', '_', 'total'],\n    cases: ['lower', 'upper', 'title']\n  },\n  county: {\n    patterns: ['county', 'county_name', 'county_ascii'],\n    variants: ['', '_', 'name', 'ascii'],\n    cases: ['lower', 'upper', 'title']\n  }\n};\nclass GeocodeCache {\n  constructor(ttlHours = 24) {\n    this.cache = new Map();\n    this.ttl = ttlHours * 60 * 60 * 1000;\n  }\n  get(key) {\n    const item = this.cache.get(key);\n    if (!item) return null;\n    if (Date.now() > item.expires) {\n      this.cache.delete(key);\n      return null;\n    }\n    return item.value;\n  }\n  set(key, value) {\n    this.cache.set(key, {\n      value,\n      expires: Date.now() + this.ttl\n    });\n  }\n}\nclass UsDataPreprocessor {\n  constructor(config = {}) {\n    this.config = {\n      maxRows: 100000,\n      batchSize: 100,\n      geocodingRetryDelay: 200,\n      maxRetries: 3,\n      progressInterval: 100,\n      ...config\n    };\n    this.geocodeCache = new GeocodeCache();\n  }\n  generateColumnVariants(pattern) {\n    const variants = [];\n    COLUMN_PATTERNS[pattern].patterns.forEach(base => {\n      COLUMN_PATTERNS[pattern].variants.forEach(variant => {\n        COLUMN_PATTERNS[pattern].cases.forEach(case_ => {\n          let columnName = base + variant;\n          if (case_ === 'upper') columnName = columnName.toUpperCase();else if (case_ === 'title') columnName = columnName.charAt(0).toUpperCase() + columnName.slice(1);\n          variants.push(columnName);\n        });\n      });\n    });\n    return variants;\n  }\n  findColumnByPattern(headers, pattern) {\n    const variants = this.generateColumnVariants(pattern);\n    return headers.find(header => variants.includes(header));\n  }\n  validateStateCode(stateCode) {\n    if (!stateCode) return null;\n    const code = stateCode.toUpperCase();\n    return US_STATES[code] ? code : null;\n  }\n  validateStateName(stateName) {\n    if (!stateName) return null;\n    const name = stateName.toLowerCase();\n    return STATE_NAMES_TO_CODES[name] || null;\n  }\n  async geocodeLocation(location, retryCount = 0) {\n    const cached = this.geocodeCache.get(location);\n    if (cached) return cached;\n    try {\n      const response = await axios.get(`https://api.mapbox.com/geocoding/v5/mapbox.places/${encodeURIComponent(location)}.json`, {\n        params: {\n          access_token: MAPBOX_TOKEN,\n          limit: 1,\n          types: 'place,region',\n          country: 'US'\n        }\n      });\n      const features = response.data.features;\n      if ((features === null || features === void 0 ? void 0 : features.length) > 0) {\n        const [longitude, latitude] = features[0].center;\n        const result = {\n          latitude,\n          longitude\n        };\n        this.geocodeCache.set(location, result);\n        return result;\n      }\n    } catch (error) {\n      var _error$response, _error$response2;\n      console.error(`Geocoding error for \"${location}\":`, error.message);\n      if (retryCount < this.config.maxRetries && (((_error$response = error.response) === null || _error$response === void 0 ? void 0 : _error$response.status) === 429 || ((_error$response2 = error.response) === null || _error$response2 === void 0 ? void 0 : _error$response2.status) >= 500)) {\n        await new Promise(resolve => setTimeout(resolve, this.config.geocodingRetryDelay * Math.pow(2, retryCount)));\n        return this.geocodeLocation(location, retryCount + 1);\n      }\n    }\n    return {\n      latitude: null,\n      longitude: null\n    };\n  }\n  async process(data, setProgress) {\n    try {\n      setProgress === null || setProgress === void 0 ? void 0 : setProgress(prev => ({\n        ...prev,\n        preprocess: 0\n      }));\n      if (!Array.isArray(data) || data.length === 0) {\n        throw new Error('Input data must be a non-empty array');\n      }\n\n      // Limit data size\n      const limitedData = data.slice(0, this.config.maxRows);\n      setProgress === null || setProgress === void 0 ? void 0 : setProgress(prev => ({\n        ...prev,\n        preprocess: 10\n      }));\n\n      // Detect columns\n      const headers = Object.keys(limitedData[0]);\n      const columns = {\n        state: this.findColumnByPattern(headers, 'state'),\n        city: this.findColumnByPattern(headers, 'city'),\n        latitude: this.findColumnByPattern(headers, 'latitude'),\n        longitude: this.findColumnByPattern(headers, 'longitude'),\n        population: this.findColumnByPattern(headers, 'population'),\n        county: this.findColumnByPattern(headers, 'county')\n      };\n      console.log('Detected columns:', columns);\n      setProgress === null || setProgress === void 0 ? void 0 : setProgress(prev => ({\n        ...prev,\n        preprocess: 20\n      }));\n      const processedData = [];\n      let lastProgressUpdate = Date.now();\n      for (let i = 0; i < limitedData.length; i++) {\n        const item = {\n          ...limitedData[i]\n        };\n        let coordinates = {\n          latitude: null,\n          longitude: null\n        };\n        let stateCode = null;\n\n        // Try to get state code\n        if (columns.state) {\n          stateCode = this.validateStateCode(item[columns.state]) || this.validateStateName(item[columns.state]);\n        }\n\n        // Get coordinates\n        if (columns.latitude && columns.longitude) {\n          coordinates = {\n            latitude: parseFloat(item[columns.latitude]),\n            longitude: parseFloat(item[columns.longitude])\n          };\n        } else if (stateCode && columns.city) {\n          const locationQuery = `${item[columns.city]}, ${US_STATES[stateCode]}`;\n          coordinates = await this.geocodeLocation(locationQuery);\n        } else if (stateCode) {\n          const locationQuery = US_STATES[stateCode];\n          coordinates = await this.geocodeLocation(locationQuery);\n        }\n\n        // Validate coordinates\n        if (coordinates.latitude != null && coordinates.longitude != null && !isNaN(coordinates.latitude) && !isNaN(coordinates.longitude) && coordinates.latitude >= 24 && coordinates.latitude <= 72 &&\n        // US latitude range\n        coordinates.longitude >= -180 && coordinates.longitude <= -66) {\n          // US longitude range\n\n          // Standardize the output\n          const processedItem = {\n            ...item,\n            state_code: stateCode,\n            state_name: stateCode ? US_STATES[stateCode] : null,\n            latitude: coordinates.latitude,\n            longitude: coordinates.longitude\n          };\n\n          // Clean up old fields\n          this.generateColumnVariants('state').forEach(field => delete processedItem[field]);\n          this.generateColumnVariants('latitude').forEach(field => delete processedItem[field]);\n          this.generateColumnVariants('longitude').forEach(field => delete processedItem[field]);\n          processedData.push(processedItem);\n        }\n\n        // Update progress\n        const now = Date.now();\n        if (now - lastProgressUpdate > this.config.progressInterval) {\n          const progress = 20 + Math.floor(i / limitedData.length * 70);\n          setProgress === null || setProgress === void 0 ? void 0 : setProgress(prev => ({\n            ...prev,\n            preprocess: progress\n          }));\n          lastProgressUpdate = now;\n          await new Promise(resolve => setTimeout(resolve, 1));\n        }\n      }\n      if (processedData.length === 0) {\n        throw new Error('No valid data points after processing');\n      }\n      setProgress === null || setProgress === void 0 ? void 0 : setProgress(prev => ({\n        ...prev,\n        preprocess: 100\n      }));\n      return processedData;\n    } catch (error) {\n      console.error('Preprocessing failed:', error);\n      setProgress === null || setProgress === void 0 ? void 0 : setProgress(prev => ({\n        ...prev,\n        preprocess: 0\n      }));\n      throw error;\n    }\n  }\n}\nexport default UsDataPreprocessor;\nvar _c, _c2;\n$RefreshReg$(_c, \"STATE_NAMES_TO_CODES$Object.entries(US_STATES).reduce\");\n$RefreshReg$(_c2, \"STATE_NAMES_TO_CODES\");","map":{"version":3,"names":["axios","MAPBOX_TOKEN","US_STATES","AL","AK","AZ","AR","CA","CO","CT","DE","FL","GA","HI","ID","IL","IN","IA","KS","KY","LA","ME","MD","MA","MI","MN","MS","MO","MT","NE","NV","NH","NJ","NM","NY","NC","ND","OH","OK","OR","PA","RI","SC","SD","TN","TX","UT","VT","VA","WA","WV","WI","WY","DC","STATE_NAMES_TO_CODES","Object","entries","reduce","_c","acc","code","name","toLowerCase","_c2","COLUMN_PATTERNS","state","patterns","variants","cases","city","latitude","longitude","population","county","GeocodeCache","constructor","ttlHours","cache","Map","ttl","get","key","item","Date","now","expires","delete","value","set","UsDataPreprocessor","config","maxRows","batchSize","geocodingRetryDelay","maxRetries","progressInterval","geocodeCache","generateColumnVariants","pattern","forEach","base","variant","case_","columnName","toUpperCase","charAt","slice","push","findColumnByPattern","headers","find","header","includes","validateStateCode","stateCode","validateStateName","stateName","geocodeLocation","location","retryCount","cached","response","encodeURIComponent","params","access_token","limit","types","country","features","data","length","center","result","error","_error$response","_error$response2","console","message","status","Promise","resolve","setTimeout","Math","pow","process","setProgress","prev","preprocess","Array","isArray","Error","limitedData","keys","columns","log","processedData","lastProgressUpdate","i","coordinates","parseFloat","locationQuery","isNaN","processedItem","state_code","state_name","field","progress","floor","$RefreshReg$"],"sources":["/Users/girishkumarpatchikoru/Desktop/projecthci/geovizproject/frontend/src/components/preprocessData.js"],"sourcesContent":["// src/components/UsDataPreprocessor.js\n\nimport axios from 'axios';\nimport { MAPBOX_TOKEN } from './constants';\n\n// US States validation data\nconst US_STATES = {\n  AL: 'Alabama', AK: 'Alaska', AZ: 'Arizona', AR: 'Arkansas', CA: 'California',\n  CO: 'Colorado', CT: 'Connecticut', DE: 'Delaware', FL: 'Florida', GA: 'Georgia',\n  HI: 'Hawaii', ID: 'Idaho', IL: 'Illinois', IN: 'Indiana', IA: 'Iowa',\n  KS: 'Kansas', KY: 'Kentucky', LA: 'Louisiana', ME: 'Maine', MD: 'Maryland',\n  MA: 'Massachusetts', MI: 'Michigan', MN: 'Minnesota', MS: 'Mississippi', MO: 'Missouri',\n  MT: 'Montana', NE: 'Nebraska', NV: 'Nevada', NH: 'New Hampshire', NJ: 'New Jersey',\n  NM: 'New Mexico', NY: 'New York', NC: 'North Carolina', ND: 'North Dakota', OH: 'Ohio',\n  OK: 'Oklahoma', OR: 'Oregon', PA: 'Pennsylvania', RI: 'Rhode Island', SC: 'South Carolina',\n  SD: 'South Dakota', TN: 'Tennessee', TX: 'Texas', UT: 'Utah', VT: 'Vermont',\n  VA: 'Virginia', WA: 'Washington', WV: 'West Virginia', WI: 'Wisconsin', WY: 'Wyoming',\n  DC: 'District of Columbia'\n};\n\n// Reverse lookup for state names to codes\nconst STATE_NAMES_TO_CODES = Object.entries(US_STATES).reduce((acc, [code, name]) => {\n  acc[name.toLowerCase()] = code;\n  return acc;\n}, {});\n\n// Column pattern recognition\nconst COLUMN_PATTERNS = {\n  state: {\n    patterns: ['state', 'state_name', 'state_id', 'state_code', 'st'],\n    variants: ['', '_', 'name', 'code', 'id'],\n    cases: ['lower', 'upper', 'title']\n  },\n  city: {\n    patterns: ['city', 'city_name', 'city_ascii', 'place'],\n    variants: ['', '_', 'name', 'ascii'],\n    cases: ['lower', 'upper', 'title']\n  },\n  latitude: {\n    patterns: ['latitude', 'lat', 'y'],\n    variants: ['', '_'],\n    cases: ['lower', 'upper', 'title']\n  },\n  longitude: {\n    patterns: ['longitude', 'long', 'lng', 'lon', 'x'],\n    variants: ['', '_'],\n    cases: ['lower', 'upper', 'title']\n  },\n  population: {\n    patterns: ['population', 'pop', 'total_population'],\n    variants: ['', '_', 'total'],\n    cases: ['lower', 'upper', 'title']\n  },\n  county: {\n    patterns: ['county', 'county_name', 'county_ascii'],\n    variants: ['', '_', 'name', 'ascii'],\n    cases: ['lower', 'upper', 'title']\n  }\n};\n\nclass GeocodeCache {\n  constructor(ttlHours = 24) {\n    this.cache = new Map();\n    this.ttl = ttlHours * 60 * 60 * 1000;\n  }\n\n  get(key) {\n    const item = this.cache.get(key);\n    if (!item) return null;\n    if (Date.now() > item.expires) {\n      this.cache.delete(key);\n      return null;\n    }\n    return item.value;\n  }\n\n  set(key, value) {\n    this.cache.set(key, {\n      value,\n      expires: Date.now() + this.ttl\n    });\n  }\n}\n\nclass UsDataPreprocessor {\n  constructor(config = {}) {\n    this.config = {\n      maxRows: 100000,\n      batchSize: 100,\n      geocodingRetryDelay: 200,\n      maxRetries: 3,\n      progressInterval: 100,\n      ...config\n    };\n\n    this.geocodeCache = new GeocodeCache();\n  }\n\n  generateColumnVariants(pattern) {\n    const variants = [];\n    COLUMN_PATTERNS[pattern].patterns.forEach(base => {\n      COLUMN_PATTERNS[pattern].variants.forEach(variant => {\n        COLUMN_PATTERNS[pattern].cases.forEach(case_ => {\n          let columnName = base + variant;\n          if (case_ === 'upper') columnName = columnName.toUpperCase();\n          else if (case_ === 'title') columnName = columnName.charAt(0).toUpperCase() + columnName.slice(1);\n          variants.push(columnName);\n        });\n      });\n    });\n    return variants;\n  }\n\n  findColumnByPattern(headers, pattern) {\n    const variants = this.generateColumnVariants(pattern);\n    return headers.find(header => variants.includes(header));\n  }\n\n  validateStateCode(stateCode) {\n    if (!stateCode) return null;\n    const code = stateCode.toUpperCase();\n    return US_STATES[code] ? code : null;\n  }\n\n  validateStateName(stateName) {\n    if (!stateName) return null;\n    const name = stateName.toLowerCase();\n    return STATE_NAMES_TO_CODES[name] || null;\n  }\n\n  async geocodeLocation(location, retryCount = 0) {\n    const cached = this.geocodeCache.get(location);\n    if (cached) return cached;\n\n    try {\n      const response = await axios.get(\n        `https://api.mapbox.com/geocoding/v5/mapbox.places/${encodeURIComponent(location)}.json`,\n        {\n          params: {\n            access_token: MAPBOX_TOKEN,\n            limit: 1,\n            types: 'place,region',\n            country: 'US'\n          }\n        }\n      );\n\n      const features = response.data.features;\n      if (features?.length > 0) {\n        const [longitude, latitude] = features[0].center;\n        const result = { latitude, longitude };\n        this.geocodeCache.set(location, result);\n        return result;\n      }\n    } catch (error) {\n      console.error(`Geocoding error for \"${location}\":`, error.message);\n      \n      if (retryCount < this.config.maxRetries && \n          (error.response?.status === 429 || error.response?.status >= 500)) {\n        await new Promise(resolve => setTimeout(resolve, \n          this.config.geocodingRetryDelay * Math.pow(2, retryCount)));\n        return this.geocodeLocation(location, retryCount + 1);\n      }\n    }\n\n    return { latitude: null, longitude: null };\n  }\n\n  async process(data, setProgress) {\n    try {\n      setProgress?.((prev) => ({ ...prev, preprocess: 0 }));\n\n      if (!Array.isArray(data) || data.length === 0) {\n        throw new Error('Input data must be a non-empty array');\n      }\n\n      // Limit data size\n      const limitedData = data.slice(0, this.config.maxRows);\n      setProgress?.((prev) => ({ ...prev, preprocess: 10 }));\n\n      // Detect columns\n      const headers = Object.keys(limitedData[0]);\n      const columns = {\n        state: this.findColumnByPattern(headers, 'state'),\n        city: this.findColumnByPattern(headers, 'city'),\n        latitude: this.findColumnByPattern(headers, 'latitude'),\n        longitude: this.findColumnByPattern(headers, 'longitude'),\n        population: this.findColumnByPattern(headers, 'population'),\n        county: this.findColumnByPattern(headers, 'county')\n      };\n\n      console.log('Detected columns:', columns);\n      setProgress?.((prev) => ({ ...prev, preprocess: 20 }));\n\n      const processedData = [];\n      let lastProgressUpdate = Date.now();\n\n      for (let i = 0; i < limitedData.length; i++) {\n        const item = { ...limitedData[i] };\n        let coordinates = { latitude: null, longitude: null };\n        let stateCode = null;\n\n        // Try to get state code\n        if (columns.state) {\n          stateCode = this.validateStateCode(item[columns.state]) || \n                     this.validateStateName(item[columns.state]);\n        }\n\n        // Get coordinates\n        if (columns.latitude && columns.longitude) {\n          coordinates = {\n            latitude: parseFloat(item[columns.latitude]),\n            longitude: parseFloat(item[columns.longitude])\n          };\n        } else if (stateCode && columns.city) {\n          const locationQuery = `${item[columns.city]}, ${US_STATES[stateCode]}`;\n          coordinates = await this.geocodeLocation(locationQuery);\n        } else if (stateCode) {\n          const locationQuery = US_STATES[stateCode];\n          coordinates = await this.geocodeLocation(locationQuery);\n        }\n\n        // Validate coordinates\n        if (coordinates.latitude != null && \n            coordinates.longitude != null && \n            !isNaN(coordinates.latitude) && \n            !isNaN(coordinates.longitude) &&\n            coordinates.latitude >= 24 && \n            coordinates.latitude <= 72 && // US latitude range\n            coordinates.longitude >= -180 && \n            coordinates.longitude <= -66) { // US longitude range\n\n          // Standardize the output\n          const processedItem = {\n            ...item,\n            state_code: stateCode,\n            state_name: stateCode ? US_STATES[stateCode] : null,\n            latitude: coordinates.latitude,\n            longitude: coordinates.longitude\n          };\n\n          // Clean up old fields\n          this.generateColumnVariants('state').forEach(field => delete processedItem[field]);\n          this.generateColumnVariants('latitude').forEach(field => delete processedItem[field]);\n          this.generateColumnVariants('longitude').forEach(field => delete processedItem[field]);\n\n          processedData.push(processedItem);\n        }\n\n        // Update progress\n        const now = Date.now();\n        if (now - lastProgressUpdate > this.config.progressInterval) {\n          const progress = 20 + Math.floor((i / limitedData.length) * 70);\n          setProgress?.((prev) => ({ ...prev, preprocess: progress }));\n          lastProgressUpdate = now;\n          await new Promise(resolve => setTimeout(resolve, 1));\n        }\n      }\n\n      if (processedData.length === 0) {\n        throw new Error('No valid data points after processing');\n      }\n\n      setProgress?.((prev) => ({ ...prev, preprocess: 100 }));\n      return processedData;\n\n    } catch (error) {\n      console.error('Preprocessing failed:', error);\n      setProgress?.((prev) => ({ ...prev, preprocess: 0 }));\n      throw error;\n    }\n  }\n}\n\nexport default UsDataPreprocessor;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}
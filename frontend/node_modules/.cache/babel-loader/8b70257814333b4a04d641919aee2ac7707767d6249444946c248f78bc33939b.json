{"ast":null,"code":"// src/components/preprocessData.js\n\nimport axios from 'axios';\nimport { MAPBOX_TOKEN } from './constants';\n\n// Function to introduce a delay (in milliseconds)\nconst delay = ms => new Promise(resolve => setTimeout(resolve, ms));\n\n// Cache object to store geocoding results and avoid duplicate API calls\nconst geocodeCache = {};\n\n// Function to handle geocoding with rate-limiting and caching\nconst geocodeLocationWithRateLimit = async (locationName, delayMs = 200) => {\n  if (geocodeCache[locationName]) {\n    return geocodeCache[locationName];\n  }\n  try {\n    const response = await axios.get(`https://api.mapbox.com/geocoding/v5/mapbox.places/${encodeURIComponent(locationName)}.json`, {\n      params: {\n        access_token: MAPBOX_TOKEN,\n        limit: 1\n      }\n    });\n    const features = response.data.features;\n    if (features && features.length > 0) {\n      const [longitude, latitude] = features[0].center;\n      const result = {\n        latitude,\n        longitude\n      };\n      geocodeCache[locationName] = result; // Cache the result\n      return result;\n    }\n  } catch (error) {\n    if (error.response && error.response.status === 429) {\n      console.warn('Rate limit exceeded. Retrying after delay...');\n      await delay(delayMs);\n      return geocodeLocationWithRateLimit(locationName, delayMs * 2); // Exponential backoff\n    }\n    console.error('Geocoding error:', error);\n  }\n\n  // Return null coordinates if geocoding fails\n  return {\n    latitude: null,\n    longitude: null\n  };\n};\n\n// Function to extract coordinates from GeoLocation field if present\nconst extractCoordinates = geoLocation => {\n  if (!geoLocation) return {\n    latitude: null,\n    longitude: null\n  };\n  const regex = /POINT\\s*\\(\\s*([-.\\d]+)\\s+([-.\\d]+)\\s*\\)/i;\n  const match = geoLocation.match(regex);\n  if (match) {\n    return {\n      longitude: parseFloat(match[1]),\n      latitude: parseFloat(match[2])\n    };\n  }\n  return {\n    latitude: null,\n    longitude: null\n  };\n};\n\n// Main preprocess function\nconst preprocessData = async (data, setProgress, locationColumn) => {\n  // Initialize progress\n  setProgress(prev => ({\n    ...prev,\n    preprocess: 0\n  }));\n\n  // Limit data to 100,000 rows to prevent excessive processing\n  const limitedData = data.slice(0, 100000);\n  setProgress(prev => ({\n    ...prev,\n    preprocess: 10\n  }));\n\n  // Define possible field names for latitude and longitude\n  const possibleLatitudeFields = ['latitude', 'Latitude', 'lat', 'Lat'];\n  const possibleLongitudeFields = ['longitude', 'Longitude', 'lon', 'Lng', 'Long'];\n\n  // Identify the actual latitude and longitude fields in the dataset\n  let latitudeField = null;\n  let longitudeField = null;\n  if (limitedData.length > 0) {\n    latitudeField = possibleLatitudeFields.find(field => limitedData[0].hasOwnProperty(field));\n    longitudeField = possibleLongitudeFields.find(field => limitedData[0].hasOwnProperty(field));\n  } else {\n    alert('The dataset is empty.');\n    return [];\n  }\n  setProgress(prev => ({\n    ...prev,\n    preprocess: 20\n  }));\n\n  // Remove rows with missing critical fields (latitude, longitude, or locationColumn)\n  const requiredFields = [];\n  if (!latitudeField || !longitudeField) {\n    requiredFields.push(locationColumn);\n  } else {\n    requiredFields.push(latitudeField, longitudeField);\n  }\n  const cleanData = limitedData.filter(row => {\n    return requiredFields.every(field => row.hasOwnProperty(field) && row[field] !== null && row[field] !== undefined && row[field].toString().trim() !== '');\n  });\n  console.log('Number of Clean Data Points:', cleanData.length);\n  if (cleanData.length === 0) {\n    alert('No data available after filtering out rows with missing critical fields.');\n    return [];\n  }\n  setProgress(prev => ({\n    ...prev,\n    preprocess: 30\n  }));\n\n  // Update latitudeField and longitudeField if they were not initially found\n  if (!latitudeField || !longitudeField) {\n    if (cleanData.length > 0) {\n      latitudeField = possibleLatitudeFields.find(field => cleanData[0].hasOwnProperty(field));\n      longitudeField = possibleLongitudeFields.find(field => cleanData[0].hasOwnProperty(field));\n    }\n  }\n\n  // Process data to ensure each item has latitude and longitude\n  const dataWithCoords = [];\n  for (let i = 0; i < cleanData.length; i++) {\n    const item = cleanData[i];\n    let latitude = null;\n    let longitude = null;\n    if (latitudeField && longitudeField) {\n      latitude = parseFloat(item[latitudeField]);\n      longitude = parseFloat(item[longitudeField]);\n    } else if (item.GeoLocation) {\n      const coords = extractCoordinates(item.GeoLocation);\n      latitude = coords.latitude;\n      longitude = coords.longitude;\n    } else if (item[locationColumn] && locationColumn !== 'locationID') {\n      // Geocode if we have a location name\n      const coords = await geocodeLocationWithRateLimit(item[locationColumn]);\n      latitude = coords.latitude;\n      longitude = coords.longitude;\n    }\n\n    // Remove any existing latitude and longitude fields to avoid confusion\n    possibleLatitudeFields.forEach(field => {\n      delete item[field];\n    });\n    possibleLongitudeFields.forEach(field => {\n      delete item[field];\n    });\n\n    // Add the coordinates to the item\n    item.latitude = latitude;\n    item.longitude = longitude;\n\n    // Only include the item if it has valid coordinates\n    if (latitude !== null && longitude !== null && !isNaN(latitude) && !isNaN(longitude)) {\n      dataWithCoords.push(item);\n    }\n\n    // Update progress\n    if (i % 100 === 0) {\n      const progressValue = 30 + Math.floor(i / cleanData.length * 40); // 30% to 70%\n      setProgress(prev => ({\n        ...prev,\n        preprocess: progressValue\n      }));\n      await delay(1); // Allow UI to update\n    }\n  }\n  console.log('Number of Data Points After Extracting Coordinates:', dataWithCoords.length);\n  if (dataWithCoords.length === 0) {\n    alert('No data available after extracting coordinates.');\n    return [];\n  }\n  setProgress(prev => ({\n    ...prev,\n    preprocess: 80\n  }));\n\n  // Final processing (if any)\n  // ...\n\n  setProgress(prev => ({\n    ...prev,\n    preprocess: 100\n  }));\n  return dataWithCoords;\n};\nexport default preprocessData;","map":{"version":3,"names":["axios","MAPBOX_TOKEN","delay","ms","Promise","resolve","setTimeout","geocodeCache","geocodeLocationWithRateLimit","locationName","delayMs","response","get","encodeURIComponent","params","access_token","limit","features","data","length","longitude","latitude","center","result","error","status","console","warn","extractCoordinates","geoLocation","regex","match","parseFloat","preprocessData","setProgress","locationColumn","prev","preprocess","limitedData","slice","possibleLatitudeFields","possibleLongitudeFields","latitudeField","longitudeField","find","field","hasOwnProperty","alert","requiredFields","push","cleanData","filter","row","every","undefined","toString","trim","log","dataWithCoords","i","item","GeoLocation","coords","forEach","isNaN","progressValue","Math","floor"],"sources":["/Users/girishkumarpatchikoru/Desktop/projecthci/geovizproject/frontend/src/components/preprocessData.js"],"sourcesContent":["// src/components/preprocessData.js\n\nimport axios from 'axios';\nimport { MAPBOX_TOKEN } from './constants';\n\n// Function to introduce a delay (in milliseconds)\nconst delay = (ms) => new Promise((resolve) => setTimeout(resolve, ms));\n\n// Cache object to store geocoding results and avoid duplicate API calls\nconst geocodeCache = {};\n\n// Function to handle geocoding with rate-limiting and caching\nconst geocodeLocationWithRateLimit = async (locationName, delayMs = 200) => {\n  if (geocodeCache[locationName]) {\n    return geocodeCache[locationName];\n  }\n\n  try {\n    const response = await axios.get(\n      `https://api.mapbox.com/geocoding/v5/mapbox.places/${encodeURIComponent(\n        locationName\n      )}.json`,\n      {\n        params: {\n          access_token: MAPBOX_TOKEN,\n          limit: 1,\n        },\n      }\n    );\n\n    const features = response.data.features;\n    if (features && features.length > 0) {\n      const [longitude, latitude] = features[0].center;\n      const result = { latitude, longitude };\n      geocodeCache[locationName] = result; // Cache the result\n      return result;\n    }\n  } catch (error) {\n    if (error.response && error.response.status === 429) {\n      console.warn('Rate limit exceeded. Retrying after delay...');\n      await delay(delayMs);\n      return geocodeLocationWithRateLimit(locationName, delayMs * 2); // Exponential backoff\n    }\n    console.error('Geocoding error:', error);\n  }\n\n  // Return null coordinates if geocoding fails\n  return { latitude: null, longitude: null };\n};\n\n// Function to extract coordinates from GeoLocation field if present\nconst extractCoordinates = (geoLocation) => {\n  if (!geoLocation) return { latitude: null, longitude: null };\n  const regex = /POINT\\s*\\(\\s*([-.\\d]+)\\s+([-.\\d]+)\\s*\\)/i;\n  const match = geoLocation.match(regex);\n  if (match) {\n    return {\n      longitude: parseFloat(match[1]),\n      latitude: parseFloat(match[2]),\n    };\n  }\n  return { latitude: null, longitude: null };\n};\n\n// Main preprocess function\nconst preprocessData = async (data, setProgress, locationColumn) => {\n  // Initialize progress\n  setProgress((prev) => ({ ...prev, preprocess: 0 }));\n\n  // Limit data to 100,000 rows to prevent excessive processing\n  const limitedData = data.slice(0, 100000);\n\n  setProgress((prev) => ({ ...prev, preprocess: 10 }));\n\n  // Define possible field names for latitude and longitude\n  const possibleLatitudeFields = ['latitude', 'Latitude', 'lat', 'Lat'];\n  const possibleLongitudeFields = ['longitude', 'Longitude', 'lon', 'Lng', 'Long'];\n\n  // Identify the actual latitude and longitude fields in the dataset\n  let latitudeField = null;\n  let longitudeField = null;\n\n  if (limitedData.length > 0) {\n    latitudeField = possibleLatitudeFields.find((field) =>\n      limitedData[0].hasOwnProperty(field)\n    );\n    longitudeField = possibleLongitudeFields.find((field) =>\n      limitedData[0].hasOwnProperty(field)\n    );\n  } else {\n    alert('The dataset is empty.');\n    return [];\n  }\n\n  setProgress((prev) => ({ ...prev, preprocess: 20 }));\n\n  // Remove rows with missing critical fields (latitude, longitude, or locationColumn)\n  const requiredFields = [];\n  if (!latitudeField || !longitudeField) {\n    requiredFields.push(locationColumn);\n  } else {\n    requiredFields.push(latitudeField, longitudeField);\n  }\n\n  const cleanData = limitedData.filter((row) => {\n    return requiredFields.every(\n      (field) =>\n        row.hasOwnProperty(field) &&\n        row[field] !== null &&\n        row[field] !== undefined &&\n        row[field].toString().trim() !== ''\n    );\n  });\n\n  console.log('Number of Clean Data Points:', cleanData.length);\n\n  if (cleanData.length === 0) {\n    alert('No data available after filtering out rows with missing critical fields.');\n    return [];\n  }\n\n  setProgress((prev) => ({ ...prev, preprocess: 30 }));\n\n  // Update latitudeField and longitudeField if they were not initially found\n  if (!latitudeField || !longitudeField) {\n    if (cleanData.length > 0) {\n      latitudeField = possibleLatitudeFields.find((field) =>\n        cleanData[0].hasOwnProperty(field)\n      );\n      longitudeField = possibleLongitudeFields.find((field) =>\n        cleanData[0].hasOwnProperty(field)\n      );\n    }\n  }\n\n  // Process data to ensure each item has latitude and longitude\n  const dataWithCoords = [];\n\n  for (let i = 0; i < cleanData.length; i++) {\n    const item = cleanData[i];\n    let latitude = null;\n    let longitude = null;\n\n    if (latitudeField && longitudeField) {\n      latitude = parseFloat(item[latitudeField]);\n      longitude = parseFloat(item[longitudeField]);\n    } else if (item.GeoLocation) {\n      const coords = extractCoordinates(item.GeoLocation);\n      latitude = coords.latitude;\n      longitude = coords.longitude;\n    } else if (item[locationColumn] && locationColumn !== 'locationID') {\n      // Geocode if we have a location name\n      const coords = await geocodeLocationWithRateLimit(item[locationColumn]);\n      latitude = coords.latitude;\n      longitude = coords.longitude;\n    }\n\n    // Remove any existing latitude and longitude fields to avoid confusion\n    possibleLatitudeFields.forEach((field) => {\n      delete item[field];\n    });\n    possibleLongitudeFields.forEach((field) => {\n      delete item[field];\n    });\n\n    // Add the coordinates to the item\n    item.latitude = latitude;\n    item.longitude = longitude;\n\n    // Only include the item if it has valid coordinates\n    if (\n      latitude !== null &&\n      longitude !== null &&\n      !isNaN(latitude) &&\n      !isNaN(longitude)\n    ) {\n      dataWithCoords.push(item);\n    }\n\n    // Update progress\n    if (i % 100 === 0) {\n      const progressValue = 30 + Math.floor((i / cleanData.length) * 40); // 30% to 70%\n      setProgress((prev) => ({ ...prev, preprocess: progressValue }));\n      await delay(1); // Allow UI to update\n    }\n  }\n\n  console.log(\n    'Number of Data Points After Extracting Coordinates:',\n    dataWithCoords.length\n  );\n\n  if (dataWithCoords.length === 0) {\n    alert('No data available after extracting coordinates.');\n    return [];\n  }\n\n  setProgress((prev) => ({ ...prev, preprocess: 80 }));\n\n  // Final processing (if any)\n  // ...\n\n  setProgress((prev) => ({ ...prev, preprocess: 100 }));\n\n  return dataWithCoords;\n};\n\nexport default preprocessData;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}
{"ast":null,"code":"// src/components/preprocessData.js\n\nimport axios from 'axios';\nimport { MAPBOX_TOKEN } from './constants';\n\n// Utility function for safely checking if a value exists and isn't empty\nconst isValidValue = value => {\n  if (value === null || value === undefined) return false;\n  if (typeof value === 'string') return value.trim() !== '';\n  return true;\n};\n\n// Utility function for delay\nconst delay = ms => new Promise(resolve => setTimeout(resolve, ms));\n\n// Cache object to store geocoding results\nconst geocodeCache = {};\n\n// Function to handle geocoding with rate-limiting and caching\nconst geocodeLocationWithRateLimit = async (locationName, delayMs = 200) => {\n  if (!locationName) return {\n    latitude: null,\n    longitude: null\n  };\n  if (geocodeCache[locationName]) {\n    return geocodeCache[locationName];\n  }\n  try {\n    const response = await axios.get(`https://api.mapbox.com/geocoding/v5/mapbox.places/${encodeURIComponent(locationName)}.json`, {\n      params: {\n        access_token: MAPBOX_TOKEN,\n        limit: 1\n      }\n    });\n    const features = response.data.features;\n    if ((features === null || features === void 0 ? void 0 : features.length) > 0) {\n      const [longitude, latitude] = features[0].center;\n      const result = {\n        latitude,\n        longitude\n      };\n      geocodeCache[locationName] = result;\n      return result;\n    }\n  } catch (error) {\n    var _error$response;\n    console.error('Geocoding error:', error);\n    if (((_error$response = error.response) === null || _error$response === void 0 ? void 0 : _error$response.status) === 429) {\n      await delay(delayMs);\n      return geocodeLocationWithRateLimit(locationName, delayMs * 2);\n    }\n  }\n  return {\n    latitude: null,\n    longitude: null\n  };\n};\n\n// Function to extract coordinates from GeoLocation field\nconst extractCoordinates = geoLocation => {\n  if (!geoLocation) return {\n    latitude: null,\n    longitude: null\n  };\n  try {\n    const regex = /POINT\\s*\\(\\s*([-.\\d]+)\\s+([-.\\d]+)\\s*\\)/i;\n    const match = geoLocation.toString().match(regex);\n    if (match) {\n      return {\n        longitude: parseFloat(match[1]),\n        latitude: parseFloat(match[2])\n      };\n    }\n  } catch (error) {\n    console.error('Error extracting coordinates:', error);\n  }\n  return {\n    latitude: null,\n    longitude: null\n  };\n};\n\n// Main preprocess function\nconst preprocessData = async (data, setProgress, locationColumn) => {\n  try {\n    // Initialize progress\n    setProgress === null || setProgress === void 0 ? void 0 : setProgress(prev => ({\n      ...prev,\n      preprocess: 0\n    }));\n    if (!Array.isArray(data) || data.length === 0) {\n      console.error('Invalid or empty data array');\n      return [];\n    }\n\n    // Limit data to prevent excessive processing\n    const limitedData = data.slice(0, 100000);\n    setProgress === null || setProgress === void 0 ? void 0 : setProgress(prev => ({\n      ...prev,\n      preprocess: 10\n    }));\n\n    // Define possible field names\n    const possibleFields = {\n      latitude: ['latitude', 'Latitude', 'lat', 'Lat'],\n      longitude: ['longitude', 'Longitude', 'lon', 'Lng', 'Long'],\n      state: ['state', 'STATE_NAME', 'state_id', 'STATE_CODE'],\n      city: ['city', 'CITY_NAME', 'city_ascii']\n    };\n\n    // Find actual field names in the dataset\n    const fields = {};\n    Object.entries(possibleFields).forEach(([key, possibilities]) => {\n      fields[key] = possibilities.find(field => {\n        var _limitedData$;\n        return ((_limitedData$ = limitedData[0]) === null || _limitedData$ === void 0 ? void 0 : _limitedData$.hasOwnProperty(field)) && limitedData.some(row => isValidValue(row[field]));\n      });\n    });\n    setProgress === null || setProgress === void 0 ? void 0 : setProgress(prev => ({\n      ...prev,\n      preprocess: 20\n    }));\n\n    // Determine if geocoding is needed\n    const requiresGeocoding = !fields.latitude || !fields.longitude;\n\n    // Filter out rows with missing critical fields\n    const cleanData = limitedData.filter(row => {\n      if (requiresGeocoding) {\n        return isValidValue(row[locationColumn]) || isValidValue(row[fields.city]) && isValidValue(row[fields.state]);\n      }\n      return isValidValue(row[fields.latitude]) && isValidValue(row[fields.longitude]);\n    });\n    if (cleanData.length === 0) {\n      console.warn('No valid data points after filtering');\n      return [];\n    }\n    setProgress === null || setProgress === void 0 ? void 0 : setProgress(prev => ({\n      ...prev,\n      preprocess: 30\n    }));\n\n    // Process data to ensure each item has coordinates\n    const processedData = [];\n    for (let i = 0; i < cleanData.length; i++) {\n      const item = {\n        ...cleanData[i]\n      };\n      let coordinates = {\n        latitude: null,\n        longitude: null\n      };\n\n      // Try to get coordinates using available methods\n      if (!requiresGeocoding) {\n        coordinates = {\n          latitude: parseFloat(item[fields.latitude]),\n          longitude: parseFloat(item[fields.longitude])\n        };\n      } else if (item.GeoLocation) {\n        coordinates = extractCoordinates(item.GeoLocation);\n      } else {\n        const locationParts = [item[fields.city], item[fields.state], item[locationColumn]].filter(isValidValue);\n        if (locationParts.length > 0) {\n          coordinates = await geocodeLocationWithRateLimit(locationParts.join(', '));\n        }\n      }\n\n      // Validate coordinates\n      if (coordinates.latitude != null && coordinates.longitude != null && !isNaN(coordinates.latitude) && !isNaN(coordinates.longitude)) {\n        // Remove old coordinate fields\n        Object.values(possibleFields).flat().forEach(field => {\n          delete item[field];\n        });\n\n        // Add new coordinate fields\n        processedData.push({\n          ...item,\n          latitude: coordinates.latitude,\n          longitude: coordinates.longitude\n        });\n      }\n\n      // Update progress\n      if (i % 100 === 0) {\n        const progress = 30 + Math.floor(i / cleanData.length * 60);\n        setProgress === null || setProgress === void 0 ? void 0 : setProgress(prev => ({\n          ...prev,\n          preprocess: progress\n        }));\n        await delay(1);\n      }\n    }\n    setProgress === null || setProgress === void 0 ? void 0 : setProgress(prev => ({\n      ...prev,\n      preprocess: 100\n    }));\n    return processedData;\n  } catch (error) {\n    console.error('Error in preprocessData:', error);\n    setProgress === null || setProgress === void 0 ? void 0 : setProgress(prev => ({\n      ...prev,\n      preprocess: 0\n    }));\n    return [];\n  }\n};\nexport default preprocessData;","map":{"version":3,"names":["axios","MAPBOX_TOKEN","isValidValue","value","undefined","trim","delay","ms","Promise","resolve","setTimeout","geocodeCache","geocodeLocationWithRateLimit","locationName","delayMs","latitude","longitude","response","get","encodeURIComponent","params","access_token","limit","features","data","length","center","result","error","_error$response","console","status","extractCoordinates","geoLocation","regex","match","toString","parseFloat","preprocessData","setProgress","locationColumn","prev","preprocess","Array","isArray","limitedData","slice","possibleFields","state","city","fields","Object","entries","forEach","key","possibilities","find","field","_limitedData$","hasOwnProperty","some","row","requiresGeocoding","cleanData","filter","warn","processedData","i","item","coordinates","GeoLocation","locationParts","join","isNaN","values","flat","push","progress","Math","floor"],"sources":["/Users/girishkumarpatchikoru/Desktop/projecthci/geovizproject/frontend/src/components/preprocessData.js"],"sourcesContent":["// src/components/preprocessData.js\n\nimport axios from 'axios';\nimport { MAPBOX_TOKEN } from './constants';\n\n// Utility function for safely checking if a value exists and isn't empty\nconst isValidValue = (value) => {\n  if (value === null || value === undefined) return false;\n  if (typeof value === 'string') return value.trim() !== '';\n  return true;\n};\n\n// Utility function for delay\nconst delay = (ms) => new Promise((resolve) => setTimeout(resolve, ms));\n\n// Cache object to store geocoding results\nconst geocodeCache = {};\n\n// Function to handle geocoding with rate-limiting and caching\nconst geocodeLocationWithRateLimit = async (locationName, delayMs = 200) => {\n  if (!locationName) return { latitude: null, longitude: null };\n  \n  if (geocodeCache[locationName]) {\n    return geocodeCache[locationName];\n  }\n\n  try {\n    const response = await axios.get(\n      `https://api.mapbox.com/geocoding/v5/mapbox.places/${encodeURIComponent(\n        locationName\n      )}.json`,\n      {\n        params: {\n          access_token: MAPBOX_TOKEN,\n          limit: 1,\n        },\n      }\n    );\n\n    const features = response.data.features;\n    if (features?.length > 0) {\n      const [longitude, latitude] = features[0].center;\n      const result = { latitude, longitude };\n      geocodeCache[locationName] = result;\n      return result;\n    }\n  } catch (error) {\n    console.error('Geocoding error:', error);\n    if (error.response?.status === 429) {\n      await delay(delayMs);\n      return geocodeLocationWithRateLimit(locationName, delayMs * 2);\n    }\n  }\n\n  return { latitude: null, longitude: null };\n};\n\n// Function to extract coordinates from GeoLocation field\nconst extractCoordinates = (geoLocation) => {\n  if (!geoLocation) return { latitude: null, longitude: null };\n  \n  try {\n    const regex = /POINT\\s*\\(\\s*([-.\\d]+)\\s+([-.\\d]+)\\s*\\)/i;\n    const match = geoLocation.toString().match(regex);\n    if (match) {\n      return {\n        longitude: parseFloat(match[1]),\n        latitude: parseFloat(match[2]),\n      };\n    }\n  } catch (error) {\n    console.error('Error extracting coordinates:', error);\n  }\n  \n  return { latitude: null, longitude: null };\n};\n\n// Main preprocess function\nconst preprocessData = async (data, setProgress, locationColumn) => {\n  try {\n    // Initialize progress\n    setProgress?.(prev => ({ ...prev, preprocess: 0 }));\n\n    if (!Array.isArray(data) || data.length === 0) {\n      console.error('Invalid or empty data array');\n      return [];\n    }\n\n    // Limit data to prevent excessive processing\n    const limitedData = data.slice(0, 100000);\n    setProgress?.(prev => ({ ...prev, preprocess: 10 }));\n\n    // Define possible field names\n    const possibleFields = {\n      latitude: ['latitude', 'Latitude', 'lat', 'Lat'],\n      longitude: ['longitude', 'Longitude', 'lon', 'Lng', 'Long'],\n      state: ['state', 'STATE_NAME', 'state_id', 'STATE_CODE'],\n      city: ['city', 'CITY_NAME', 'city_ascii']\n    };\n\n    // Find actual field names in the dataset\n    const fields = {};\n    Object.entries(possibleFields).forEach(([key, possibilities]) => {\n      fields[key] = possibilities.find(field => \n        limitedData[0]?.hasOwnProperty(field) && \n        limitedData.some(row => isValidValue(row[field]))\n      );\n    });\n\n    setProgress?.(prev => ({ ...prev, preprocess: 20 }));\n\n    // Determine if geocoding is needed\n    const requiresGeocoding = !fields.latitude || !fields.longitude;\n\n    // Filter out rows with missing critical fields\n    const cleanData = limitedData.filter(row => {\n      if (requiresGeocoding) {\n        return isValidValue(row[locationColumn]) ||\n               (isValidValue(row[fields.city]) && isValidValue(row[fields.state]));\n      }\n      return isValidValue(row[fields.latitude]) && isValidValue(row[fields.longitude]);\n    });\n\n    if (cleanData.length === 0) {\n      console.warn('No valid data points after filtering');\n      return [];\n    }\n\n    setProgress?.(prev => ({ ...prev, preprocess: 30 }));\n\n    // Process data to ensure each item has coordinates\n    const processedData = [];\n    for (let i = 0; i < cleanData.length; i++) {\n      const item = { ...cleanData[i] };\n      let coordinates = { latitude: null, longitude: null };\n\n      // Try to get coordinates using available methods\n      if (!requiresGeocoding) {\n        coordinates = {\n          latitude: parseFloat(item[fields.latitude]),\n          longitude: parseFloat(item[fields.longitude])\n        };\n      } else if (item.GeoLocation) {\n        coordinates = extractCoordinates(item.GeoLocation);\n      } else {\n        const locationParts = [\n          item[fields.city],\n          item[fields.state],\n          item[locationColumn]\n        ].filter(isValidValue);\n        \n        if (locationParts.length > 0) {\n          coordinates = await geocodeLocationWithRateLimit(locationParts.join(', '));\n        }\n      }\n\n      // Validate coordinates\n      if (coordinates.latitude != null && \n          coordinates.longitude != null && \n          !isNaN(coordinates.latitude) && \n          !isNaN(coordinates.longitude)) {\n        \n        // Remove old coordinate fields\n        Object.values(possibleFields).flat().forEach(field => {\n          delete item[field];\n        });\n\n        // Add new coordinate fields\n        processedData.push({\n          ...item,\n          latitude: coordinates.latitude,\n          longitude: coordinates.longitude\n        });\n      }\n\n      // Update progress\n      if (i % 100 === 0) {\n        const progress = 30 + Math.floor((i / cleanData.length) * 60);\n        setProgress?.(prev => ({ ...prev, preprocess: progress }));\n        await delay(1);\n      }\n    }\n\n    setProgress?.(prev => ({ ...prev, preprocess: 100 }));\n    \n    return processedData;\n\n  } catch (error) {\n    console.error('Error in preprocessData:', error);\n    setProgress?.(prev => ({ ...prev, preprocess: 0 }));\n    return [];\n  }\n};\n\nexport default preprocessData;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}
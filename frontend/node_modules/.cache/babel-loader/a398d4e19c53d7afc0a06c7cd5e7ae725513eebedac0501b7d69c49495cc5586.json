{"ast":null,"code":"var _jsxFileName = \"/Users/girishkumarpatchikoru/Desktop/projecthci/geovizproject/frontend/src/components/MapView.js\",\n  _s = $RefreshSig$();\n// // src/components/MapView.js\n\n// import React, { useEffect, useState, useCallback } from 'react';\n// import mapboxgl from 'mapbox-gl';\n// import Papa from 'papaparse';\n// import { Bar, Pie, Doughnut, PolarArea } from 'react-chartjs-2';\n// import {\n//   Chart as ChartJS,\n//   RadialLinearScale,\n//   CategoryScale,\n//   LinearScale,\n//   BarElement,\n//   ArcElement,\n//   Title,\n//   Tooltip,\n//   Legend,\n// } from 'chart.js';\n// import ChartDataLabels from 'chartjs-plugin-datalabels';\n// import { CircularProgressbar } from 'react-circular-progressbar';\n// import 'react-circular-progressbar/dist/styles.css';\n\n// import styles from './styles'; // Ensure this file exists and is properly configured\n// import preprocessData from './preprocessData'; // Ensure this file exists and is properly configured\n// import { MAPBOX_TOKEN } from './constants'; // Ensure this file exists and contains your Mapbox token\n// import blueMarkerIcon from '../assets/images/custom-marker-blue.png'; // Ensure these assets exist\n// import redMarkerIcon from '../assets/images/custom-marker-red.png';\n// import './marker.css'; // Ensure this CSS file exists for marker styling\n\n// // Register Chart.js components\n// ChartJS.register(\n//   RadialLinearScale,\n//   CategoryScale,\n//   LinearScale,\n//   BarElement,\n//   ArcElement,\n//   Title,\n//   Tooltip,\n//   Legend,\n//   ChartDataLabels\n// );\n\n// // Set Mapbox access token\n// mapboxgl.accessToken = MAPBOX_TOKEN;\n\n// const MapView = () => {\n//   // State Variables\n//   const [map, setMap] = useState(null);\n//   const [geoData, setGeoData] = useState([]);\n//   const [numericHeaders, setNumericHeaders] = useState([]);\n//   const [stringHeaders, setStringHeaders] = useState([]);\n//   const [selectedLocation, setSelectedLocation] = useState(null);\n//   const [chartType, setChartType] = useState('Bar');\n//   const [chartData, setChartData] = useState(null);\n//   const [totalRows, setTotalRows] = useState(0);\n//   const [totalColumns, setTotalColumns] = useState(0);\n//   const [markers, setMarkers] = useState([]);\n//   const [currentPopup, setCurrentPopup] = useState(null);\n//   const [progress, setProgress] = useState({\n//     upload: 0,\n//     preprocess: 0,\n//     geocode: 0,\n//   });\n//   const [progressMessages, setProgressMessages] = useState({\n//     upload: '',\n//     preprocess: '',\n//     geocode: '',\n//   });\n//   const [cityList, setCityList] = useState([]);\n//   const [selectedCity1, setSelectedCity1] = useState('');\n//   const [selectedCity2, setSelectedCity2] = useState('');\n//   const [locationColumn, setLocationColumn] = useState('');\n//   const [columnValueCounts, setColumnValueCounts] = useState({});\n//   const [markersAdded, setMarkersAdded] = useState(false);\n\n//   // Initialize Map\n//   useEffect(() => {\n//     const initializeMap = new mapboxgl.Map({\n//       container: 'map', // HTML container id\n//       style: 'mapbox://styles/mapbox/streets-v11', // style URL\n//       center: [-98.5795, 39.8283], // starting position [lng, lat] (center of USA)\n//       zoom: 3, // starting zoom\n//     });\n\n//     // Add navigation control (the +/- zoom buttons)\n//     const nav = new mapboxgl.NavigationControl();\n//     initializeMap.addControl(nav, 'top-right');\n\n//     setMap(initializeMap);\n\n//     // Clean up on unmount\n//     return () => initializeMap.remove();\n//   }, []);\n\n//   // Preprocess Data Function\n//   const handlePreprocess = useCallback(\n//     async (rawData) => {\n//       // Determine the location column dynamically\n//       const possibleLocationColumns = [\n//         'LocationDesc',\n//         'LocationAbbr',\n//         'state',\n//         'State',\n//         'city',\n//         'City',\n//         'Country',\n//         'Country Name',\n//         'Country Code',\n//         'Address',\n//         'Place',\n//         'GeoLocation',\n//         // Include more possible location columns if necessary\n//       ];\n//       let detectedLocationColumn = possibleLocationColumns.find(\n//         (col) => rawData[0] && rawData[0].hasOwnProperty(col)\n//       );\n\n//       // If no location column is found, use 'locationID'\n//       if (!detectedLocationColumn) {\n//         detectedLocationColumn = 'locationID';\n//       }\n\n//       setLocationColumn(detectedLocationColumn);\n//       console.log('Detected Location Column:', detectedLocationColumn);\n\n//       // Preprocess data\n//       const processedData = await preprocessData(\n//         rawData,\n//         setProgress,\n//         detectedLocationColumn\n//       );\n\n//       if (!processedData || processedData.length === 0) {\n//         alert('No valid data after preprocessing.');\n//         return;\n//       }\n\n//       setGeoData(processedData);\n\n//       // Identify numeric and string headers\n//       if (processedData.length > 0) {\n//         const headers = Object.keys(processedData[0]);\n//         const numeric = [];\n//         const strings = [];\n\n//         headers.forEach((header) => {\n//           if (\n//             ['latitude', 'longitude', 'GeoLocation', 'locationID'].includes(header)\n//           )\n//             return;\n\n//           const isNumeric = processedData.every((item) => {\n//             const value = parseFloat(item[header]);\n//             return !isNaN(value);\n//           });\n//           if (isNumeric) {\n//             numeric.push(header);\n//           } else {\n//             strings.push(header);\n//           }\n//         });\n\n//         setNumericHeaders(numeric);\n//         setStringHeaders(strings);\n\n//         setTotalRows(processedData.length);\n//         setTotalColumns(headers.length);\n\n//         // Count non-null values per column\n//         const columnCounts = {};\n//         headers.forEach((header) => {\n//           const count = processedData.filter(\n//             (item) => item[header] !== null && item[header] !== ''\n//           ).length;\n//           columnCounts[header] = count;\n//         });\n\n//         setColumnValueCounts(columnCounts);\n\n//         // Extract unique locations for comparison\n//         const uniqueLocations = [\n//           ...new Set(\n//             processedData.map((item) => item[detectedLocationColumn]).filter(Boolean)\n//           ),\n//         ];\n//         setCityList(uniqueLocations);\n//       } else {\n//         alert('No data available after filtering.');\n//       }\n\n//       // Reset markersAdded state when new data is uploaded\n//       setMarkersAdded(false);\n//     },\n//     []\n//   );\n\n//   // Generate a human-readable label for the location\n//   const getLocationLabel = (data) => {\n//     if (data[locationColumn]) return data[locationColumn];\n//     if (data.city) return data.city;\n//     if (data.state) return data.state;\n//     if (data.address) return data.address;\n//     return `Lat: ${parseFloat(data.latitude).toFixed(2)}, Lng: ${parseFloat(\n//       data.longitude\n//     ).toFixed(2)}`;\n//   };\n\n//   // Handle File Upload\n//   const handleFileUpload = (event) => {\n//     setProgress({\n//       upload: 0,\n//       preprocess: 0,\n//       geocode: 0,\n//     });\n//     setProgressMessages({\n//       upload: '',\n//       preprocess: '',\n//       geocode: '',\n//     });\n//     const file = event.target.files[0];\n//     if (file) {\n//       const fileExtension = file.name.split('.').pop().toLowerCase();\n\n//       if (fileExtension === 'json') {\n//         const reader = new FileReader();\n//         reader.onload = async (e) => {\n//           try {\n//             const data = JSON.parse(e.target.result);\n//             setProgress((prev) => ({ ...prev, upload: 100 }));\n//             setProgressMessages((prev) => ({\n//               ...prev,\n//               upload: 'Dataset uploaded successfully.',\n//             }));\n//             await handlePreprocess(data);\n//           } catch (error) {\n//             console.error('Invalid JSON format:', error);\n//             alert('Error: Uploaded file is not valid JSON.');\n//           }\n//         };\n//         reader.readAsText(file);\n//       } else if (fileExtension === 'csv') {\n//         Papa.parse(file, {\n//           header: true,\n//           skipEmptyLines: true,\n//           beforeFirstChunk: (chunk) => {\n//             // Handle datasets with metadata rows\n//             const lines = chunk.trim().split('\\n');\n//             const dataStartIndex = lines.findIndex(\n//               (line) =>\n//                 line.startsWith('Country Name') ||\n//                 line.startsWith('state') ||\n//                 line.startsWith('RowId')\n//             );\n//             if (dataStartIndex > 0) {\n//               return lines.slice(dataStartIndex).join('\\n');\n//             }\n//             return chunk;\n//           },\n//           complete: async (results) => {\n//             setProgress((prev) => ({ ...prev, upload: 100 }));\n//             setProgressMessages((prev) => ({\n//               ...prev,\n//               upload: 'Dataset uploaded successfully.',\n//             }));\n//             await handlePreprocess(results.data);\n//           },\n//           error: (error) => {\n//             console.error('CSV parsing error:', error);\n//             alert('Error: Failed to parse CSV file.');\n//           },\n//         });\n//       } else {\n//         alert('Please upload a valid JSON or CSV file.');\n//       }\n//     }\n//   };\n\n//   // Monitor Progress Updates\n//   useEffect(() => {\n//     if (progress.preprocess === 100) {\n//       setProgressMessages((prev) => ({\n//         ...prev,\n//         preprocess: 'Preprocessing completed.',\n//       }));\n//     }\n//   }, [progress.preprocess]);\n\n//   useEffect(() => {\n//     if (progress.geocode === 100) {\n//       setProgressMessages((prev) => ({\n//         ...prev,\n//         geocode: 'Locations marked on the map.',\n//       }));\n//     }\n//   }, [progress.geocode]);\n\n//   // Handle Location Selection from Map\n//   const handleLocationSelect = (locationData) => {\n//     // Clear city selections if a map marker is selected\n//     setSelectedCity1('');\n//     setSelectedCity2('');\n//     if (selectedLocation && selectedLocation.locationID === locationData.locationID) {\n//       setSelectedLocation(null); // Deselect\n//       setChartData(null);\n//       if (currentPopup) currentPopup.remove();\n//     } else {\n//       setSelectedLocation(locationData);\n//       setChartData(null);\n//       if (currentPopup) currentPopup.remove();\n//     }\n//   };\n\n//   // Handle Location Comparison Selection\n//   const handleCitySelection = () => {\n//     if (selectedCity1 && selectedCity2) {\n//       const data1 = geoData.filter(\n//         (item) => item[locationColumn] === selectedCity1\n//       );\n//       const data2 = geoData.filter(\n//         (item) => item[locationColumn] === selectedCity2\n//       );\n\n//       if (data1.length === 0 || data2.length === 0) {\n//         alert('One or both selected locations have no data.');\n//         return;\n//       }\n\n//       // Aggregate data (e.g., average)\n//       const aggregatedData1 = {};\n//       const aggregatedData2 = {};\n\n//       numericHeaders.forEach((header) => {\n//         const values1 = data1.map((item) => parseFloat(item[header]) || 0);\n//         const values2 = data2.map((item) => parseFloat(item[header]) || 0);\n\n//         const avg1 = values1.reduce((a, b) => a + b, 0) / (values1.length || 1);\n//         const avg2 = values2.reduce((a, b) => a + b, 0) / (values2.length || 1);\n\n//         aggregatedData1[header] = avg1;\n//         aggregatedData2[header] = avg2;\n//       });\n\n//       // Normalize data for chart display (0.5% to 10%)\n//       const dataMin = 0; // Minimum data value\n//       const dataMax = Math.max(\n//         ...Object.values(aggregatedData1),\n//         ...Object.values(aggregatedData2)\n//       );\n//       const range = dataMax - dataMin || 1; // Avoid division by zero\n\n//       const normalizedData1 = {};\n//       const normalizedData2 = {};\n//       const actualData1 = {};\n//       const actualData2 = {};\n\n//       numericHeaders.forEach((header) => {\n//         normalizedData1[header] =\n//           ((aggregatedData1[header] - dataMin) / range) * 9.5 + 0.5;\n//         normalizedData2[header] =\n//           ((aggregatedData2[header] - dataMin) / range) * 9.5 + 0.5;\n//         actualData1[header] = aggregatedData1[header];\n//         actualData2[header] = aggregatedData2[header];\n//       });\n\n//       // Prepare chart data\n//       const labels = numericHeaders;\n//       const dataSet = {\n//         labels,\n//         datasets: [\n//           {\n//             label: selectedCity1,\n//             data: numericHeaders.map((header) => normalizedData1[header]),\n//             actualValues: numericHeaders.map((header) => actualData1[header]),\n//             backgroundColor: 'rgba(255, 99, 132, 0.5)',\n//             borderColor: 'rgba(255, 99, 132, 1)',\n//             borderWidth: 1,\n//           },\n//           {\n//             label: selectedCity2,\n//             data: numericHeaders.map((header) => normalizedData2[header]),\n//             actualValues: numericHeaders.map((header) => actualData2[header]),\n//             backgroundColor: 'rgba(54, 162, 235, 0.5)',\n//             borderColor: 'rgba(54, 162, 235, 1)',\n//             borderWidth: 1,\n//           },\n//         ],\n//       };\n\n//       setChartData(dataSet);\n//       setSelectedLocation(null); // Deselect any single location\n//       if (currentPopup) currentPopup.remove();\n//     }\n//   };\n\n//   const generateChartData = useCallback(() => {\n//     if (selectedLocation) {\n//       const locationValues = numericHeaders.map((header) => ({\n//         label: header,\n//         value: parseFloat(selectedLocation[header]) || 0,\n//       }));\n\n//       const dataMin = 0; // Minimum data value\n//       const dataMax = Math.max(...locationValues.map((item) => item.value));\n//       const range = dataMax - dataMin || 1; // Avoid division by zero\n\n//       const normalizedValues = locationValues.map((item) => ({\n//         label: item.label,\n//         normalizedValue: ((item.value - dataMin) / range) * 9.5 + 0.5,\n//         actualValue: item.value, // Keep the actual value\n//       }));\n\n//       setChartData({\n//         labels: normalizedValues.map((item) => item.label),\n//         datasets: [\n//           {\n//             label: getLocationLabel(selectedLocation),\n//             data: normalizedValues.map((item) => item.normalizedValue),\n//             actualValues: normalizedValues.map((item) => item.actualValue), // Store actual values\n//             backgroundColor: [\n//               'rgba(255, 99, 132, 0.5)',\n//               'rgba(54, 162, 235, 0.5)',\n//               'rgba(255, 206, 86, 0.5)',\n//               'rgba(75, 192, 192, 0.5)',\n//               'rgba(153, 102, 255, 0.5)',\n//               'rgba(255, 159, 64, 0.5)',\n\n//             ],\n//             borderColor: [\n//               'rgba(255, 99, 132, 1)',\n//               'rgba(54, 162, 235, 1)',\n//               'rgba(255, 206, 86, 1)',\n//               'rgba(75, 192, 192, 1)',\n//               'rgba(153, 102, 255, 1)',\n//               'rgba(255, 159, 64, 1)',\n\n//             ],\n//             borderWidth: 1,\n//           },\n//         ],\n//       });\n//     }\n//   }, [selectedLocation, numericHeaders]);\n\n//   //Data Generation\n//   useEffect(() => {\n//     generateChartData();\n//   }, [generateChartData, chartType]);\n\n//   //Markers on Map\n//   const renderMarkers = useCallback(() => {\n//     if (map && geoData.length > 0) {\n//       // Remove existing markers\n//       markers.forEach((marker) => marker.remove());\n//       const newMarkers = [];\n\n//       geoData.forEach((data) => {\n//         const latitude = parseFloat(data.latitude);\n//         const longitude = parseFloat(data.longitude);\n\n//         if (!isNaN(latitude) && !isNaN(longitude)) {\n//           const el = document.createElement('div');\n//           el.className = 'marker';\n//           const isSelected = selectedLocation\n//             ? selectedLocation.locationID === data.locationID\n//             : false;\n//           const icon = isSelected ? redMarkerIcon : blueMarkerIcon;\n//           el.style.backgroundImage = `url(${icon})`;\n//           el.style.width = '30px';\n//           el.style.height = '30px';\n//           el.style.backgroundSize = 'contain';\n//           el.style.cursor = 'pointer';\n\n//           const marker = new mapboxgl.Marker(el)\n//             .setLngLat([longitude, latitude])\n//             .addTo(map);\n\n//           marker.getElement().addEventListener('click', () => {\n//             handleLocationSelect(data);\n//           });\n\n//           newMarkers.push(marker);\n//         }\n//       });\n//       setMarkers(newMarkers);\n//       setMarkersAdded(true); \n\n//       setProgress((prev) => ({ ...prev, geocode: 100 }));\n//       setProgressMessages((prev) => ({\n//         ...prev,\n//         geocode: 'Locations marked on the map.',\n//       }));\n//     }\n//   }, [map, geoData, selectedLocation]);\n\n//   // Re-render markers when selectedLocation changes to update marker colors\n//   useEffect(() => {\n//     if (markersAdded) {\n//       renderMarkers();\n//     }\n//   }, [selectedLocation, renderMarkers, markersAdded]);\n\n//   // Chart Options\n//   const chartOptions = {\n//     responsive: true,\n//     maintainAspectRatio: false,\n//     scales:\n//       chartType === 'Bar'\n//         ? {\n//             y: {\n//               beginAtZero: true,\n//               min: 0.5,\n//               max: 10,\n//             },\n//           }\n//         : {},\n//     plugins: {\n//       legend: {\n//         position: 'top',\n//       },\n//       datalabels: {\n//         display: true,\n//         color: '#000',\n//         align: 'center', // Align labels to the center of the bars\n//         anchor: 'center',\n//         formatter: function (value, context) {\n//           const dataset = context.chart.data.datasets[context.datasetIndex];\n//           if (dataset.actualValues) {\n//             const actualValue = dataset.actualValues[context.dataIndex];\n//             return actualValue.toFixed(2); // Display actual value\n//           } else {\n//             return value.toFixed(2);\n//           }\n//         },\n//       },\n//       tooltip: {\n//         callbacks: {\n//           label: function (context) {\n//             const dataset = context.dataset;\n//             if (dataset.actualValues) {\n//               const actualValue = dataset.actualValues[context.dataIndex];\n//               return `${context.label}: ${actualValue.toFixed(2)}`;\n//             } else {\n//               return `${context.label}: ${context.parsed.y}`;\n//             }\n//           },\n//         },\n//       },\n//     },\n//   };\n\n//   return (\n//     <div style={styles.container}>\n//       {/* Map Container */}\n//       <div id=\"map\" style={styles.map}></div>\n\n//       {/* Sidebar */}\n//       <div style={styles.sidebar}>\n//         {/* Combined Controls Box */}\n//         <div style={styles.combinedBox}>\n//           {/* Progress Indicators */}\n//           <div style={styles.progressContainer}>\n//             <div style={styles.progressItem}>\n//               <CircularProgressbar\n//                 value={progress.upload}\n//                 text={`${Math.round(progress.upload)}%`}\n//                 styles={{\n//                   root: { width: '80px' },\n//                   text: { fontSize: '10px' },\n//                 }}\n//               />\n//               <div style={styles.progressMessage}>{progressMessages.upload}</div>\n//             </div>\n//             <div style={styles.progressItem}>\n//               <CircularProgressbar\n//                 value={progress.preprocess}\n//                 text={`${Math.round(progress.preprocess)}%`}\n//                 styles={{\n//                   root: { width: '80px' },\n//                   text: { fontSize: '10px' },\n//                 }}\n//               />\n//               <div style={styles.progressMessage}>{progressMessages.preprocess}</div>\n//             </div>\n//             <div style={styles.progressItem}>\n//               <CircularProgressbar\n//                 value={progress.geocode}\n//                 text={`${Math.round(progress.geocode)}%`}\n//                 styles={{\n//                   root: { width: '80px' },\n//                   text: { fontSize: '10px' },\n//                 }}\n//               />\n//               <div style={styles.progressMessage}>{progressMessages.geocode}</div>\n//             </div>\n//           </div>\n\n//           {/* Upload Data Section */}\n//           <div style={styles.section}>\n//             <h3 style={styles.sectionTitle}>Upload Data</h3>\n//             <input\n//               type=\"file\"\n//               accept=\".json, .csv\"\n//               onChange={handleFileUpload}\n//               style={styles.fileInput}\n//             />\n//           </div>\n\n//           {/* Mark Locations Button */}\n//           {geoData.length > 0 && !markersAdded && (\n//             <div style={styles.section}>\n//               <button\n//                 onClick={renderMarkers}\n//                 style={{\n//                   ...styles.chartButton,\n//                   backgroundColor: '#17a2b8',\n//                   width: '100%',\n//                 }}\n//               >\n//                 Mark Locations on Map\n//               </button>\n//             </div>\n//           )}\n\n//           {/* Dataset Details Section */}\n//           <div style={styles.section}>\n//             <h3 style={styles.sectionTitle}>Dataset Details</h3>\n//             {geoData.length > 0 ? (\n//               <div style={styles.datasetDetails}>\n//                 <p>\n//                   <strong>Rows:</strong> {totalRows}\n//                 </p>\n//                 <p>\n//                   <strong>Columns:</strong> {totalColumns}\n//                 </p>\n//                 <p>\n//                   <strong>Numeric Columns:</strong> {numericHeaders.join(', ')}\n//                 </p>\n//                 <p>\n//                   <strong>String Columns:</strong> {stringHeaders.join(', ')}\n//                 </p>\n//               </div>\n//             ) : (\n//               <p>No dataset uploaded yet.</p>\n//             )}\n//           </div>\n\n//           {/* Location Comparison Section */}\n//           <div style={styles.section}>\n//             <h3 style={styles.sectionTitle}>Compare Two Locations</h3>\n//             <div style={styles.inputGroup}>\n//               <label style={styles.inputLabel}>Location 1:</label>\n//               <select\n//                 value={selectedCity1}\n//                 onChange={(e) => setSelectedCity1(e.target.value)}\n//                 style={styles.selectDropdown}\n//                 disabled={cityList.length === 0}\n//               >\n//                 <option value=\"\">Select Location</option>\n//                 {cityList.map((city) => (\n//                   <option key={city} value={city}>\n//                     {city}\n//                   </option>\n//                 ))}\n//               </select>\n//             </div>\n//             <div style={styles.inputGroup}>\n//               <label style={styles.inputLabel}>Location 2:</label>\n//               <select\n//                 value={selectedCity2}\n//                 onChange={(e) => setSelectedCity2(e.target.value)}\n//                 style={styles.selectDropdown}\n//                 disabled={cityList.length === 0}\n//               >\n//                 <option value=\"\">Select Location</option>\n//                 {cityList.map((city) => (\n//                   <option key={city} value={city}>\n//                     {city}\n//                   </option>\n//                 ))}\n//               </select>\n//             </div>\n//             <button\n//               onClick={handleCitySelection}\n//               disabled={!selectedCity1 || !selectedCity2}\n//               style={{\n//                 ...styles.chartButton,\n//                 backgroundColor:\n//                   selectedCity1 && selectedCity2 ? '#28a745' : '#6c757d',\n//               }}\n//             >\n//               Compare\n//             </button>\n//           </div>\n\n//           {/* Chart Type Selection Section */}\n//           <div style={styles.section}>\n//             <h3 style={styles.sectionTitle}>Select Chart Type</h3>\n//             <div style={styles.chartOptions}>\n//               <button\n//                 onClick={() => setChartType('Bar')}\n//                 style={{\n//                   ...styles.chartButton,\n//                   ...(chartType === 'Bar' ? styles.chartButtonActive : {}),\n//                 }}\n//               >\n//                 Bar Chart\n//               </button>\n//               <button\n//                 onClick={() => setChartType('Pie')}\n//                 style={{\n//                   ...styles.chartButton,\n//                   ...(chartType === 'Pie' ? styles.chartButtonActive : {}),\n//                 }}\n//               >\n//                 Pie Chart\n//               </button>\n//               <button\n//                 onClick={() => setChartType('Doughnut')}\n//                 style={{\n//                   ...styles.chartButton,\n//                   ...(chartType === 'Doughnut' ? styles.chartButtonActive : {}),\n//                 }}\n//               >\n//                 Doughnut Chart\n//               </button>\n//               <button\n//                 onClick={() => setChartType('PolarArea')}\n//                 style={{\n//                   ...styles.chartButton,\n//                   ...(chartType === 'PolarArea' ? styles.chartButtonActive : {}),\n//                 }}\n//               >\n//                 PolarArea Chart\n//               </button>\n//             </div>\n//           </div>\n//         </div>\n\n//         {/* Chart Display Section */}\n//         {chartData && (\n//           <div style={styles.chartContainer}>\n//             <div style={styles.chartWrapper}>\n//               <div style={styles.chartContent}>\n//                 <h3>{chartType} Chart</h3>\n//                 {chartType === 'Bar' && <Bar data={chartData} options={chartOptions} />}\n//                 {chartType === 'Pie' && <Pie data={chartData} options={chartOptions} />}\n//                 {chartType === 'Doughnut' && (\n//                   <Doughnut data={chartData} options={chartOptions} />\n//                 )}\n//                 {chartType === 'PolarArea' && (\n//                   <PolarArea data={chartData} options={chartOptions} />\n//                 )}\n//               </div>\n//             </div>\n//           </div>\n//         )}\n//       </div>\n//     </div>\n//   );\n// };\n\n// export default MapView;\n// src/components/MapView.js\n\nimport React, { useEffect, useState, useCallback } from 'react';\nimport MapComponent from './MapComponent';\nimport Controls from './Controls';\nimport styles from './styles'; // Ensure this file exists and is properly configured\nimport preprocessData from './preprocessData'; // Ensure this file exists and is properly configured\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst MapView = () => {\n  _s();\n  // State Variables\n  const [geoData, setGeoData] = useState([]);\n  const [numericHeaders, setNumericHeaders] = useState([]);\n  const [stringHeaders, setStringHeaders] = useState([]);\n  const [selectedLocation, setSelectedLocation] = useState(null);\n  const [chartType, setChartType] = useState('Bar');\n  const [chartData, setChartData] = useState(null);\n  const [totalRows, setTotalRows] = useState(0);\n  const [totalColumns, setTotalColumns] = useState(0);\n  const [progress, setProgress] = useState({\n    upload: 0,\n    preprocess: 0,\n    geocode: 0\n  });\n  const [progressMessages, setProgressMessages] = useState({\n    upload: '',\n    preprocess: '',\n    geocode: ''\n  });\n  const [cityList, setCityList] = useState([]);\n  const [selectedCity1, setSelectedCity1] = useState('');\n  const [selectedCity2, setSelectedCity2] = useState('');\n  const [locationColumn, setLocationColumn] = useState('');\n  const [markersAdded, setMarkersAdded] = useState(false);\n\n  // Preprocess Data Function\n  const handlePreprocess = useCallback(async rawData => {\n    // Determine the location column dynamically\n    const possibleLocationColumns = ['LocationDesc', 'LocationAbbr', 'state', 'State', 'city', 'City', 'Country', 'Country Name', 'Country Code', 'Address', 'Place', 'GeoLocation'\n    // Include more possible location columns if necessary\n    ];\n    let detectedLocationColumn = possibleLocationColumns.find(col => rawData[0] && rawData[0].hasOwnProperty(col));\n\n    // If no location column is found, use 'locationID'\n    if (!detectedLocationColumn) {\n      detectedLocationColumn = 'locationID';\n    }\n    setLocationColumn(detectedLocationColumn);\n    console.log('Detected Location Column:', detectedLocationColumn);\n\n    // Preprocess data\n    const processedData = await preprocessData(rawData, setProgress, detectedLocationColumn);\n    if (!processedData || processedData.length === 0) {\n      alert('No valid data after preprocessing.');\n      return;\n    }\n    setGeoData(processedData);\n\n    // Identify numeric and string headers\n    if (processedData.length > 0) {\n      const headers = Object.keys(processedData[0]);\n      const numeric = [];\n      const strings = [];\n      headers.forEach(header => {\n        if (['latitude', 'longitude', 'GeoLocation', 'locationID'].includes(header)) return;\n        const isNumeric = processedData.every(item => {\n          const value = parseFloat(item[header]);\n          return !isNaN(value);\n        });\n        if (isNumeric) {\n          numeric.push(header);\n        } else {\n          strings.push(header);\n        }\n      });\n      setNumericHeaders(numeric);\n      setStringHeaders(strings);\n      setTotalRows(processedData.length);\n      setTotalColumns(headers.length);\n\n      // Extract unique locations for comparison\n      const uniqueLocations = [...new Set(processedData.map(item => item[detectedLocationColumn]).filter(Boolean))];\n      setCityList(uniqueLocations);\n    } else {\n      alert('No data available after filtering.');\n    }\n\n    // Reset markersAdded state when new data is uploaded\n    setMarkersAdded(false);\n  }, []);\n\n  // Handle Location Selection from Map\n  const handleLocationSelect = useCallback(locationData => {\n    // Clear city selections if a map marker is selected\n    setSelectedCity1('');\n    setSelectedCity2('');\n    if (selectedLocation && selectedLocation.locationID === locationData.locationID) {\n      setSelectedLocation(null); // Deselect\n      setChartData(null);\n    } else {\n      setSelectedLocation(locationData);\n      setChartData(null);\n    }\n  }, [selectedLocation]);\n\n  // Handle Location Comparison Selection\n  const handleCitySelection = useCallback(() => {\n    if (selectedCity1 && selectedCity2) {\n      const data1 = geoData.filter(item => item[locationColumn] === selectedCity1);\n      const data2 = geoData.filter(item => item[locationColumn] === selectedCity2);\n      if (data1.length === 0 || data2.length === 0) {\n        alert('One or both selected locations have no data.');\n        return;\n      }\n\n      // Aggregate data (e.g., average)\n      const aggregatedData1 = {};\n      const aggregatedData2 = {};\n      numericHeaders.forEach(header => {\n        const values1 = data1.map(item => parseFloat(item[header]) || 0);\n        const values2 = data2.map(item => parseFloat(item[header]) || 0);\n        const avg1 = values1.reduce((a, b) => a + b, 0) / (values1.length || 1);\n        const avg2 = values2.reduce((a, b) => a + b, 0) / (values2.length || 1);\n        aggregatedData1[header] = avg1;\n        aggregatedData2[header] = avg2;\n      });\n\n      // Normalize data for chart display (0.5% to 10%)\n      const dataMin = 0; // Minimum data value\n      const dataMax = Math.max(...Object.values(aggregatedData1), ...Object.values(aggregatedData2));\n      const range = dataMax - dataMin || 1; // Avoid division by zero\n\n      const normalizedData1 = {};\n      const normalizedData2 = {};\n      const actualData1 = {};\n      const actualData2 = {};\n      numericHeaders.forEach(header => {\n        normalizedData1[header] = (aggregatedData1[header] - dataMin) / range * 9.5 + 0.5;\n        normalizedData2[header] = (aggregatedData2[header] - dataMin) / range * 9.5 + 0.5;\n        actualData1[header] = aggregatedData1[header];\n        actualData2[header] = aggregatedData2[header];\n      });\n\n      // Prepare chart data\n      const labels = numericHeaders;\n      const dataSet = {\n        labels,\n        datasets: [{\n          label: selectedCity1,\n          data: numericHeaders.map(header => normalizedData1[header]),\n          actualValues: numericHeaders.map(header => actualData1[header]),\n          backgroundColor: 'rgba(255, 99, 132, 0.5)',\n          borderColor: 'rgba(255, 99, 132, 1)',\n          borderWidth: 1\n        }, {\n          label: selectedCity2,\n          data: numericHeaders.map(header => normalizedData2[header]),\n          actualValues: numericHeaders.map(header => actualData2[header]),\n          backgroundColor: 'rgba(54, 162, 235, 0.5)',\n          borderColor: 'rgba(54, 162, 235, 1)',\n          borderWidth: 1\n        }]\n      };\n      setChartData(dataSet);\n      setSelectedLocation(null); // Deselect any single location\n    }\n  }, [selectedCity1, selectedCity2, geoData, locationColumn, numericHeaders]);\n\n  // Generate Chart Data for Selected Location\n  const generateChartData = useCallback(() => {\n    if (selectedLocation) {\n      const locationValues = numericHeaders.map(header => ({\n        label: header,\n        value: parseFloat(selectedLocation[header]) || 0\n      }));\n\n      // Normalize data for chart display (0.5% to 10%)\n      const dataMin = 0; // Minimum data value\n      const dataMax = Math.max(...locationValues.map(item => item.value));\n      const range = dataMax - dataMin || 1; // Avoid division by zero\n\n      const normalizedValues = locationValues.map(item => ({\n        label: item.label,\n        normalizedValue: (item.value - dataMin) / range * 9.5 + 0.5,\n        actualValue: item.value // Keep the actual value\n      }));\n      setChartData({\n        labels: normalizedValues.map(item => item.label),\n        datasets: [{\n          label: getLocationLabel(selectedLocation),\n          data: normalizedValues.map(item => item.normalizedValue),\n          actualValues: normalizedValues.map(item => item.actualValue),\n          // Store actual values\n          backgroundColor: ['rgba(255, 99, 132, 0.5)', 'rgba(54, 162, 235, 0.5)', 'rgba(255, 206, 86, 0.5)', 'rgba(75, 192, 192, 0.5)', 'rgba(153, 102, 255, 0.5)', 'rgba(255, 159, 64, 0.5)'],\n          borderColor: ['rgba(255, 99, 132, 1)', 'rgba(54, 162, 235, 1)', 'rgba(255, 206, 86, 1)', 'rgba(75, 192, 192, 1)', 'rgba(153, 102, 255, 1)', 'rgba(255, 159, 64, 1)'],\n          borderWidth: 1\n        }]\n      });\n    }\n  }, [selectedLocation, numericHeaders, getLocationLabel]);\n\n  // Trigger Chart Data Generation\n  useEffect(() => {\n    generateChartData();\n  }, [generateChartData, chartType]);\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    style: styles.container,\n    children: [/*#__PURE__*/_jsxDEV(MapComponent, {\n      geoData: geoData,\n      selectedLocation: selectedLocation,\n      handleLocationSelect: handleLocationSelect,\n      markersAdded: markersAdded,\n      setMarkersAdded: setMarkersAdded\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 1038,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(Controls, {\n      progress: progress,\n      progressMessages: progressMessages,\n      handleFileUpload: handleFileUpload,\n      geoData: geoData,\n      totalRows: totalRows,\n      totalColumns: totalColumns,\n      numericHeaders: numericHeaders,\n      stringHeaders: stringHeaders,\n      cityList: cityList,\n      selectedCity1: selectedCity1,\n      selectedCity2: selectedCity2,\n      setSelectedCity1: setSelectedCity1,\n      setSelectedCity2: setSelectedCity2,\n      handleCitySelection: handleCitySelection,\n      chartType: chartType,\n      setChartType: setChartType,\n      chartData: chartData\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 1045,\n      columnNumber: 7\n    }, this)]\n  }, void 0, true, {\n    fileName: _jsxFileName,\n    lineNumber: 1037,\n    columnNumber: 5\n  }, this);\n};\n_s(MapView, \"aN19lR12psQsWDjFNwgWzg0mLpg=\");\n_c = MapView;\nexport default MapView;\nvar _c;\n$RefreshReg$(_c, \"MapView\");","map":{"version":3,"names":["React","useEffect","useState","useCallback","MapComponent","Controls","styles","preprocessData","jsxDEV","_jsxDEV","MapView","_s","geoData","setGeoData","numericHeaders","setNumericHeaders","stringHeaders","setStringHeaders","selectedLocation","setSelectedLocation","chartType","setChartType","chartData","setChartData","totalRows","setTotalRows","totalColumns","setTotalColumns","progress","setProgress","upload","preprocess","geocode","progressMessages","setProgressMessages","cityList","setCityList","selectedCity1","setSelectedCity1","selectedCity2","setSelectedCity2","locationColumn","setLocationColumn","markersAdded","setMarkersAdded","handlePreprocess","rawData","possibleLocationColumns","detectedLocationColumn","find","col","hasOwnProperty","console","log","processedData","length","alert","headers","Object","keys","numeric","strings","forEach","header","includes","isNumeric","every","item","value","parseFloat","isNaN","push","uniqueLocations","Set","map","filter","Boolean","handleLocationSelect","locationData","locationID","handleCitySelection","data1","data2","aggregatedData1","aggregatedData2","values1","values2","avg1","reduce","a","b","avg2","dataMin","dataMax","Math","max","values","range","normalizedData1","normalizedData2","actualData1","actualData2","labels","dataSet","datasets","label","data","actualValues","backgroundColor","borderColor","borderWidth","generateChartData","locationValues","normalizedValues","normalizedValue","actualValue","getLocationLabel","style","container","children","fileName","_jsxFileName","lineNumber","columnNumber","handleFileUpload","_c","$RefreshReg$"],"sources":["/Users/girishkumarpatchikoru/Desktop/projecthci/geovizproject/frontend/src/components/MapView.js"],"sourcesContent":["// // src/components/MapView.js\r\n\r\n// import React, { useEffect, useState, useCallback } from 'react';\r\n// import mapboxgl from 'mapbox-gl';\r\n// import Papa from 'papaparse';\r\n// import { Bar, Pie, Doughnut, PolarArea } from 'react-chartjs-2';\r\n// import {\r\n//   Chart as ChartJS,\r\n//   RadialLinearScale,\r\n//   CategoryScale,\r\n//   LinearScale,\r\n//   BarElement,\r\n//   ArcElement,\r\n//   Title,\r\n//   Tooltip,\r\n//   Legend,\r\n// } from 'chart.js';\r\n// import ChartDataLabels from 'chartjs-plugin-datalabels';\r\n// import { CircularProgressbar } from 'react-circular-progressbar';\r\n// import 'react-circular-progressbar/dist/styles.css';\r\n\r\n// import styles from './styles'; // Ensure this file exists and is properly configured\r\n// import preprocessData from './preprocessData'; // Ensure this file exists and is properly configured\r\n// import { MAPBOX_TOKEN } from './constants'; // Ensure this file exists and contains your Mapbox token\r\n// import blueMarkerIcon from '../assets/images/custom-marker-blue.png'; // Ensure these assets exist\r\n// import redMarkerIcon from '../assets/images/custom-marker-red.png';\r\n// import './marker.css'; // Ensure this CSS file exists for marker styling\r\n\r\n// // Register Chart.js components\r\n// ChartJS.register(\r\n//   RadialLinearScale,\r\n//   CategoryScale,\r\n//   LinearScale,\r\n//   BarElement,\r\n//   ArcElement,\r\n//   Title,\r\n//   Tooltip,\r\n//   Legend,\r\n//   ChartDataLabels\r\n// );\r\n\r\n// // Set Mapbox access token\r\n// mapboxgl.accessToken = MAPBOX_TOKEN;\r\n\r\n// const MapView = () => {\r\n//   // State Variables\r\n//   const [map, setMap] = useState(null);\r\n//   const [geoData, setGeoData] = useState([]);\r\n//   const [numericHeaders, setNumericHeaders] = useState([]);\r\n//   const [stringHeaders, setStringHeaders] = useState([]);\r\n//   const [selectedLocation, setSelectedLocation] = useState(null);\r\n//   const [chartType, setChartType] = useState('Bar');\r\n//   const [chartData, setChartData] = useState(null);\r\n//   const [totalRows, setTotalRows] = useState(0);\r\n//   const [totalColumns, setTotalColumns] = useState(0);\r\n//   const [markers, setMarkers] = useState([]);\r\n//   const [currentPopup, setCurrentPopup] = useState(null);\r\n//   const [progress, setProgress] = useState({\r\n//     upload: 0,\r\n//     preprocess: 0,\r\n//     geocode: 0,\r\n//   });\r\n//   const [progressMessages, setProgressMessages] = useState({\r\n//     upload: '',\r\n//     preprocess: '',\r\n//     geocode: '',\r\n//   });\r\n//   const [cityList, setCityList] = useState([]);\r\n//   const [selectedCity1, setSelectedCity1] = useState('');\r\n//   const [selectedCity2, setSelectedCity2] = useState('');\r\n//   const [locationColumn, setLocationColumn] = useState('');\r\n//   const [columnValueCounts, setColumnValueCounts] = useState({});\r\n//   const [markersAdded, setMarkersAdded] = useState(false);\r\n\r\n//   // Initialize Map\r\n//   useEffect(() => {\r\n//     const initializeMap = new mapboxgl.Map({\r\n//       container: 'map', // HTML container id\r\n//       style: 'mapbox://styles/mapbox/streets-v11', // style URL\r\n//       center: [-98.5795, 39.8283], // starting position [lng, lat] (center of USA)\r\n//       zoom: 3, // starting zoom\r\n//     });\r\n\r\n//     // Add navigation control (the +/- zoom buttons)\r\n//     const nav = new mapboxgl.NavigationControl();\r\n//     initializeMap.addControl(nav, 'top-right');\r\n\r\n//     setMap(initializeMap);\r\n\r\n//     // Clean up on unmount\r\n//     return () => initializeMap.remove();\r\n//   }, []);\r\n\r\n//   // Preprocess Data Function\r\n//   const handlePreprocess = useCallback(\r\n//     async (rawData) => {\r\n//       // Determine the location column dynamically\r\n//       const possibleLocationColumns = [\r\n//         'LocationDesc',\r\n//         'LocationAbbr',\r\n//         'state',\r\n//         'State',\r\n//         'city',\r\n//         'City',\r\n//         'Country',\r\n//         'Country Name',\r\n//         'Country Code',\r\n//         'Address',\r\n//         'Place',\r\n//         'GeoLocation',\r\n//         // Include more possible location columns if necessary\r\n//       ];\r\n//       let detectedLocationColumn = possibleLocationColumns.find(\r\n//         (col) => rawData[0] && rawData[0].hasOwnProperty(col)\r\n//       );\r\n\r\n//       // If no location column is found, use 'locationID'\r\n//       if (!detectedLocationColumn) {\r\n//         detectedLocationColumn = 'locationID';\r\n//       }\r\n\r\n//       setLocationColumn(detectedLocationColumn);\r\n//       console.log('Detected Location Column:', detectedLocationColumn);\r\n\r\n//       // Preprocess data\r\n//       const processedData = await preprocessData(\r\n//         rawData,\r\n//         setProgress,\r\n//         detectedLocationColumn\r\n//       );\r\n\r\n//       if (!processedData || processedData.length === 0) {\r\n//         alert('No valid data after preprocessing.');\r\n//         return;\r\n//       }\r\n\r\n//       setGeoData(processedData);\r\n\r\n//       // Identify numeric and string headers\r\n//       if (processedData.length > 0) {\r\n//         const headers = Object.keys(processedData[0]);\r\n//         const numeric = [];\r\n//         const strings = [];\r\n\r\n//         headers.forEach((header) => {\r\n//           if (\r\n//             ['latitude', 'longitude', 'GeoLocation', 'locationID'].includes(header)\r\n//           )\r\n//             return;\r\n\r\n//           const isNumeric = processedData.every((item) => {\r\n//             const value = parseFloat(item[header]);\r\n//             return !isNaN(value);\r\n//           });\r\n//           if (isNumeric) {\r\n//             numeric.push(header);\r\n//           } else {\r\n//             strings.push(header);\r\n//           }\r\n//         });\r\n\r\n//         setNumericHeaders(numeric);\r\n//         setStringHeaders(strings);\r\n\r\n//         setTotalRows(processedData.length);\r\n//         setTotalColumns(headers.length);\r\n\r\n//         // Count non-null values per column\r\n//         const columnCounts = {};\r\n//         headers.forEach((header) => {\r\n//           const count = processedData.filter(\r\n//             (item) => item[header] !== null && item[header] !== ''\r\n//           ).length;\r\n//           columnCounts[header] = count;\r\n//         });\r\n\r\n//         setColumnValueCounts(columnCounts);\r\n\r\n//         // Extract unique locations for comparison\r\n//         const uniqueLocations = [\r\n//           ...new Set(\r\n//             processedData.map((item) => item[detectedLocationColumn]).filter(Boolean)\r\n//           ),\r\n//         ];\r\n//         setCityList(uniqueLocations);\r\n//       } else {\r\n//         alert('No data available after filtering.');\r\n//       }\r\n\r\n//       // Reset markersAdded state when new data is uploaded\r\n//       setMarkersAdded(false);\r\n//     },\r\n//     []\r\n//   );\r\n\r\n//   // Generate a human-readable label for the location\r\n//   const getLocationLabel = (data) => {\r\n//     if (data[locationColumn]) return data[locationColumn];\r\n//     if (data.city) return data.city;\r\n//     if (data.state) return data.state;\r\n//     if (data.address) return data.address;\r\n//     return `Lat: ${parseFloat(data.latitude).toFixed(2)}, Lng: ${parseFloat(\r\n//       data.longitude\r\n//     ).toFixed(2)}`;\r\n//   };\r\n\r\n//   // Handle File Upload\r\n//   const handleFileUpload = (event) => {\r\n//     setProgress({\r\n//       upload: 0,\r\n//       preprocess: 0,\r\n//       geocode: 0,\r\n//     });\r\n//     setProgressMessages({\r\n//       upload: '',\r\n//       preprocess: '',\r\n//       geocode: '',\r\n//     });\r\n//     const file = event.target.files[0];\r\n//     if (file) {\r\n//       const fileExtension = file.name.split('.').pop().toLowerCase();\r\n\r\n//       if (fileExtension === 'json') {\r\n//         const reader = new FileReader();\r\n//         reader.onload = async (e) => {\r\n//           try {\r\n//             const data = JSON.parse(e.target.result);\r\n//             setProgress((prev) => ({ ...prev, upload: 100 }));\r\n//             setProgressMessages((prev) => ({\r\n//               ...prev,\r\n//               upload: 'Dataset uploaded successfully.',\r\n//             }));\r\n//             await handlePreprocess(data);\r\n//           } catch (error) {\r\n//             console.error('Invalid JSON format:', error);\r\n//             alert('Error: Uploaded file is not valid JSON.');\r\n//           }\r\n//         };\r\n//         reader.readAsText(file);\r\n//       } else if (fileExtension === 'csv') {\r\n//         Papa.parse(file, {\r\n//           header: true,\r\n//           skipEmptyLines: true,\r\n//           beforeFirstChunk: (chunk) => {\r\n//             // Handle datasets with metadata rows\r\n//             const lines = chunk.trim().split('\\n');\r\n//             const dataStartIndex = lines.findIndex(\r\n//               (line) =>\r\n//                 line.startsWith('Country Name') ||\r\n//                 line.startsWith('state') ||\r\n//                 line.startsWith('RowId')\r\n//             );\r\n//             if (dataStartIndex > 0) {\r\n//               return lines.slice(dataStartIndex).join('\\n');\r\n//             }\r\n//             return chunk;\r\n//           },\r\n//           complete: async (results) => {\r\n//             setProgress((prev) => ({ ...prev, upload: 100 }));\r\n//             setProgressMessages((prev) => ({\r\n//               ...prev,\r\n//               upload: 'Dataset uploaded successfully.',\r\n//             }));\r\n//             await handlePreprocess(results.data);\r\n//           },\r\n//           error: (error) => {\r\n//             console.error('CSV parsing error:', error);\r\n//             alert('Error: Failed to parse CSV file.');\r\n//           },\r\n//         });\r\n//       } else {\r\n//         alert('Please upload a valid JSON or CSV file.');\r\n//       }\r\n//     }\r\n//   };\r\n\r\n//   // Monitor Progress Updates\r\n//   useEffect(() => {\r\n//     if (progress.preprocess === 100) {\r\n//       setProgressMessages((prev) => ({\r\n//         ...prev,\r\n//         preprocess: 'Preprocessing completed.',\r\n//       }));\r\n//     }\r\n//   }, [progress.preprocess]);\r\n\r\n//   useEffect(() => {\r\n//     if (progress.geocode === 100) {\r\n//       setProgressMessages((prev) => ({\r\n//         ...prev,\r\n//         geocode: 'Locations marked on the map.',\r\n//       }));\r\n//     }\r\n//   }, [progress.geocode]);\r\n\r\n//   // Handle Location Selection from Map\r\n//   const handleLocationSelect = (locationData) => {\r\n//     // Clear city selections if a map marker is selected\r\n//     setSelectedCity1('');\r\n//     setSelectedCity2('');\r\n//     if (selectedLocation && selectedLocation.locationID === locationData.locationID) {\r\n//       setSelectedLocation(null); // Deselect\r\n//       setChartData(null);\r\n//       if (currentPopup) currentPopup.remove();\r\n//     } else {\r\n//       setSelectedLocation(locationData);\r\n//       setChartData(null);\r\n//       if (currentPopup) currentPopup.remove();\r\n//     }\r\n//   };\r\n\r\n//   // Handle Location Comparison Selection\r\n//   const handleCitySelection = () => {\r\n//     if (selectedCity1 && selectedCity2) {\r\n//       const data1 = geoData.filter(\r\n//         (item) => item[locationColumn] === selectedCity1\r\n//       );\r\n//       const data2 = geoData.filter(\r\n//         (item) => item[locationColumn] === selectedCity2\r\n//       );\r\n\r\n//       if (data1.length === 0 || data2.length === 0) {\r\n//         alert('One or both selected locations have no data.');\r\n//         return;\r\n//       }\r\n\r\n//       // Aggregate data (e.g., average)\r\n//       const aggregatedData1 = {};\r\n//       const aggregatedData2 = {};\r\n\r\n//       numericHeaders.forEach((header) => {\r\n//         const values1 = data1.map((item) => parseFloat(item[header]) || 0);\r\n//         const values2 = data2.map((item) => parseFloat(item[header]) || 0);\r\n\r\n//         const avg1 = values1.reduce((a, b) => a + b, 0) / (values1.length || 1);\r\n//         const avg2 = values2.reduce((a, b) => a + b, 0) / (values2.length || 1);\r\n\r\n//         aggregatedData1[header] = avg1;\r\n//         aggregatedData2[header] = avg2;\r\n//       });\r\n\r\n//       // Normalize data for chart display (0.5% to 10%)\r\n//       const dataMin = 0; // Minimum data value\r\n//       const dataMax = Math.max(\r\n//         ...Object.values(aggregatedData1),\r\n//         ...Object.values(aggregatedData2)\r\n//       );\r\n//       const range = dataMax - dataMin || 1; // Avoid division by zero\r\n\r\n//       const normalizedData1 = {};\r\n//       const normalizedData2 = {};\r\n//       const actualData1 = {};\r\n//       const actualData2 = {};\r\n\r\n//       numericHeaders.forEach((header) => {\r\n//         normalizedData1[header] =\r\n//           ((aggregatedData1[header] - dataMin) / range) * 9.5 + 0.5;\r\n//         normalizedData2[header] =\r\n//           ((aggregatedData2[header] - dataMin) / range) * 9.5 + 0.5;\r\n//         actualData1[header] = aggregatedData1[header];\r\n//         actualData2[header] = aggregatedData2[header];\r\n//       });\r\n\r\n//       // Prepare chart data\r\n//       const labels = numericHeaders;\r\n//       const dataSet = {\r\n//         labels,\r\n//         datasets: [\r\n//           {\r\n//             label: selectedCity1,\r\n//             data: numericHeaders.map((header) => normalizedData1[header]),\r\n//             actualValues: numericHeaders.map((header) => actualData1[header]),\r\n//             backgroundColor: 'rgba(255, 99, 132, 0.5)',\r\n//             borderColor: 'rgba(255, 99, 132, 1)',\r\n//             borderWidth: 1,\r\n//           },\r\n//           {\r\n//             label: selectedCity2,\r\n//             data: numericHeaders.map((header) => normalizedData2[header]),\r\n//             actualValues: numericHeaders.map((header) => actualData2[header]),\r\n//             backgroundColor: 'rgba(54, 162, 235, 0.5)',\r\n//             borderColor: 'rgba(54, 162, 235, 1)',\r\n//             borderWidth: 1,\r\n//           },\r\n//         ],\r\n//       };\r\n\r\n//       setChartData(dataSet);\r\n//       setSelectedLocation(null); // Deselect any single location\r\n//       if (currentPopup) currentPopup.remove();\r\n//     }\r\n//   };\r\n\r\n  \r\n//   const generateChartData = useCallback(() => {\r\n//     if (selectedLocation) {\r\n//       const locationValues = numericHeaders.map((header) => ({\r\n//         label: header,\r\n//         value: parseFloat(selectedLocation[header]) || 0,\r\n//       }));\r\n\r\n     \r\n//       const dataMin = 0; // Minimum data value\r\n//       const dataMax = Math.max(...locationValues.map((item) => item.value));\r\n//       const range = dataMax - dataMin || 1; // Avoid division by zero\r\n\r\n//       const normalizedValues = locationValues.map((item) => ({\r\n//         label: item.label,\r\n//         normalizedValue: ((item.value - dataMin) / range) * 9.5 + 0.5,\r\n//         actualValue: item.value, // Keep the actual value\r\n//       }));\r\n\r\n//       setChartData({\r\n//         labels: normalizedValues.map((item) => item.label),\r\n//         datasets: [\r\n//           {\r\n//             label: getLocationLabel(selectedLocation),\r\n//             data: normalizedValues.map((item) => item.normalizedValue),\r\n//             actualValues: normalizedValues.map((item) => item.actualValue), // Store actual values\r\n//             backgroundColor: [\r\n//               'rgba(255, 99, 132, 0.5)',\r\n//               'rgba(54, 162, 235, 0.5)',\r\n//               'rgba(255, 206, 86, 0.5)',\r\n//               'rgba(75, 192, 192, 0.5)',\r\n//               'rgba(153, 102, 255, 0.5)',\r\n//               'rgba(255, 159, 64, 0.5)',\r\n              \r\n//             ],\r\n//             borderColor: [\r\n//               'rgba(255, 99, 132, 1)',\r\n//               'rgba(54, 162, 235, 1)',\r\n//               'rgba(255, 206, 86, 1)',\r\n//               'rgba(75, 192, 192, 1)',\r\n//               'rgba(153, 102, 255, 1)',\r\n//               'rgba(255, 159, 64, 1)',\r\n             \r\n//             ],\r\n//             borderWidth: 1,\r\n//           },\r\n//         ],\r\n//       });\r\n//     }\r\n//   }, [selectedLocation, numericHeaders]);\r\n\r\n//   //Data Generation\r\n//   useEffect(() => {\r\n//     generateChartData();\r\n//   }, [generateChartData, chartType]);\r\n\r\n//   //Markers on Map\r\n//   const renderMarkers = useCallback(() => {\r\n//     if (map && geoData.length > 0) {\r\n//       // Remove existing markers\r\n//       markers.forEach((marker) => marker.remove());\r\n//       const newMarkers = [];\r\n\r\n//       geoData.forEach((data) => {\r\n//         const latitude = parseFloat(data.latitude);\r\n//         const longitude = parseFloat(data.longitude);\r\n\r\n//         if (!isNaN(latitude) && !isNaN(longitude)) {\r\n//           const el = document.createElement('div');\r\n//           el.className = 'marker';\r\n//           const isSelected = selectedLocation\r\n//             ? selectedLocation.locationID === data.locationID\r\n//             : false;\r\n//           const icon = isSelected ? redMarkerIcon : blueMarkerIcon;\r\n//           el.style.backgroundImage = `url(${icon})`;\r\n//           el.style.width = '30px';\r\n//           el.style.height = '30px';\r\n//           el.style.backgroundSize = 'contain';\r\n//           el.style.cursor = 'pointer';\r\n\r\n//           const marker = new mapboxgl.Marker(el)\r\n//             .setLngLat([longitude, latitude])\r\n//             .addTo(map);\r\n\r\n//           marker.getElement().addEventListener('click', () => {\r\n//             handleLocationSelect(data);\r\n//           });\r\n\r\n//           newMarkers.push(marker);\r\n//         }\r\n//       });\r\n//       setMarkers(newMarkers);\r\n//       setMarkersAdded(true); \r\n\r\n    \r\n//       setProgress((prev) => ({ ...prev, geocode: 100 }));\r\n//       setProgressMessages((prev) => ({\r\n//         ...prev,\r\n//         geocode: 'Locations marked on the map.',\r\n//       }));\r\n//     }\r\n//   }, [map, geoData, selectedLocation]);\r\n\r\n//   // Re-render markers when selectedLocation changes to update marker colors\r\n//   useEffect(() => {\r\n//     if (markersAdded) {\r\n//       renderMarkers();\r\n//     }\r\n//   }, [selectedLocation, renderMarkers, markersAdded]);\r\n\r\n//   // Chart Options\r\n//   const chartOptions = {\r\n//     responsive: true,\r\n//     maintainAspectRatio: false,\r\n//     scales:\r\n//       chartType === 'Bar'\r\n//         ? {\r\n//             y: {\r\n//               beginAtZero: true,\r\n//               min: 0.5,\r\n//               max: 10,\r\n//             },\r\n//           }\r\n//         : {},\r\n//     plugins: {\r\n//       legend: {\r\n//         position: 'top',\r\n//       },\r\n//       datalabels: {\r\n//         display: true,\r\n//         color: '#000',\r\n//         align: 'center', // Align labels to the center of the bars\r\n//         anchor: 'center',\r\n//         formatter: function (value, context) {\r\n//           const dataset = context.chart.data.datasets[context.datasetIndex];\r\n//           if (dataset.actualValues) {\r\n//             const actualValue = dataset.actualValues[context.dataIndex];\r\n//             return actualValue.toFixed(2); // Display actual value\r\n//           } else {\r\n//             return value.toFixed(2);\r\n//           }\r\n//         },\r\n//       },\r\n//       tooltip: {\r\n//         callbacks: {\r\n//           label: function (context) {\r\n//             const dataset = context.dataset;\r\n//             if (dataset.actualValues) {\r\n//               const actualValue = dataset.actualValues[context.dataIndex];\r\n//               return `${context.label}: ${actualValue.toFixed(2)}`;\r\n//             } else {\r\n//               return `${context.label}: ${context.parsed.y}`;\r\n//             }\r\n//           },\r\n//         },\r\n//       },\r\n//     },\r\n//   };\r\n\r\n//   return (\r\n//     <div style={styles.container}>\r\n//       {/* Map Container */}\r\n//       <div id=\"map\" style={styles.map}></div>\r\n\r\n//       {/* Sidebar */}\r\n//       <div style={styles.sidebar}>\r\n//         {/* Combined Controls Box */}\r\n//         <div style={styles.combinedBox}>\r\n//           {/* Progress Indicators */}\r\n//           <div style={styles.progressContainer}>\r\n//             <div style={styles.progressItem}>\r\n//               <CircularProgressbar\r\n//                 value={progress.upload}\r\n//                 text={`${Math.round(progress.upload)}%`}\r\n//                 styles={{\r\n//                   root: { width: '80px' },\r\n//                   text: { fontSize: '10px' },\r\n//                 }}\r\n//               />\r\n//               <div style={styles.progressMessage}>{progressMessages.upload}</div>\r\n//             </div>\r\n//             <div style={styles.progressItem}>\r\n//               <CircularProgressbar\r\n//                 value={progress.preprocess}\r\n//                 text={`${Math.round(progress.preprocess)}%`}\r\n//                 styles={{\r\n//                   root: { width: '80px' },\r\n//                   text: { fontSize: '10px' },\r\n//                 }}\r\n//               />\r\n//               <div style={styles.progressMessage}>{progressMessages.preprocess}</div>\r\n//             </div>\r\n//             <div style={styles.progressItem}>\r\n//               <CircularProgressbar\r\n//                 value={progress.geocode}\r\n//                 text={`${Math.round(progress.geocode)}%`}\r\n//                 styles={{\r\n//                   root: { width: '80px' },\r\n//                   text: { fontSize: '10px' },\r\n//                 }}\r\n//               />\r\n//               <div style={styles.progressMessage}>{progressMessages.geocode}</div>\r\n//             </div>\r\n//           </div>\r\n\r\n//           {/* Upload Data Section */}\r\n//           <div style={styles.section}>\r\n//             <h3 style={styles.sectionTitle}>Upload Data</h3>\r\n//             <input\r\n//               type=\"file\"\r\n//               accept=\".json, .csv\"\r\n//               onChange={handleFileUpload}\r\n//               style={styles.fileInput}\r\n//             />\r\n//           </div>\r\n\r\n//           {/* Mark Locations Button */}\r\n//           {geoData.length > 0 && !markersAdded && (\r\n//             <div style={styles.section}>\r\n//               <button\r\n//                 onClick={renderMarkers}\r\n//                 style={{\r\n//                   ...styles.chartButton,\r\n//                   backgroundColor: '#17a2b8',\r\n//                   width: '100%',\r\n//                 }}\r\n//               >\r\n//                 Mark Locations on Map\r\n//               </button>\r\n//             </div>\r\n//           )}\r\n\r\n//           {/* Dataset Details Section */}\r\n//           <div style={styles.section}>\r\n//             <h3 style={styles.sectionTitle}>Dataset Details</h3>\r\n//             {geoData.length > 0 ? (\r\n//               <div style={styles.datasetDetails}>\r\n//                 <p>\r\n//                   <strong>Rows:</strong> {totalRows}\r\n//                 </p>\r\n//                 <p>\r\n//                   <strong>Columns:</strong> {totalColumns}\r\n//                 </p>\r\n//                 <p>\r\n//                   <strong>Numeric Columns:</strong> {numericHeaders.join(', ')}\r\n//                 </p>\r\n//                 <p>\r\n//                   <strong>String Columns:</strong> {stringHeaders.join(', ')}\r\n//                 </p>\r\n//               </div>\r\n//             ) : (\r\n//               <p>No dataset uploaded yet.</p>\r\n//             )}\r\n//           </div>\r\n\r\n//           {/* Location Comparison Section */}\r\n//           <div style={styles.section}>\r\n//             <h3 style={styles.sectionTitle}>Compare Two Locations</h3>\r\n//             <div style={styles.inputGroup}>\r\n//               <label style={styles.inputLabel}>Location 1:</label>\r\n//               <select\r\n//                 value={selectedCity1}\r\n//                 onChange={(e) => setSelectedCity1(e.target.value)}\r\n//                 style={styles.selectDropdown}\r\n//                 disabled={cityList.length === 0}\r\n//               >\r\n//                 <option value=\"\">Select Location</option>\r\n//                 {cityList.map((city) => (\r\n//                   <option key={city} value={city}>\r\n//                     {city}\r\n//                   </option>\r\n//                 ))}\r\n//               </select>\r\n//             </div>\r\n//             <div style={styles.inputGroup}>\r\n//               <label style={styles.inputLabel}>Location 2:</label>\r\n//               <select\r\n//                 value={selectedCity2}\r\n//                 onChange={(e) => setSelectedCity2(e.target.value)}\r\n//                 style={styles.selectDropdown}\r\n//                 disabled={cityList.length === 0}\r\n//               >\r\n//                 <option value=\"\">Select Location</option>\r\n//                 {cityList.map((city) => (\r\n//                   <option key={city} value={city}>\r\n//                     {city}\r\n//                   </option>\r\n//                 ))}\r\n//               </select>\r\n//             </div>\r\n//             <button\r\n//               onClick={handleCitySelection}\r\n//               disabled={!selectedCity1 || !selectedCity2}\r\n//               style={{\r\n//                 ...styles.chartButton,\r\n//                 backgroundColor:\r\n//                   selectedCity1 && selectedCity2 ? '#28a745' : '#6c757d',\r\n//               }}\r\n//             >\r\n//               Compare\r\n//             </button>\r\n//           </div>\r\n\r\n//           {/* Chart Type Selection Section */}\r\n//           <div style={styles.section}>\r\n//             <h3 style={styles.sectionTitle}>Select Chart Type</h3>\r\n//             <div style={styles.chartOptions}>\r\n//               <button\r\n//                 onClick={() => setChartType('Bar')}\r\n//                 style={{\r\n//                   ...styles.chartButton,\r\n//                   ...(chartType === 'Bar' ? styles.chartButtonActive : {}),\r\n//                 }}\r\n//               >\r\n//                 Bar Chart\r\n//               </button>\r\n//               <button\r\n//                 onClick={() => setChartType('Pie')}\r\n//                 style={{\r\n//                   ...styles.chartButton,\r\n//                   ...(chartType === 'Pie' ? styles.chartButtonActive : {}),\r\n//                 }}\r\n//               >\r\n//                 Pie Chart\r\n//               </button>\r\n//               <button\r\n//                 onClick={() => setChartType('Doughnut')}\r\n//                 style={{\r\n//                   ...styles.chartButton,\r\n//                   ...(chartType === 'Doughnut' ? styles.chartButtonActive : {}),\r\n//                 }}\r\n//               >\r\n//                 Doughnut Chart\r\n//               </button>\r\n//               <button\r\n//                 onClick={() => setChartType('PolarArea')}\r\n//                 style={{\r\n//                   ...styles.chartButton,\r\n//                   ...(chartType === 'PolarArea' ? styles.chartButtonActive : {}),\r\n//                 }}\r\n//               >\r\n//                 PolarArea Chart\r\n//               </button>\r\n//             </div>\r\n//           </div>\r\n//         </div>\r\n\r\n//         {/* Chart Display Section */}\r\n//         {chartData && (\r\n//           <div style={styles.chartContainer}>\r\n//             <div style={styles.chartWrapper}>\r\n//               <div style={styles.chartContent}>\r\n//                 <h3>{chartType} Chart</h3>\r\n//                 {chartType === 'Bar' && <Bar data={chartData} options={chartOptions} />}\r\n//                 {chartType === 'Pie' && <Pie data={chartData} options={chartOptions} />}\r\n//                 {chartType === 'Doughnut' && (\r\n//                   <Doughnut data={chartData} options={chartOptions} />\r\n//                 )}\r\n//                 {chartType === 'PolarArea' && (\r\n//                   <PolarArea data={chartData} options={chartOptions} />\r\n//                 )}\r\n//               </div>\r\n//             </div>\r\n//           </div>\r\n//         )}\r\n//       </div>\r\n//     </div>\r\n//   );\r\n// };\r\n\r\n// export default MapView;\r\n// src/components/MapView.js\r\n\r\nimport React, { useEffect, useState, useCallback } from 'react';\r\nimport MapComponent from './MapComponent';\r\nimport Controls from './Controls';\r\nimport styles from './styles'; // Ensure this file exists and is properly configured\r\nimport preprocessData from './preprocessData'; // Ensure this file exists and is properly configured\r\n\r\nconst MapView = () => {\r\n  // State Variables\r\n  const [geoData, setGeoData] = useState([]);\r\n  const [numericHeaders, setNumericHeaders] = useState([]);\r\n  const [stringHeaders, setStringHeaders] = useState([]);\r\n  const [selectedLocation, setSelectedLocation] = useState(null);\r\n  const [chartType, setChartType] = useState('Bar');\r\n  const [chartData, setChartData] = useState(null);\r\n  const [totalRows, setTotalRows] = useState(0);\r\n  const [totalColumns, setTotalColumns] = useState(0);\r\n  const [progress, setProgress] = useState({\r\n    upload: 0,\r\n    preprocess: 0,\r\n    geocode: 0,\r\n  });\r\n  const [progressMessages, setProgressMessages] = useState({\r\n    upload: '',\r\n    preprocess: '',\r\n    geocode: '',\r\n  });\r\n  const [cityList, setCityList] = useState([]);\r\n  const [selectedCity1, setSelectedCity1] = useState('');\r\n  const [selectedCity2, setSelectedCity2] = useState('');\r\n  const [locationColumn, setLocationColumn] = useState('');\r\n  const [markersAdded, setMarkersAdded] = useState(false);\r\n\r\n  // Preprocess Data Function\r\n  const handlePreprocess = useCallback(async (rawData) => {\r\n    // Determine the location column dynamically\r\n    const possibleLocationColumns = [\r\n      'LocationDesc',\r\n      'LocationAbbr',\r\n      'state',\r\n      'State',\r\n      'city',\r\n      'City',\r\n      'Country',\r\n      'Country Name',\r\n      'Country Code',\r\n      'Address',\r\n      'Place',\r\n      'GeoLocation',\r\n      // Include more possible location columns if necessary\r\n    ];\r\n    let detectedLocationColumn = possibleLocationColumns.find(\r\n      (col) => rawData[0] && rawData[0].hasOwnProperty(col)\r\n    );\r\n\r\n    // If no location column is found, use 'locationID'\r\n    if (!detectedLocationColumn) {\r\n      detectedLocationColumn = 'locationID';\r\n    }\r\n\r\n    setLocationColumn(detectedLocationColumn);\r\n    console.log('Detected Location Column:', detectedLocationColumn);\r\n\r\n    // Preprocess data\r\n    const processedData = await preprocessData(\r\n      rawData,\r\n      setProgress,\r\n      detectedLocationColumn\r\n    );\r\n\r\n    if (!processedData || processedData.length === 0) {\r\n      alert('No valid data after preprocessing.');\r\n      return;\r\n    }\r\n\r\n    setGeoData(processedData);\r\n\r\n    // Identify numeric and string headers\r\n    if (processedData.length > 0) {\r\n      const headers = Object.keys(processedData[0]);\r\n      const numeric = [];\r\n      const strings = [];\r\n\r\n      headers.forEach((header) => {\r\n        if (\r\n          ['latitude', 'longitude', 'GeoLocation', 'locationID'].includes(header)\r\n        )\r\n          return;\r\n\r\n        const isNumeric = processedData.every((item) => {\r\n          const value = parseFloat(item[header]);\r\n          return !isNaN(value);\r\n        });\r\n        if (isNumeric) {\r\n          numeric.push(header);\r\n        } else {\r\n          strings.push(header);\r\n        }\r\n      });\r\n\r\n      setNumericHeaders(numeric);\r\n      setStringHeaders(strings);\r\n\r\n      setTotalRows(processedData.length);\r\n      setTotalColumns(headers.length);\r\n\r\n      // Extract unique locations for comparison\r\n      const uniqueLocations = [\r\n        ...new Set(\r\n          processedData.map((item) => item[detectedLocationColumn]).filter(Boolean)\r\n        ),\r\n      ];\r\n      setCityList(uniqueLocations);\r\n    } else {\r\n      alert('No data available after filtering.');\r\n    }\r\n\r\n    // Reset markersAdded state when new data is uploaded\r\n    setMarkersAdded(false);\r\n  }, []);\r\n\r\n  // Handle Location Selection from Map\r\n  const handleLocationSelect = useCallback((locationData) => {\r\n    // Clear city selections if a map marker is selected\r\n    setSelectedCity1('');\r\n    setSelectedCity2('');\r\n    if (selectedLocation && selectedLocation.locationID === locationData.locationID) {\r\n      setSelectedLocation(null); // Deselect\r\n      setChartData(null);\r\n    } else {\r\n      setSelectedLocation(locationData);\r\n      setChartData(null);\r\n    }\r\n  }, [selectedLocation]);\r\n\r\n  // Handle Location Comparison Selection\r\n  const handleCitySelection = useCallback(() => {\r\n    if (selectedCity1 && selectedCity2) {\r\n      const data1 = geoData.filter(\r\n        (item) => item[locationColumn] === selectedCity1\r\n      );\r\n      const data2 = geoData.filter(\r\n        (item) => item[locationColumn] === selectedCity2\r\n      );\r\n\r\n      if (data1.length === 0 || data2.length === 0) {\r\n        alert('One or both selected locations have no data.');\r\n        return;\r\n      }\r\n\r\n      // Aggregate data (e.g., average)\r\n      const aggregatedData1 = {};\r\n      const aggregatedData2 = {};\r\n\r\n      numericHeaders.forEach((header) => {\r\n        const values1 = data1.map((item) => parseFloat(item[header]) || 0);\r\n        const values2 = data2.map((item) => parseFloat(item[header]) || 0);\r\n\r\n        const avg1 = values1.reduce((a, b) => a + b, 0) / (values1.length || 1);\r\n        const avg2 = values2.reduce((a, b) => a + b, 0) / (values2.length || 1);\r\n\r\n        aggregatedData1[header] = avg1;\r\n        aggregatedData2[header] = avg2;\r\n      });\r\n\r\n      // Normalize data for chart display (0.5% to 10%)\r\n      const dataMin = 0; // Minimum data value\r\n      const dataMax = Math.max(\r\n        ...Object.values(aggregatedData1),\r\n        ...Object.values(aggregatedData2)\r\n      );\r\n      const range = dataMax - dataMin || 1; // Avoid division by zero\r\n\r\n      const normalizedData1 = {};\r\n      const normalizedData2 = {};\r\n      const actualData1 = {};\r\n      const actualData2 = {};\r\n\r\n      numericHeaders.forEach((header) => {\r\n        normalizedData1[header] =\r\n          ((aggregatedData1[header] - dataMin) / range) * 9.5 + 0.5;\r\n        normalizedData2[header] =\r\n          ((aggregatedData2[header] - dataMin) / range) * 9.5 + 0.5;\r\n        actualData1[header] = aggregatedData1[header];\r\n        actualData2[header] = aggregatedData2[header];\r\n      });\r\n\r\n      // Prepare chart data\r\n      const labels = numericHeaders;\r\n      const dataSet = {\r\n        labels,\r\n        datasets: [\r\n          {\r\n            label: selectedCity1,\r\n            data: numericHeaders.map((header) => normalizedData1[header]),\r\n            actualValues: numericHeaders.map((header) => actualData1[header]),\r\n            backgroundColor: 'rgba(255, 99, 132, 0.5)',\r\n            borderColor: 'rgba(255, 99, 132, 1)',\r\n            borderWidth: 1,\r\n          },\r\n          {\r\n            label: selectedCity2,\r\n            data: numericHeaders.map((header) => normalizedData2[header]),\r\n            actualValues: numericHeaders.map((header) => actualData2[header]),\r\n            backgroundColor: 'rgba(54, 162, 235, 0.5)',\r\n            borderColor: 'rgba(54, 162, 235, 1)',\r\n            borderWidth: 1,\r\n          },\r\n        ],\r\n      };\r\n\r\n      setChartData(dataSet);\r\n      setSelectedLocation(null); // Deselect any single location\r\n    }\r\n  }, [selectedCity1, selectedCity2, geoData, locationColumn, numericHeaders]);\r\n\r\n  // Generate Chart Data for Selected Location\r\n  const generateChartData = useCallback(() => {\r\n    if (selectedLocation) {\r\n      const locationValues = numericHeaders.map((header) => ({\r\n        label: header,\r\n        value: parseFloat(selectedLocation[header]) || 0,\r\n      }));\r\n\r\n      // Normalize data for chart display (0.5% to 10%)\r\n      const dataMin = 0; // Minimum data value\r\n      const dataMax = Math.max(...locationValues.map((item) => item.value));\r\n      const range = dataMax - dataMin || 1; // Avoid division by zero\r\n\r\n      const normalizedValues = locationValues.map((item) => ({\r\n        label: item.label,\r\n        normalizedValue: ((item.value - dataMin) / range) * 9.5 + 0.5,\r\n        actualValue: item.value, // Keep the actual value\r\n      }));\r\n\r\n      setChartData({\r\n        labels: normalizedValues.map((item) => item.label),\r\n        datasets: [\r\n          {\r\n            label: getLocationLabel(selectedLocation),\r\n            data: normalizedValues.map((item) => item.normalizedValue),\r\n            actualValues: normalizedValues.map((item) => item.actualValue), // Store actual values\r\n            backgroundColor: [\r\n              'rgba(255, 99, 132, 0.5)',\r\n              'rgba(54, 162, 235, 0.5)',\r\n              'rgba(255, 206, 86, 0.5)',\r\n              'rgba(75, 192, 192, 0.5)',\r\n              'rgba(153, 102, 255, 0.5)',\r\n              'rgba(255, 159, 64, 0.5)',\r\n            ],\r\n            borderColor: [\r\n              'rgba(255, 99, 132, 1)',\r\n              'rgba(54, 162, 235, 1)',\r\n              'rgba(255, 206, 86, 1)',\r\n              'rgba(75, 192, 192, 1)',\r\n              'rgba(153, 102, 255, 1)',\r\n              'rgba(255, 159, 64, 1)',\r\n            ],\r\n            borderWidth: 1,\r\n          },\r\n        ],\r\n      });\r\n    }\r\n  }, [selectedLocation, numericHeaders, getLocationLabel]);\r\n\r\n  // Trigger Chart Data Generation\r\n  useEffect(() => {\r\n    generateChartData();\r\n  }, [generateChartData, chartType]);\r\n\r\n  return (\r\n    <div style={styles.container}>\r\n      <MapComponent\r\n        geoData={geoData}\r\n        selectedLocation={selectedLocation}\r\n        handleLocationSelect={handleLocationSelect}\r\n        markersAdded={markersAdded}\r\n        setMarkersAdded={setMarkersAdded}\r\n      />\r\n      <Controls\r\n        progress={progress}\r\n        progressMessages={progressMessages}\r\n        handleFileUpload={handleFileUpload}\r\n        geoData={geoData}\r\n        totalRows={totalRows}\r\n        totalColumns={totalColumns}\r\n        numericHeaders={numericHeaders}\r\n        stringHeaders={stringHeaders}\r\n        cityList={cityList}\r\n        selectedCity1={selectedCity1}\r\n        selectedCity2={selectedCity2}\r\n        setSelectedCity1={setSelectedCity1}\r\n        setSelectedCity2={setSelectedCity2}\r\n        handleCitySelection={handleCitySelection}\r\n        chartType={chartType}\r\n        setChartType={setChartType}\r\n        chartData={chartData}\r\n      />\r\n    </div>\r\n  );\r\n};\r\n\r\nexport default MapView;\r\n"],"mappings":";;AAAA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAGA;AACA;AACA;AACA;AACA;AACA;;AAGA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,OAAOA,KAAK,IAAIC,SAAS,EAAEC,QAAQ,EAAEC,WAAW,QAAQ,OAAO;AAC/D,OAAOC,YAAY,MAAM,gBAAgB;AACzC,OAAOC,QAAQ,MAAM,YAAY;AACjC,OAAOC,MAAM,MAAM,UAAU,CAAC,CAAC;AAC/B,OAAOC,cAAc,MAAM,kBAAkB,CAAC,CAAC;AAAA,SAAAC,MAAA,IAAAC,OAAA;AAE/C,MAAMC,OAAO,GAAGA,CAAA,KAAM;EAAAC,EAAA;EACpB;EACA,MAAM,CAACC,OAAO,EAAEC,UAAU,CAAC,GAAGX,QAAQ,CAAC,EAAE,CAAC;EAC1C,MAAM,CAACY,cAAc,EAAEC,iBAAiB,CAAC,GAAGb,QAAQ,CAAC,EAAE,CAAC;EACxD,MAAM,CAACc,aAAa,EAAEC,gBAAgB,CAAC,GAAGf,QAAQ,CAAC,EAAE,CAAC;EACtD,MAAM,CAACgB,gBAAgB,EAAEC,mBAAmB,CAAC,GAAGjB,QAAQ,CAAC,IAAI,CAAC;EAC9D,MAAM,CAACkB,SAAS,EAAEC,YAAY,CAAC,GAAGnB,QAAQ,CAAC,KAAK,CAAC;EACjD,MAAM,CAACoB,SAAS,EAAEC,YAAY,CAAC,GAAGrB,QAAQ,CAAC,IAAI,CAAC;EAChD,MAAM,CAACsB,SAAS,EAAEC,YAAY,CAAC,GAAGvB,QAAQ,CAAC,CAAC,CAAC;EAC7C,MAAM,CAACwB,YAAY,EAAEC,eAAe,CAAC,GAAGzB,QAAQ,CAAC,CAAC,CAAC;EACnD,MAAM,CAAC0B,QAAQ,EAAEC,WAAW,CAAC,GAAG3B,QAAQ,CAAC;IACvC4B,MAAM,EAAE,CAAC;IACTC,UAAU,EAAE,CAAC;IACbC,OAAO,EAAE;EACX,CAAC,CAAC;EACF,MAAM,CAACC,gBAAgB,EAAEC,mBAAmB,CAAC,GAAGhC,QAAQ,CAAC;IACvD4B,MAAM,EAAE,EAAE;IACVC,UAAU,EAAE,EAAE;IACdC,OAAO,EAAE;EACX,CAAC,CAAC;EACF,MAAM,CAACG,QAAQ,EAAEC,WAAW,CAAC,GAAGlC,QAAQ,CAAC,EAAE,CAAC;EAC5C,MAAM,CAACmC,aAAa,EAAEC,gBAAgB,CAAC,GAAGpC,QAAQ,CAAC,EAAE,CAAC;EACtD,MAAM,CAACqC,aAAa,EAAEC,gBAAgB,CAAC,GAAGtC,QAAQ,CAAC,EAAE,CAAC;EACtD,MAAM,CAACuC,cAAc,EAAEC,iBAAiB,CAAC,GAAGxC,QAAQ,CAAC,EAAE,CAAC;EACxD,MAAM,CAACyC,YAAY,EAAEC,eAAe,CAAC,GAAG1C,QAAQ,CAAC,KAAK,CAAC;;EAEvD;EACA,MAAM2C,gBAAgB,GAAG1C,WAAW,CAAC,MAAO2C,OAAO,IAAK;IACtD;IACA,MAAMC,uBAAuB,GAAG,CAC9B,cAAc,EACd,cAAc,EACd,OAAO,EACP,OAAO,EACP,MAAM,EACN,MAAM,EACN,SAAS,EACT,cAAc,EACd,cAAc,EACd,SAAS,EACT,OAAO,EACP;IACA;IAAA,CACD;IACD,IAAIC,sBAAsB,GAAGD,uBAAuB,CAACE,IAAI,CACtDC,GAAG,IAAKJ,OAAO,CAAC,CAAC,CAAC,IAAIA,OAAO,CAAC,CAAC,CAAC,CAACK,cAAc,CAACD,GAAG,CACtD,CAAC;;IAED;IACA,IAAI,CAACF,sBAAsB,EAAE;MAC3BA,sBAAsB,GAAG,YAAY;IACvC;IAEAN,iBAAiB,CAACM,sBAAsB,CAAC;IACzCI,OAAO,CAACC,GAAG,CAAC,2BAA2B,EAAEL,sBAAsB,CAAC;;IAEhE;IACA,MAAMM,aAAa,GAAG,MAAM/C,cAAc,CACxCuC,OAAO,EACPjB,WAAW,EACXmB,sBACF,CAAC;IAED,IAAI,CAACM,aAAa,IAAIA,aAAa,CAACC,MAAM,KAAK,CAAC,EAAE;MAChDC,KAAK,CAAC,oCAAoC,CAAC;MAC3C;IACF;IAEA3C,UAAU,CAACyC,aAAa,CAAC;;IAEzB;IACA,IAAIA,aAAa,CAACC,MAAM,GAAG,CAAC,EAAE;MAC5B,MAAME,OAAO,GAAGC,MAAM,CAACC,IAAI,CAACL,aAAa,CAAC,CAAC,CAAC,CAAC;MAC7C,MAAMM,OAAO,GAAG,EAAE;MAClB,MAAMC,OAAO,GAAG,EAAE;MAElBJ,OAAO,CAACK,OAAO,CAAEC,MAAM,IAAK;QAC1B,IACE,CAAC,UAAU,EAAE,WAAW,EAAE,aAAa,EAAE,YAAY,CAAC,CAACC,QAAQ,CAACD,MAAM,CAAC,EAEvE;QAEF,MAAME,SAAS,GAAGX,aAAa,CAACY,KAAK,CAAEC,IAAI,IAAK;UAC9C,MAAMC,KAAK,GAAGC,UAAU,CAACF,IAAI,CAACJ,MAAM,CAAC,CAAC;UACtC,OAAO,CAACO,KAAK,CAACF,KAAK,CAAC;QACtB,CAAC,CAAC;QACF,IAAIH,SAAS,EAAE;UACbL,OAAO,CAACW,IAAI,CAACR,MAAM,CAAC;QACtB,CAAC,MAAM;UACLF,OAAO,CAACU,IAAI,CAACR,MAAM,CAAC;QACtB;MACF,CAAC,CAAC;MAEFhD,iBAAiB,CAAC6C,OAAO,CAAC;MAC1B3C,gBAAgB,CAAC4C,OAAO,CAAC;MAEzBpC,YAAY,CAAC6B,aAAa,CAACC,MAAM,CAAC;MAClC5B,eAAe,CAAC8B,OAAO,CAACF,MAAM,CAAC;;MAE/B;MACA,MAAMiB,eAAe,GAAG,CACtB,GAAG,IAAIC,GAAG,CACRnB,aAAa,CAACoB,GAAG,CAAEP,IAAI,IAAKA,IAAI,CAACnB,sBAAsB,CAAC,CAAC,CAAC2B,MAAM,CAACC,OAAO,CAC1E,CAAC,CACF;MACDxC,WAAW,CAACoC,eAAe,CAAC;IAC9B,CAAC,MAAM;MACLhB,KAAK,CAAC,oCAAoC,CAAC;IAC7C;;IAEA;IACAZ,eAAe,CAAC,KAAK,CAAC;EACxB,CAAC,EAAE,EAAE,CAAC;;EAEN;EACA,MAAMiC,oBAAoB,GAAG1E,WAAW,CAAE2E,YAAY,IAAK;IACzD;IACAxC,gBAAgB,CAAC,EAAE,CAAC;IACpBE,gBAAgB,CAAC,EAAE,CAAC;IACpB,IAAItB,gBAAgB,IAAIA,gBAAgB,CAAC6D,UAAU,KAAKD,YAAY,CAACC,UAAU,EAAE;MAC/E5D,mBAAmB,CAAC,IAAI,CAAC,CAAC,CAAC;MAC3BI,YAAY,CAAC,IAAI,CAAC;IACpB,CAAC,MAAM;MACLJ,mBAAmB,CAAC2D,YAAY,CAAC;MACjCvD,YAAY,CAAC,IAAI,CAAC;IACpB;EACF,CAAC,EAAE,CAACL,gBAAgB,CAAC,CAAC;;EAEtB;EACA,MAAM8D,mBAAmB,GAAG7E,WAAW,CAAC,MAAM;IAC5C,IAAIkC,aAAa,IAAIE,aAAa,EAAE;MAClC,MAAM0C,KAAK,GAAGrE,OAAO,CAAC+D,MAAM,CACzBR,IAAI,IAAKA,IAAI,CAAC1B,cAAc,CAAC,KAAKJ,aACrC,CAAC;MACD,MAAM6C,KAAK,GAAGtE,OAAO,CAAC+D,MAAM,CACzBR,IAAI,IAAKA,IAAI,CAAC1B,cAAc,CAAC,KAAKF,aACrC,CAAC;MAED,IAAI0C,KAAK,CAAC1B,MAAM,KAAK,CAAC,IAAI2B,KAAK,CAAC3B,MAAM,KAAK,CAAC,EAAE;QAC5CC,KAAK,CAAC,8CAA8C,CAAC;QACrD;MACF;;MAEA;MACA,MAAM2B,eAAe,GAAG,CAAC,CAAC;MAC1B,MAAMC,eAAe,GAAG,CAAC,CAAC;MAE1BtE,cAAc,CAACgD,OAAO,CAAEC,MAAM,IAAK;QACjC,MAAMsB,OAAO,GAAGJ,KAAK,CAACP,GAAG,CAAEP,IAAI,IAAKE,UAAU,CAACF,IAAI,CAACJ,MAAM,CAAC,CAAC,IAAI,CAAC,CAAC;QAClE,MAAMuB,OAAO,GAAGJ,KAAK,CAACR,GAAG,CAAEP,IAAI,IAAKE,UAAU,CAACF,IAAI,CAACJ,MAAM,CAAC,CAAC,IAAI,CAAC,CAAC;QAElE,MAAMwB,IAAI,GAAGF,OAAO,CAACG,MAAM,CAAC,CAACC,CAAC,EAAEC,CAAC,KAAKD,CAAC,GAAGC,CAAC,EAAE,CAAC,CAAC,IAAIL,OAAO,CAAC9B,MAAM,IAAI,CAAC,CAAC;QACvE,MAAMoC,IAAI,GAAGL,OAAO,CAACE,MAAM,CAAC,CAACC,CAAC,EAAEC,CAAC,KAAKD,CAAC,GAAGC,CAAC,EAAE,CAAC,CAAC,IAAIJ,OAAO,CAAC/B,MAAM,IAAI,CAAC,CAAC;QAEvE4B,eAAe,CAACpB,MAAM,CAAC,GAAGwB,IAAI;QAC9BH,eAAe,CAACrB,MAAM,CAAC,GAAG4B,IAAI;MAChC,CAAC,CAAC;;MAEF;MACA,MAAMC,OAAO,GAAG,CAAC,CAAC,CAAC;MACnB,MAAMC,OAAO,GAAGC,IAAI,CAACC,GAAG,CACtB,GAAGrC,MAAM,CAACsC,MAAM,CAACb,eAAe,CAAC,EACjC,GAAGzB,MAAM,CAACsC,MAAM,CAACZ,eAAe,CAClC,CAAC;MACD,MAAMa,KAAK,GAAGJ,OAAO,GAAGD,OAAO,IAAI,CAAC,CAAC,CAAC;;MAEtC,MAAMM,eAAe,GAAG,CAAC,CAAC;MAC1B,MAAMC,eAAe,GAAG,CAAC,CAAC;MAC1B,MAAMC,WAAW,GAAG,CAAC,CAAC;MACtB,MAAMC,WAAW,GAAG,CAAC,CAAC;MAEtBvF,cAAc,CAACgD,OAAO,CAAEC,MAAM,IAAK;QACjCmC,eAAe,CAACnC,MAAM,CAAC,GACpB,CAACoB,eAAe,CAACpB,MAAM,CAAC,GAAG6B,OAAO,IAAIK,KAAK,GAAI,GAAG,GAAG,GAAG;QAC3DE,eAAe,CAACpC,MAAM,CAAC,GACpB,CAACqB,eAAe,CAACrB,MAAM,CAAC,GAAG6B,OAAO,IAAIK,KAAK,GAAI,GAAG,GAAG,GAAG;QAC3DG,WAAW,CAACrC,MAAM,CAAC,GAAGoB,eAAe,CAACpB,MAAM,CAAC;QAC7CsC,WAAW,CAACtC,MAAM,CAAC,GAAGqB,eAAe,CAACrB,MAAM,CAAC;MAC/C,CAAC,CAAC;;MAEF;MACA,MAAMuC,MAAM,GAAGxF,cAAc;MAC7B,MAAMyF,OAAO,GAAG;QACdD,MAAM;QACNE,QAAQ,EAAE,CACR;UACEC,KAAK,EAAEpE,aAAa;UACpBqE,IAAI,EAAE5F,cAAc,CAAC4D,GAAG,CAAEX,MAAM,IAAKmC,eAAe,CAACnC,MAAM,CAAC,CAAC;UAC7D4C,YAAY,EAAE7F,cAAc,CAAC4D,GAAG,CAAEX,MAAM,IAAKqC,WAAW,CAACrC,MAAM,CAAC,CAAC;UACjE6C,eAAe,EAAE,yBAAyB;UAC1CC,WAAW,EAAE,uBAAuB;UACpCC,WAAW,EAAE;QACf,CAAC,EACD;UACEL,KAAK,EAAElE,aAAa;UACpBmE,IAAI,EAAE5F,cAAc,CAAC4D,GAAG,CAAEX,MAAM,IAAKoC,eAAe,CAACpC,MAAM,CAAC,CAAC;UAC7D4C,YAAY,EAAE7F,cAAc,CAAC4D,GAAG,CAAEX,MAAM,IAAKsC,WAAW,CAACtC,MAAM,CAAC,CAAC;UACjE6C,eAAe,EAAE,yBAAyB;UAC1CC,WAAW,EAAE,uBAAuB;UACpCC,WAAW,EAAE;QACf,CAAC;MAEL,CAAC;MAEDvF,YAAY,CAACgF,OAAO,CAAC;MACrBpF,mBAAmB,CAAC,IAAI,CAAC,CAAC,CAAC;IAC7B;EACF,CAAC,EAAE,CAACkB,aAAa,EAAEE,aAAa,EAAE3B,OAAO,EAAE6B,cAAc,EAAE3B,cAAc,CAAC,CAAC;;EAE3E;EACA,MAAMiG,iBAAiB,GAAG5G,WAAW,CAAC,MAAM;IAC1C,IAAIe,gBAAgB,EAAE;MACpB,MAAM8F,cAAc,GAAGlG,cAAc,CAAC4D,GAAG,CAAEX,MAAM,KAAM;QACrD0C,KAAK,EAAE1C,MAAM;QACbK,KAAK,EAAEC,UAAU,CAACnD,gBAAgB,CAAC6C,MAAM,CAAC,CAAC,IAAI;MACjD,CAAC,CAAC,CAAC;;MAEH;MACA,MAAM6B,OAAO,GAAG,CAAC,CAAC,CAAC;MACnB,MAAMC,OAAO,GAAGC,IAAI,CAACC,GAAG,CAAC,GAAGiB,cAAc,CAACtC,GAAG,CAAEP,IAAI,IAAKA,IAAI,CAACC,KAAK,CAAC,CAAC;MACrE,MAAM6B,KAAK,GAAGJ,OAAO,GAAGD,OAAO,IAAI,CAAC,CAAC,CAAC;;MAEtC,MAAMqB,gBAAgB,GAAGD,cAAc,CAACtC,GAAG,CAAEP,IAAI,KAAM;QACrDsC,KAAK,EAAEtC,IAAI,CAACsC,KAAK;QACjBS,eAAe,EAAG,CAAC/C,IAAI,CAACC,KAAK,GAAGwB,OAAO,IAAIK,KAAK,GAAI,GAAG,GAAG,GAAG;QAC7DkB,WAAW,EAAEhD,IAAI,CAACC,KAAK,CAAE;MAC3B,CAAC,CAAC,CAAC;MAEH7C,YAAY,CAAC;QACX+E,MAAM,EAAEW,gBAAgB,CAACvC,GAAG,CAAEP,IAAI,IAAKA,IAAI,CAACsC,KAAK,CAAC;QAClDD,QAAQ,EAAE,CACR;UACEC,KAAK,EAAEW,gBAAgB,CAAClG,gBAAgB,CAAC;UACzCwF,IAAI,EAAEO,gBAAgB,CAACvC,GAAG,CAAEP,IAAI,IAAKA,IAAI,CAAC+C,eAAe,CAAC;UAC1DP,YAAY,EAAEM,gBAAgB,CAACvC,GAAG,CAAEP,IAAI,IAAKA,IAAI,CAACgD,WAAW,CAAC;UAAE;UAChEP,eAAe,EAAE,CACf,yBAAyB,EACzB,yBAAyB,EACzB,yBAAyB,EACzB,yBAAyB,EACzB,0BAA0B,EAC1B,yBAAyB,CAC1B;UACDC,WAAW,EAAE,CACX,uBAAuB,EACvB,uBAAuB,EACvB,uBAAuB,EACvB,uBAAuB,EACvB,wBAAwB,EACxB,uBAAuB,CACxB;UACDC,WAAW,EAAE;QACf,CAAC;MAEL,CAAC,CAAC;IACJ;EACF,CAAC,EAAE,CAAC5F,gBAAgB,EAAEJ,cAAc,EAAEsG,gBAAgB,CAAC,CAAC;;EAExD;EACAnH,SAAS,CAAC,MAAM;IACd8G,iBAAiB,CAAC,CAAC;EACrB,CAAC,EAAE,CAACA,iBAAiB,EAAE3F,SAAS,CAAC,CAAC;EAElC,oBACEX,OAAA;IAAK4G,KAAK,EAAE/G,MAAM,CAACgH,SAAU;IAAAC,QAAA,gBAC3B9G,OAAA,CAACL,YAAY;MACXQ,OAAO,EAAEA,OAAQ;MACjBM,gBAAgB,EAAEA,gBAAiB;MACnC2D,oBAAoB,EAAEA,oBAAqB;MAC3ClC,YAAY,EAAEA,YAAa;MAC3BC,eAAe,EAAEA;IAAgB;MAAA4E,QAAA,EAAAC,YAAA;MAAAC,UAAA;MAAAC,YAAA;IAAA,OAClC,CAAC,eACFlH,OAAA,CAACJ,QAAQ;MACPuB,QAAQ,EAAEA,QAAS;MACnBK,gBAAgB,EAAEA,gBAAiB;MACnC2F,gBAAgB,EAAEA,gBAAiB;MACnChH,OAAO,EAAEA,OAAQ;MACjBY,SAAS,EAAEA,SAAU;MACrBE,YAAY,EAAEA,YAAa;MAC3BZ,cAAc,EAAEA,cAAe;MAC/BE,aAAa,EAAEA,aAAc;MAC7BmB,QAAQ,EAAEA,QAAS;MACnBE,aAAa,EAAEA,aAAc;MAC7BE,aAAa,EAAEA,aAAc;MAC7BD,gBAAgB,EAAEA,gBAAiB;MACnCE,gBAAgB,EAAEA,gBAAiB;MACnCwC,mBAAmB,EAAEA,mBAAoB;MACzC5D,SAAS,EAAEA,SAAU;MACrBC,YAAY,EAAEA,YAAa;MAC3BC,SAAS,EAAEA;IAAU;MAAAkG,QAAA,EAAAC,YAAA;MAAAC,UAAA;MAAAC,YAAA;IAAA,OACtB,CAAC;EAAA;IAAAH,QAAA,EAAAC,YAAA;IAAAC,UAAA;IAAAC,YAAA;EAAA,OACC,CAAC;AAEV,CAAC;AAAChH,EAAA,CArSID,OAAO;AAAAmH,EAAA,GAAPnH,OAAO;AAuSb,eAAeA,OAAO;AAAC,IAAAmH,EAAA;AAAAC,YAAA,CAAAD,EAAA","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}